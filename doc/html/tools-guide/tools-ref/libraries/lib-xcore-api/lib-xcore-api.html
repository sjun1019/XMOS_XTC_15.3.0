<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../../genindex.html" /><link rel="search" title="Search" href="../../../../search.html" /><link rel="next" title="lib_xs1" href="../libxs1/lib-xs1-api.html" /><link rel="prev" title="Libraries" href="../index.html" />

    <link rel="shortcut icon" href="../../../../_static/x-favicon.png"/><!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>lib_xcore - XMOS XTC Tools v15.3</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #1399DB;
  --color-brand-content: #1399DB;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-brand-primary: #1399DB;
  --color-brand-content: #1399DB;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-brand-primary: #1399DB;
  --color-brand-content: #1399DB;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../../index.html"><div class="brand">XMOS XTC Tools v15.3</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../../../_static/x-logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">XMOS XTC Tools v15.3</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><!-- This html element presents a list of pdfs that can be generated -->
<!-- We expect pdfs to be in a folder called pdf alongside the folder called html -->

<!-- TODO: generate this list using JS only for real pdfs that exist -->

<!-- pathto(root_doc) set by sphinx for each page, but root doc has # -->

<div id="pdf_linker">
    <script>
        function openPDF(url) {
            if (url=="--select--") {
                return;
            }
            window.location.href = url;
        }
    </script>
    PDFs:
    <select title="Link to generated pdfs" onchange="openPDF(value);">
        <option>--select--</option>
        
        <option
            title="xtc_tools_introduction_v15.3.pdf"
            value="../../../../index.html/../../pdf/xtc_tools_introduction_v15.3.pdf"
        >
            XMOS XTC Tools - Introduction
        </option> 
        
        <option
            title="xtc_tools_installation_v15.3.pdf"
            value="../../../../index.html/../../pdf/xtc_tools_installation_v15.3.pdf"
        >
            XMOS XTC Tools - Installation
        </option> 
        
        <option
            title="xtc_tools_guide_v15.3.pdf"
            value="../../../../index.html/../../pdf/xtc_tools_guide_v15.3.pdf"
        >
            XMOS XTC Tools - Tools Guide
        </option> 
        
        <option
            title="xtc_prog_guide_v15.3.pdf"
            value="../../../../index.html/../../pdf/xtc_prog_guide_v15.3.pdf"
        >
            XMOS XTC Tools - Programming Guide
        </option> 
        
    </select>
</div>
<div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/index.html">Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../installation/index.html">Installation guide</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../installation/install-configure/system-requirements/requirements.html">System requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../installation/install-configure/install-tools/install.html">Installation instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../installation/install-configure/install-tools/install_prerequisites.html">Installation of required third-party tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../installation/install-configure/getting-started.html">Configuring the command-line environment</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../../index.html">Tools guide</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../quick-start/index.html">Quick start</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../quick-start/single-tile.html">A single-tile program</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../quick-start/multi-tile.html">Targeting multiple tiles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../quick-start/switch-setup.html">Communicating between tiles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../quick-start/fast-printf.html">Using xSCOPE for fast “printf debugging”</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../quick-start/debug.html">Debugging with XGDB</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../quick-start/build-system.html">Build system</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../vscode-guide/index.html">Using VS Code</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../vscode-guide/example/index.html">Building an example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../vscode-guide/next-steps/index.html">Using VS Code with a real project</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../tutorials/index.html">Tools and target features</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/describe-a-target-platform/platform.html">Describe a target platform</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../tutorials/working-with-targets/index.html">Working with targets</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#key-target-based-features">Key target-based features</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#xtag">xTAG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#host-tools">Host tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#target-interaction">Target interaction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#host-io">Host-IO</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#xscope-apis">xSCOPE APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#user-supplied-host-program">User-supplied host program</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#sample-based-profiling-of-the-target-program">Sample-based profiling of the target program</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#target-errors-and-warnings">Target errors and warnings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tutorials/working-with-targets/intro.html#command-examples">Command examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/design-with-flash/flash.html">Design and manufacture systems with flash memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/safeguard-ip/safeguard.html">Safeguard IP and device authenticity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/add-flash-support/flash.html">Add support for a new flash device</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/lpddr.html">Using LPDDR</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/swmem.html">Using software-defined memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/args-and-ret-codes.html">How to use arguments and return codes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/using-xsim.html">Using XSIM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/understanding-xe-structure.html">Understanding XE files and how they are loaded</a></li>
</ul>
</li>
<li class="toctree-l2 current has-children"><a class="reference internal" href="../../index.html">Reference</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l3 has-children"><a class="reference internal" href="../../cmd-line-tools/index.html">Command line tools</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cmd-line-tools/xrun-manual/xrun-manual.html">XRUN</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cmd-line-tools/xsim-manual/xsim-manual.html">XSIM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cmd-line-tools/xcc-manual/xcc-manual.html">XCC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cmd-line-tools/xobjdump-manual/xobjdump-manual.html">XOBJDUMP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cmd-line-tools/xgdb-manual/xgdb-manual.html">XGDB</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cmd-line-tools/xgdbserver-manual/xgdbserver-manual.html">XGDBSERVER</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cmd-line-tools/xflash-manual/xflash-manual.html">XFLASH</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cmd-line-tools/xburn-manual/xburn-manual.html">XBURN</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../cmd-line-tools/xmake-manual/xmake-manual.html">XMAKE</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../formats/index.html">File formats and data descriptions</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../formats/xe.html">XMOS executable (XE) file format</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../formats/xn-spec/xn-spec.html">XN specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../formats/xsim-trace.html">XSIM trace output</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../formats/config-xscope.html">xSCOPE config file</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../xscope/index.html">xSCOPE</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../xscope/xscope-command-line-options.html">xSCOPE command line options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../xscope/xscope-performance.html">xSCOPE performance figures</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../xscope/xscope-target-library.html">xSCOPE target library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../xscope/xscope-host-library.html">xSCOPE host library</a></li>
</ul>
</li>
<li class="toctree-l3 current has-children"><a class="reference internal" href="../index.html">Libraries</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l4 current current-page"><a class="current reference internal" href="#">lib_xcore</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../libxs1/lib-xs1-api.html">lib_xs1</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../libxs1/lib-xs1-defines-xs3a.html">XS3 definitions</a></li>
<li class="toctree-l5"><a class="reference internal" href="../libxs1/lib-xs1-defines-xs2a.html">XS2 definitions</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../libflash-api/libflash-api.html">libflash API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../libquadflash-api/libquadflash-api.html">libquadflash API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../libflash-included-devices/libflash-devices.html">List of devices natively supported by libflash</a></li>
<li class="toctree-l4"><a class="reference internal" href="../libquadflash-included-devices/libquadflash-devices.html">List of devices natively supported by libquadflash</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lib-otp-api/lib-otp-api.html">lib_otp</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../xcommon_cmake.html">XCommon CMake build system</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../xcommon/index.html">XCOMMON build system</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../xcommon/using-makefiles.html">Using the XCOMMON build system</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../xcommon/makefile-libraries.html">Using XMOS Makefiles to create binary libraries</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../transitioning/index.html">Transitioning from older tools releases</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../prog-guide/index.html">Programming guide</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../prog-guide/arch-hw-guide/index.html">Architecture &amp; hardware guide</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../../prog-guide/quick-start/index.html">Quick start</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../prog-guide/quick-start/prog-model.html">The multicore programming model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../prog-guide/quick-start/c-programming-guide/index.html">Programming an XCORE tile with C and lib_xcore</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../../prog-guide/prog-ref/index.html">Reference</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../../prog-guide/prog-ref/programming-in-c-xc.html">Programming in C/XC</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/calling-between-c-xc/calling.html">Calling between C/C++ and XC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/xc-imp-defined-behavior/xc-imp.html">XC implementation-defined behavior</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/c-imp-defined-behavior/c-imp.html">C implementation-defined behavior</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/c-lang-ref/clangref.html">C and C++ language reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/xcc-pragma-directives/pragmas.html">XCC pragma directives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/cheat.html">XC to C cheat sheet</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/memory-models.html">Memory models</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../../prog-guide/prog-ref/programming-in-asm.html">Programming in assembly</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" role="switch" type="checkbox"/><label for="toctree-checkbox-18"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/inline-assembly/inline-assembly.html">Inline assembly</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/assembly-for-xmos-xs1-abi/assembly-for-abi.html">Make assembly programs compatible with the XMOS XS1 ABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/assembly-manual/assembly.html">Assembly programming manual</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../../prog-guide/prog-ref/programming-xs1-devices.html">Programming for XCORE Devices</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" role="switch" type="checkbox"/><label for="toctree-checkbox-19"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/xs1-data-types/datatypes.html">xcore data types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/xs1-port-to-pin-map/portmap.html">xcore port-to-pin mapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../prog-guide/prog-ref/xs1-abi/abi.html">XCORE 32-bit application binary interface</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div></div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="lib-xcore">
<span id="lib-xcore-api"></span><h1>lib_xcore<a class="headerlink" href="#lib-xcore" title="Permalink to this heading">#</a></h1>
<p>lib_xcore is a system library that provides a C API for the underlying hardware
features of an xcore tile. A header file is provided for each functional area,
and can be included with a line such as:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;xcore/port.h&gt;</span>
</pre></div>
</div>
<p>By default, lib_xcore is automatically added to the list of libraries for
linking, so there is no need to use <a class="reference internal" href="../../cmd-line-tools/xcc-manual/xcc-manual.html#cmdoption-xcc-l"><code class="xref std std-option docutils literal notranslate"><span class="pre">xcc</span> <span class="pre">-l</span></code></a>.</p>
<section id="api-details">
<h2>API details<a class="headerlink" href="#api-details" title="Permalink to this heading">#</a></h2>
<section id="xcore-assert-h">
<h3>xcore/assert.h<a class="headerlink" href="#xcore-assert-h" title="Permalink to this heading">#</a></h3>
<p>Provides assertions similar to those defined by the standard C assert.h. </p>
<p>Assertions provided by this header are intended by behave similarly to the C standard assert. However by default, when enabled, these macros will expand to ‘hardware assisted’ assertions which cause processor exceptions upon failure. ‘Hardware assisted’ assertions can execute quickly and do not print any diagnostic information. This makes these assertions suitable for applications where small code size is desirable.</p>
<p>The behaviour of the (expansion of) macros defined in this header varies depending on the macros defined at the point it is first included. Specifically: <ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> is defined all assertions will expand to <code class="docutils literal notranslate"><span class="pre">((void)0)</span></code>; </p></li>
<li><p>Otherwise, if <code class="docutils literal notranslate"><span class="pre">LIBXCORE_XASSERT_IS_ASSERT</span></code> is <strong>not</strong> defined then the assertions will be ‘hardware assisted’ and will trap on failure without printing any diagnostic information; </p></li>
<li><p>Otherwise (i.e. <code class="docutils literal notranslate"><span class="pre">LIBXCORE_XASSERT_IS_ASSERT</span></code> is defined and <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> is not) the assertions will be implemented in terms of the C standard library <code class="docutils literal notranslate"><span class="pre">assert</span></code>. </p></li>
</ul>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c._XCORE_XASSERT_EMPTY">
<span class="target" id="assert_8h_1ad062ff2cb476810164510138de793e68"></span><span class="sig-name descname"><span class="n"><span class="pre">_XCORE_XASSERT_EMPTY</span></span></span><a class="headerlink" href="#c._XCORE_XASSERT_EMPTY" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c._XCORE_XASSERT_HIDE">
<span class="target" id="assert_8h_1a0f3448a5c4074c314176f3e49a7061a0"></span><span class="sig-name descname"><span class="n"><span class="pre">_XCORE_XASSERT_HIDE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_X</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._XCORE_XASSERT_HIDE" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c._XCORE_XASSERT_NOT_AFTER">
<span class="target" id="assert_8h_1ab8f3957244c5e1a67965a35817915d5f"></span><span class="sig-name descname"><span class="n"><span class="pre">_XCORE_XASSERT_NOT_AFTER</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_C</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._XCORE_XASSERT_NOT_AFTER" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c._XCORE_XASSERT_TRUE">
<span class="target" id="assert_8h_1ac9c46819db6087a4aaeac9e99e2b0baa"></span><span class="sig-name descname"><span class="n"><span class="pre">_XCORE_XASSERT_TRUE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_CONDITION</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._XCORE_XASSERT_TRUE" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c._XCORE_XASSERT_FALSE">
<span class="target" id="assert_8h_1a7c20a56892e2643f392df1ee3a47b494"></span><span class="sig-name descname"><span class="n"><span class="pre">_XCORE_XASSERT_FALSE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_CONDITION</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._XCORE_XASSERT_FALSE" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.xassert">
<span class="target" id="assert_8h_1a6ce19a5cf84bb26a3b2c1f6066d39983"></span><span class="sig-name descname"><span class="n"><span class="pre">xassert</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__condition</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xassert" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Assert that a given expression evaluates true. </p>
<p>Asserts that <em>condition</em> is true (nonzero). The actual behaviour when condition is false depends on the which configuration macros are defined.</p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p><em>condition</em> should not have side effects as these will not be executed when assertions are ineffective.</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__condition</strong> – The expression which is expected to evaluate true </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.xassert_not">
<span class="target" id="assert_8h_1ac18b89665a6678a575b071831eefebec"></span><span class="sig-name descname"><span class="n"><span class="pre">xassert_not</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__condition</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xassert_not" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Assert that a given expression evaluates false. </p>
<p>Asserts that <em>condition</em> is false (0). The actual behaviour when condition is true depends on the which configuration macros are defined.</p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p><em>condition</em> should not have side effects as these will not be executed when assertions are ineffective.</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__condition</strong> – The expression which is expected to evaluate true </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.xassert_not_after">
<span class="target" id="assert_8h_1a7d1a07e4db8461f03c9094a86ee08eab"></span><span class="sig-name descname"><span class="n"><span class="pre">xassert_not_after</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__timestamp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xassert_not_after" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Assert that the given timestamp is not in the past. </p>
<p>On XS2 and onwards this macro implements a timing assertion based on the reference clock. When <code class="docutils literal notranslate"><span class="pre">LIBXCORE_XASSERT_IS_ASSERT</span></code> is defined an approximation of the ‘hardware’ assert’s condition is used however this may be less accurate as checking the timestamp cannot be performed as a single instruction.</p>
<p>The macro LIBXCORE_HAS_TIMING_ASSERTIONS will be defined if and only if this assertion can be effective on the current platform.</p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p><em>timestamp</em> should not have side effects as these will not be executed when assertions are ineffective (including when timing assertions are not available on the current platform). </p>
</dd>
</dl>
</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>On XS1 devices this assertion will have no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__timestamp</strong> – The timestamp which is expected not to be in the past </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-chanend-h">
<h3>xcore/chanend.h<a class="headerlink" href="#xcore-chanend-h" title="Permalink to this heading">#</a></h3>
<p>Low level channel end API. </p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>It is strongly recommended that higher-level ‘channel’ protocols are used e.g. xcore/channel.h or xcore/channel_streaming.h </p>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.chanend_t">
<span class="target" id="chanend_8h_1adc20ea57f282ec60227914b648c1e050"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_t</span></span></span><a class="headerlink" href="#c.chanend_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Opaque channel end type for use in C/C++ code. </p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>Users must not access its raw underlying type. </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_alloc">
<span class="target" id="chanend_8h_1af2bb8d6811d3e83850fcf0948bf67d3a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_alloc</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_alloc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Allocate a single chanend. </p>
<p>If there are no channel ends available the function returns 0. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the channel end is no longer required, <a class="reference internal" href="#chanend_8h_1ac30ce62cb67f71e7fc79208ddbca0ef9"><span class="std std-ref">chanend_free()</span></a> should be called to deallocate it.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Allocated chanend (0 if none are available) </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_free">
<span class="target" id="chanend_8h_1ac30ce62cb67f71e7fc79208ddbca0ef9"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Deallocate a single chanend. </p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>The last transfer on the chanend must have been a CT_END token.</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – chanend to free.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chanend, an input/output is pending, or it has not received/sent a CT_END token. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chanend. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_set_dest">
<span class="target" id="chanend_8h_1a31f9eb88f611edd4d10598ab57a6b98d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_set_dest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__dst</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_set_dest" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the destination of a chanend. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – chanend to set. </p></li>
<li><p><strong>__dst</strong> – Destination chanend.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chanend. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chanend. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_get_dest">
<span class="target" id="chanend_8h_1aef3677e03a6c8cf8aeb534b938aba6bf"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_get_dest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_get_dest" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_out_byte">
<span class="target" id="chanend_8h_1ac1cc839240f415fbd1fa7ec0f8c21905"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_out_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">__b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_out_byte" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_out_word">
<span class="target" id="chanend_8h_1ae1e1d0cdaa1c4fc7cbdf5fa86a717805"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_out_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_out_word" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_out_control_token">
<span class="target" id="chanend_8h_1a61ba5b0b118b78caf93be5c7b5254c7e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_out_control_token</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">__ct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_out_control_token" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_in_byte">
<span class="target" id="chanend_8h_1a10534231d8c29bec356fee95cb283786"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_in_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_in_byte" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_in_word">
<span class="target" id="chanend_8h_1acc4a86a0cd9461912068e4cfe6756e75"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_in_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_in_word" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_in_control_token">
<span class="target" id="chanend_8h_1a9b239c181c503cd5f0a947d51f6c00ca"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_in_control_token</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_in_control_token" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_check_control_token">
<span class="target" id="chanend_8h_1aca99987837fba455da3200147ac47deb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_check_control_token</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">__ct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_check_control_token" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_test_control_token_next_byte">
<span class="target" id="chanend_8h_1a15296586a3ab37ecdfbe7c6d2d95c3da"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_test_control_token_next_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_test_control_token_next_byte" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_test_control_token_next_word">
<span class="target" id="chanend_8h_1a3014b77da96a0be0d4bb6fb583d7999a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_test_control_token_next_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_test_control_token_next_word" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_test_dest_local">
<span class="target" id="chanend_8h_1a03be4eaa53cf984736c61ceabeb73fc0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_test_dest_local</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_test_dest_local" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_set_network">
<span class="target" id="chanend_8h_1a30a46cad74c8684e50b424ed7b9d052d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_set_network</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__net</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_set_network" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_get_network">
<span class="target" id="chanend_8h_1afdc34fcc716c1cc71e74ac1c281de263"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_get_network</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_get_network" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_out_end_token">
<span class="target" id="chanend_8h_1ad52ec13f34e972e825e247d47906d22e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_out_end_token</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_out_end_token" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chanend_check_end_token">
<span class="target" id="chanend_8h_1aba58d2f8d0d9199c53568ef73c241175"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chanend_check_end_token</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chanend_check_end_token" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

</div>
</section>
<section id="xcore-channel-streaming-h">
<h3>xcore/channel_streaming.h<a class="headerlink" href="#xcore-channel-streaming-h" title="Permalink to this heading">#</a></h3>
<p>Streaming channel API. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_alloc">
<span class="target" id="channel__streaming_8h_1ab8813da97f953fab7c524070ecbfbbec"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.streaming_channel_t" title="streaming_channel_t"><span class="n"><span class="pre">streaming_channel_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_alloc</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_alloc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Allocate a streaming channel by allocating two hardware chan-ends and joining them. </p>
<p>If there are not enough chan-ends available the function returns a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a> with both fields set to 0. <dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>The chan-ends must be accessed on the same tile</p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a> is no longer required, <a class="reference internal" href="#channel__streaming_8h_1a3b0d6a648326511534764663e6daf20e"><span class="std std-ref">s_chan_free()</span></a> should be called to deallocate it.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a> variable holding the two initialised and joined chan-ends or 0s. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_free">
<span class="target" id="channel__streaming_8h_1a3b0d6a648326511534764663e6daf20e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.streaming_channel_t" title="streaming_channel_t"><span class="n"><span class="pre">streaming_channel_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Deallocate a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a> by freeing its two hardware chan-ends. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a> to free.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>a chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated channel, or an input/output is pending. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the channel. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_out_word">
<span class="target" id="channel__streaming_8h_1a9fb72667f9261b0cf16463f2f1bfb667"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_out_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_out_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a word over a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a>. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The streaming chan-end </p></li>
<li><p><strong>__data</strong> – The word to be output</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_out_byte">
<span class="target" id="channel__streaming_8h_1a6360304481decb822151c2d0d0d0f634"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_out_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_out_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output an byte over a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a>. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The streaming chan-end </p></li>
<li><p><strong>__data</strong> – The byte to be output</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_out_buf_word">
<span class="target" id="channel__streaming_8h_1af180ea9be7a345a52c96c68028796855"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_out_buf_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_out_buf_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a block of data over a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a>. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The streaming chan-end </p></li>
<li><p><strong>__buf</strong> – A pointer to the buffer containing the data to send </p></li>
<li><p><strong>__n</strong> – The number of words to send</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>buf[]</em> argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_out_buf_byte">
<span class="target" id="channel__streaming_8h_1ae2dee4be82308383fbd3c2cb428ada0f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_out_buf_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_out_buf_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a block of data over a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a>. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The streaming chan-end </p></li>
<li><p><strong>__buf</strong> – A pointer to the buffer containing the data to send </p></li>
<li><p><strong>__n</strong> – The number of bytes to send</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>buf[]</em> argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_in_word">
<span class="target" id="channel__streaming_8h_1a8c16382c5de7d963b6cfc066969463c0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_in_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_in_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a word from a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a>. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The streaming chan-end </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or has pending control token. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The word read from the channel</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_in_byte">
<span class="target" id="channel__streaming_8h_1ad0651c62eb6e6ec49b2d0360caae11cb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_in_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_in_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a byte from a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a>. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The streaming chan-end </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or has pending control token. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The byte read from the channel</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_in_buf_word">
<span class="target" id="channel__streaming_8h_1a6ca147d368160511aa4172bf908b0842"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_in_buf_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_in_buf_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a block of data from a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a>. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The streaming chan-end </p></li>
<li><p><strong>__buf</strong> – A pointer to the memory region to fill </p></li>
<li><p><strong>__n</strong> – The number of words to receive</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or has pending control token. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-even">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-even"><p>invalid <em>buf[]</em> argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.s_chan_in_buf_byte">
<span class="target" id="channel__streaming_8h_1a9ac98aee8c504facb649eb8289e5da42"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">s_chan_in_buf_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.s_chan_in_buf_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a block of data from a <a class="reference internal" href="#structstreaming__channel__t"><span class="std std-ref">streaming_channel_t</span></a>. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The streaming chan-end </p></li>
<li><p><strong>__buf</strong> – A pointer to the memory region to fill </p></li>
<li><p><strong>__n</strong> – The number of bytes to receive</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or has pending control token. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-even">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-even"><p>invalid <em>buf[]</em> argument. </p>
</dd>
</dl>
</dd></dl>

</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.streaming_channel_t">
<span class="target" id="structstreaming__channel__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">streaming_channel_t</span></span></span><a class="headerlink" href="#c.streaming_channel_t" title="Permalink to this definition">#</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;channel_streaming.h&gt;</em></div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.streaming_channel_t.end_a">
<span class="target" id="structstreaming__channel__t_1a7d6215051812ccfd0d29dad7b8d9f4f9"></span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">end_a</span></span></span><a class="headerlink" href="#c.streaming_channel_t.end_a" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.streaming_channel_t.end_b">
<span class="target" id="structstreaming__channel__t_1acb03dcf72b2b79afdd0a8ed86de6e225"></span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">end_b</span></span></span><a class="headerlink" href="#c.streaming_channel_t.end_b" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</section>
<section id="xcore-channel-transaction-h">
<h3>xcore/channel_transaction.h<a class="headerlink" href="#xcore-channel-transaction-h" title="Permalink to this heading">#</a></h3>
<p>API for transaction-based channel communications. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.transacting_chanend_t">
<span class="target" id="channel__transaction_8h_1aadeb1ea145ae9da64213503927f4e04f"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">__xcore_transacting_chanend_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">transacting_chanend_t</span></span></span><a class="headerlink" href="#c.transacting_chanend_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>An opaque type for handling transactions. </p>
<p>Users must not access its raw underlying type. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.chan_init_transaction_master">
<span class="target" id="channel__transaction_8h_1ab244a9b46b095a3dfc1a445af2cc57a2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_init_transaction_master</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_init_transaction_master" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Start a transaction (master). </p>
<p>This initiates a transaction on a channel.</p>
<p>A transacting_chanend_t is used to temporarily open a transaction route through a channel. During the transaction, you can use transaction channel operations for increased efficiency. You can create a transacting chanend from a normal <em>chanend</em> using <a class="reference internal" href="#channel__transaction_8h_1ab244a9b46b095a3dfc1a445af2cc57a2"><span class="std std-ref">chan_init_transaction_master()</span></a> and <a class="reference internal" href="#channel__transaction_8h_1a458531903eb9881b74df7ab5602bd341"><span class="std std-ref">chan_init_transaction_slave()</span></a>.</p>
<p>This called must be matched by a call to <a class="reference internal" href="#channel__transaction_8h_1a458531903eb9881b74df7ab5602bd341"><span class="std std-ref">chan_init_transaction_slave()</span></a> on the other end of the channel.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A transaction must be closed with <a class="reference internal" href="#channel__transaction_8h_1aa9c6a2b2303a60d1b14ddca1c5211281"><span class="std std-ref">chan_complete_transaction()</span></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – chan-end to initialize the transaction on. </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the intialized master transacting_chanend_t</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_init_transaction_slave">
<span class="target" id="channel__transaction_8h_1a458531903eb9881b74df7ab5602bd341"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_init_transaction_slave</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_init_transaction_slave" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Start a transaction (slave). </p>
<p>This call must be matched by a call to <a class="reference internal" href="#channel__transaction_8h_1ab244a9b46b095a3dfc1a445af2cc57a2"><span class="std std-ref">chan_init_transaction_master()</span></a> on the other end of the channel.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A transaction must be closed with <a class="reference internal" href="#channel__transaction_8h_1aa9c6a2b2303a60d1b14ddca1c5211281"><span class="std std-ref">chan_complete_transaction()</span></a>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The original channed <em>c</em> must not be used until the transaction is closed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – chan-end to initialize the transaction on. chanend is invalidated </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or does not contain CT_END token. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the intialized slave transacting_chanend_t</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_complete_transaction">
<span class="target" id="channel__transaction_8h_1aa9c6a2b2303a60d1b14ddca1c5211281"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_complete_transaction</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__tc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_complete_transaction" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Completes a transaction. After this call the route between the two ends of the channel is freed allowing other channels to use the communication network. </p>
<p>Whilst the transacting_chanend_t is now invalid, the channel remains allocated, awaiting another transaction or deallocation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This call must be accompanied by a call to <a class="reference internal" href="#channel__transaction_8h_1aa9c6a2b2303a60d1b14ddca1c5211281"><span class="std std-ref">chan_complete_transaction()</span></a> on the other end of the channel.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__tc</strong> – Transacting chan-end to close. </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The original chan-end which is valid once again.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.t_chan_out_word">
<span class="target" id="channel__transaction_8h_1abc8195dfc173f70dfab503d5213151f4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">t_chan_out_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__tc</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.t_chan_out_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a word over a transacting chan-end. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__tc</strong> – <strong>[inout]</strong> Transacting chan-end </p></li>
<li><p><strong>__data</strong> – Word to be output</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>tc</em> argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.t_chan_out_byte">
<span class="target" id="channel__transaction_8h_1ad5458b98b350b09d10d71522699d8813"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">t_chan_out_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__tc</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.t_chan_out_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output an byte over a transacting chan-end. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__tc</strong> – <strong>[inout]</strong> Transacting chan-end </p></li>
<li><p><strong>__data</strong> – Byte to be output</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>tc</em> argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.t_chan_out_buf_word">
<span class="target" id="channel__transaction_8h_1a8b5e54f63b46cfead4f4b4699642df95"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">t_chan_out_buf_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__tc</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.t_chan_out_buf_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a block of data over a transacting chan-end. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__tc</strong> – <strong>[inout]</strong> Transacting chan-end </p></li>
<li><p><strong>__buf</strong> – <strong>[in]</strong> Pointer to the buffer containing the data to send </p></li>
<li><p><strong>__n</strong> – Number of words to send</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>tc</em> or <em>buf</em>[] argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.t_chan_out_buf_byte">
<span class="target" id="channel__transaction_8h_1a6884d9f57f7df8fcd5341c036723d85f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">t_chan_out_buf_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__tc</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.t_chan_out_buf_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a block of data over a transacting chan-end. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__tc</strong> – <strong>[inout]</strong> Transacting chan-end </p></li>
<li><p><strong>__buf</strong> – <strong>[in]</strong> Pointer to the buffer containing the data to send </p></li>
<li><p><strong>__n</strong> – Number of bytes to send</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>tc</em> or <em>buf</em>[] argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.t_chan_in_word">
<span class="target" id="channel__transaction_8h_1ac5de4b87f94142e8e4f1c6e553427c71"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">t_chan_in_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__tc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.t_chan_in_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a word from a transacting chan-end. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__tc</strong> – <strong>[inout]</strong> Transacting chan-end </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>tc</em> argument. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Word read from <em>tc</em> </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.t_chan_in_byte">
<span class="target" id="channel__transaction_8h_1afa03211de0bf54b26b142795179dd1c3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">t_chan_in_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__tc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.t_chan_in_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a byte from a transacting chan-end. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__tc</strong> – <strong>[inout]</strong> Transacting chan-end </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>tc</em> or <em>data</em> argument. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Byte read from <em>tc</em> </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.t_chan_in_buf_word">
<span class="target" id="channel__transaction_8h_1a2bcd146f8cbac72298f202dbffb5bd87"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">t_chan_in_buf_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__tc</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.t_chan_in_buf_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a block of data from a transacting chan-end. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__tc</strong> – <strong>[inout]</strong> Transacting chan-end </p></li>
<li><p><strong>__buf</strong> – <strong>[in]</strong> Pointer to the memory region to fill </p></li>
<li><p><strong>__n</strong> – The number of words to receive</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>tc</em> or <em>buf</em>[] argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.t_chan_in_buf_byte">
<span class="target" id="channel__transaction_8h_1aeec21f0cd101ef1e4da3d5d9abfcd33b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">t_chan_in_buf_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.transacting_chanend_t" title="transacting_chanend_t"><span class="n"><span class="pre">transacting_chanend_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__tc</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.t_chan_in_buf_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a block of data from a transacting chan-end. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__tc</strong> – <strong>[inout]</strong> Transacting chan-end </p></li>
<li><p><strong>__buf</strong> – <strong>[in]</strong> Pointer to the memory region to fill </p></li>
<li><p><strong>__n</strong> – The number of bytes to receive</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>__tc</em> or <em>__buf</em> argument. </p>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-channel-h">
<h3>xcore/channel.h<a class="headerlink" href="#xcore-channel-h" title="Permalink to this heading">#</a></h3>
<p>API for channel communications. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.channel_t">
<span class="target" id="channel_8h_1a30e77e0b6fd428a0cceed4edb1ddbd20"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="#c.streaming_channel_t" title="streaming_channel_t"><span class="n"><span class="pre">streaming_channel_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">channel_t</span></span></span><a class="headerlink" href="#c.channel_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Helper type for passing around both ends of a channel. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.chan_alloc">
<span class="target" id="channel_8h_1aa1d778c63557d438699d5f638fcc39d9"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.channel_t" title="channel_t"><span class="n"><span class="pre">channel_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_alloc</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_alloc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Allocates a channel by allocating two hardware chan-ends and joining them. </p>
<p>If there are not enough chan-ends available the function returns a channel_t with both fields set to 0. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the channel_t is no longer required, <a class="reference internal" href="#channel_8h_1ac6b740213d9c77d0af868082504270ff"><span class="std std-ref">chan_free()</span></a> should be called to deallocate it.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The chan-ends must be accessed on the same tile.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The channel_t (both fields will be 0 if allocation was not possible) </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_free">
<span class="target" id="channel_8h_1ac6b740213d9c77d0af868082504270ff"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.channel_t" title="channel_t"><span class="n"><span class="pre">channel_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Deallocate a channel by freeing its constituent chan-ends. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – channel_t to free</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chanend. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_out_word">
<span class="target" id="channel_8h_1a62c9d4eb6db1e8800eebe6ee400a5797"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_out_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_out_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a word over a channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The chan-end </p></li>
<li><p><strong>__data</strong> – The word to be output</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_out_byte">
<span class="target" id="channel_8h_1a07da4369683e1d5d0342e9de2815d840"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_out_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_out_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a byte over a channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The chan-end </p></li>
<li><p><strong>__data</strong> – The byte to be output</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_out_buf_word">
<span class="target" id="channel_8h_1ae089b174094fb8b9ce810b475a1d0a80"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_out_buf_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_out_buf_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a block of data over a channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The chan-end </p></li>
<li><p><strong>__buf</strong> – <strong>[in]</strong> A pointer to the buffer containing the data to send </p></li>
<li><p><strong>__n</strong> – The number of words to send</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>buf</em>[] argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_out_buf_byte">
<span class="target" id="channel_8h_1a3364abf4c8e911aeb3f56e5743223c55"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_out_buf_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_out_buf_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a block of data over a channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The chan-end </p></li>
<li><p><strong>__buf</strong> – <strong>[in]</strong> A pointer to the buffer containing the data to send </p></li>
<li><p><strong>__n</strong> – The number of bytes to send</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_LINK_ERROR<span class="colon">:</span></dt>
<dd class="field-even"><p>chan-end destination is not set. </p>
</dd>
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-even">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-even"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-odd">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-odd"><p>invalid <em>buf</em>[] argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_in_word">
<span class="target" id="channel_8h_1a15d0277de70aec0e59a812f071b1e972"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_in_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_in_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a word from a channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The chan-end </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-even">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-even"><p>invalid **data* argument. </p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The word which was read from the channel</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_in_byte">
<span class="target" id="channel_8h_1a9d18d51a8c17b07fc164181c8b6a3288"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_in_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_in_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a byte from a channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The chan-end </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-even">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-even"><p>invalid **data* argument. </p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The byte which was read from the channel</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_in_buf_word">
<span class="target" id="channel_8h_1ac4bfbb4159486529942862390954ca21"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_in_buf_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_in_buf_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a block of data from a channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The chan-end </p></li>
<li><p><strong>__buf</strong> – <strong>[out]</strong> A pointer to the memory region to fill </p></li>
<li><p><strong>__n</strong> – The number of words to receive</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-even">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-even"><p>invalid <em>buf[]</em> argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.chan_in_buf_byte">
<span class="target" id="channel_8h_1ac6130f8d9cb5874ae582a12fd4c853bb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">chan_in_buf_byte</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.chanend_t" title="chanend_t"><span class="n"><span class="pre">chanend_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__c</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__buf</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.chan_in_buf_byte" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a block of data from a channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__c</strong> – The chan-end </p></li>
<li><p><strong>__buf</strong> – <strong>[out]</strong> A pointer to the memory region to fill </p></li>
<li><p><strong>__n</strong> – The number of bytes to receive</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated chan-end, or channel handshaking corrupted. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the chan-end. </p>
</dd>
<dt class="field-even">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-even"><p>invalid <em>buf[]</em> argument. </p>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-clock-h">
<h3>xcore/clock.h<a class="headerlink" href="#xcore-clock-h" title="Permalink to this heading">#</a></h3>
<p>Hardware clock API. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.xclock_t">
<span class="target" id="clock_8h_1a33ffe5be890fbeca324152583cf36c2f"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xclock_t</span></span></span><a class="headerlink" href="#c.xclock_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clock handle type. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.clock_enable">
<span class="target" id="clock_8h_1af7c0d8017dbe8c80956b4360a5aeb85a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_enable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_enable" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Enables a specified clock block so that it may be used. </p>
<p>Should be called before any other operations are performed on the given <code class="docutils literal notranslate"><span class="pre">id</span></code>. When the clock is no longer required is should be disabled again with <a class="reference internal" href="#clock_8h_1a343ee3c72d60ef8c88920eca8e760b0b"><span class="std std-ref">clock_disable()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__id</strong> – The id of the clock to enable</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid clock. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the clock. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.clock_disable">
<span class="target" id="clock_8h_1a343ee3c72d60ef8c88920eca8e760b0b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_disable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_disable" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Disable a clock. </p>
<p>/note Once disabled, a the clock must be re-enabled using <a class="reference internal" href="#clock_8h_1af7c0d8017dbe8c80956b4360a5aeb85a"><span class="std std-ref">clock_enable()</span></a> before it can be used again.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__clk</strong> – The clock to be disabled</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid clock. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the clock. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.clock_start">
<span class="target" id="clock_8h_1a5310c05a486fd2241b2fbbbec66c11de"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_start</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_start" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Start a clock. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__clk</strong> – The clock to start running</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid clock. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the clock. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.clock_stop">
<span class="target" id="clock_8h_1a52421c85ae712e793f1d68f95f91bbff"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_stop</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_stop" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Stop a clock. </p>
<p>Waits until the clock is low and then pauses a clock.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__clk</strong> – The clock to stop</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid clock. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the clock. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.clock_set_source_port">
<span class="target" id="clock_8h_1a961d4c69c655b388fd9a04b1108ec2e1"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_set_source_port</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span>, <span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_set_source_port" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configure a clock’s source to a 1-bit port. </p>
<p>A clock can be a 1-bit port, the reference clock or the xCORE clock. Note that if the xCORE clock is used then a non-zero divide must be used for ports to function correctly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__clk</strong> – The clock to configure </p></li>
<li><p><strong>__p</strong> – The 1-bit port to set as the clock input. Attempting to set a port which is not 1-bit as the input will cause an exception.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid clock or port, or the clock is running, or p not a one bit port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the clock. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.clock_set_source_clk_ref">
<span class="target" id="clock_8h_1a3d925b60a74ad7cfaa0edebbbfcc56a7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_set_source_clk_ref</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_set_source_clk_ref" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configure a clock’s source to be the 100MHz reference clock. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__clk</strong> – The clock to configure</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid clock, or the clock is running. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the clock. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.clock_set_source_clk_xcore">
<span class="target" id="clock_8h_1af066fb2a3184d7656f098e36bac0e167"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_set_source_clk_xcore</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_set_source_clk_xcore" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configure a clock’s source to be the xCORE clock. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using the xCORE clock as the clock input a divide of &gt; 0 must be used for the ports to function correclty.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__clk</strong> – The clock to configure</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid clock, or the clock is running. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the clock. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.clock_set_divide">
<span class="target" id="clock_8h_1a4e6ebed85c4c965117efc96ca40eaaf8"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_set_divide</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">__divide</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_set_divide" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configure the divider for a clock. </p>
<p>A clock can divide its input signal by an integer value which this function specifies. The XS2 architecture supports dividing the signal from a 1-bit port while the XS1 architecture will raise a trap if a non-zero divide is used with a 1-bit port input.</p>
<p>If the divide is 0 then the value signal will be passed through the clock. If the value is non-zero then the clock output will be divided by 2*divide.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the clock has been started then this will raise a trap.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__clk</strong> – The clock to configure </p></li>
<li><p><strong>__divide</strong> – The divide value</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid clock, or the clock is running. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the clock. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.clock_set_ready_src">
<span class="target" id="clock_8h_1a61258d6e736c3860d58ce7d589bf2458"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_set_ready_src</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span>, <span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__ready_source</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_set_ready_src" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sets a clock to use a 1-bit port for the ready-in signal. </p>
<p>If the port is not a 1-bit port then an exception is raised. The ready-in port controls when data is sampled from the pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__clk</strong> – The clock to configure. </p></li>
<li><p><strong>__ready_source</strong> – The 1-bit port to use for the ready-in signal.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid clock, or ready_source not a one bit port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the clock. </p>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-hwtimer-h">
<h3>xcore/hwtimer.h<a class="headerlink" href="#xcore-hwtimer-h" title="Permalink to this heading">#</a></h3>
<p>API for using hardware timers to measure and wait time. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.hwtimer_t">
<span class="target" id="hwtimer_8h_1a758b811aa82e7aa7823b18070708dc62"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_t</span></span></span><a class="headerlink" href="#c.hwtimer_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>brief Hardware timer handle type. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_free_xc_timer">
<span class="target" id="hwtimer_8h_1ad5b9dc1872552490893e284c0f4d4028"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_free_xc_timer</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_free_xc_timer" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Deallcoates the hardware timer automatically allocated. </p>
<p>for xC use. Each logical core is allocated a hardware timer that is multiplexed and used by the xC ‘timer’ interface. This multiplexed timer is not accessible from C. If the logical core is not running any xC code, or any xC code is not making use of the ‘timer’ resource type, the allocated hardware timer may be retrieved for use as a hwtimer_t.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This call must be paired with a call to <a class="reference internal" href="#hwtimer_8h_1a95d6ebfdc43d8cd7181d9800769d63a4"><span class="std std-ref">hwtimer_realloc_xc_timer()</span></a> prior to the logical core completing its tasks.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The xScope link also requires a hardware timer.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-odd"><p>timer has already been deallocated. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_realloc_xc_timer">
<span class="target" id="hwtimer_8h_1a95d6ebfdc43d8cd7181d9800769d63a4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_realloc_xc_timer</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_realloc_xc_timer" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Reallcoates a logical core’s xC hardware timer that was. </p>
<p>deallocated by a call to <a class="reference internal" href="#hwtimer_8h_1ad5b9dc1872552490893e284c0f4d4028"><span class="std std-ref">hwtimer_free_xc_timer()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>There must be an available hw timer when this call is made, otherwise a trap will be raised.</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Throws ET_ECALL<span class="colon">:</span></dt>
<dd class="field-odd"><p>no available hw timer, reallocation failed. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_alloc">
<span class="target" id="hwtimer_8h_1adae9619a3daf386e6713b92c7c4529b9"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.hwtimer_t" title="hwtimer_t"><span class="n"><span class="pre">hwtimer_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_alloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_alloc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Allocates a hardware timer. </p>
<p>If there are no timers available then 0 is returned. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the timer is no longer required, <a class="reference internal" href="#hwtimer_8h_1ac426912c8b86d0ec6a687a5ad20b5f10"><span class="std std-ref">hwtimer_free()</span></a> should be called to deallocate it.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Timer handle to the allocated timer </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_free">
<span class="target" id="hwtimer_8h_1ac426912c8b86d0ec6a687a5ad20b5f10"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.hwtimer_t" title="hwtimer_t"><span class="n"><span class="pre">hwtimer_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Deallocate a timer. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__t</strong> – The timer to be freed</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated timer. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the timer. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_get_time">
<span class="target" id="hwtimer_8h_1adbcad6e3575af69a2e7a94b2fc0f746d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_get_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.hwtimer_t" title="hwtimer_t"><span class="n"><span class="pre">hwtimer_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_get_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get the current time from the timer. </p>
<p>If there is a trigger time setup, the call will stall until after the trigger time. For select and interrupt event, calling <a class="reference internal" href="#hwtimer_8h_1adbcad6e3575af69a2e7a94b2fc0f746d"><span class="std std-ref">hwtimer_get_time()</span></a> will clear the event.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__t</strong> – The timer to read </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated timer. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the timer. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The time value (a 32-bit value)</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_get_trigger_time">
<span class="target" id="hwtimer_8h_1a08a7418b90c7af2824506aa2286b0c4f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_get_trigger_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.hwtimer_t" title="hwtimer_t"><span class="n"><span class="pre">hwtimer_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_get_trigger_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get the trigger time value. </p>
<p>The trigger time value is set using <a class="reference internal" href="#hwtimer_8h_1a8aa754010945286e8ec8242c45b2f119"><span class="std std-ref">hwtimer_set_trigger_time()</span></a>. The trigger may be cleared using <a class="reference internal" href="#hwtimer_8h_1a946c7839fb3aae8f1679a7c52de21e03"><span class="std std-ref">hwtimer_clear_trigger_time()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__t</strong> – The timer whose time value is requested. </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid timer. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the timer. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The time value</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_set_trigger_time">
<span class="target" id="hwtimer_8h_1a8aa754010945286e8ec8242c45b2f119"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_set_trigger_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.hwtimer_t" title="hwtimer_t"><span class="n"><span class="pre">hwtimer_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__time</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_set_trigger_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Setup an event trigger on a timer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This will cause <a class="reference internal" href="#hwtimer_8h_1adbcad6e3575af69a2e7a94b2fc0f746d"><span class="std std-ref">hwtimer_get_time()</span></a> to pause until the specified time. The trigger may be cleared using <a class="reference internal" href="#hwtimer_8h_1a946c7839fb3aae8f1679a7c52de21e03"><span class="std std-ref">hwtimer_clear_trigger_time()</span></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#hwtimer_8h_1a08855cb73d02c10ea77f3e5d07ff080f"><span class="std std-ref">hwtimer_wait_until()</span></a>, <a class="reference internal" href="#hwtimer_8h_1a141040bfe6f8d5e39cf96f78e19cf5b7"><span class="std std-ref">hwtimer_delay()</span></a>, hwtimer_setup_select() and hwtimer_setup_select_callback() call <a class="reference internal" href="#hwtimer_8h_1a8aa754010945286e8ec8242c45b2f119"><span class="std std-ref">hwtimer_set_trigger_time()</span></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__t</strong> – The timer to setup a event trigger on. </p></li>
<li><p><strong>__time</strong> – The time at which the timer will trigger an event. The default timer ticks are at a 10ns resolution.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid timer. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the timer. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_change_trigger_time">
<span class="target" id="hwtimer_8h_1a455f0fa1296b9d9490738e7548b70b11"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_change_trigger_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.hwtimer_t" title="hwtimer_t"><span class="n"><span class="pre">hwtimer_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__time</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_change_trigger_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Change the time at which a timer trigger will fire. </p>
<p>This function modifies the time at which a previously setup trigger fires. It is used to set a new trigger time after a select or interrupt event has occurred.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__t</strong> – The timer to change </p></li>
<li><p><strong>__time</strong> – The time at which the timer will trigger an event. The default timer ticks are at a 10ns resolution.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid timer. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the timer. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_clear_trigger_time">
<span class="target" id="hwtimer_8h_1a946c7839fb3aae8f1679a7c52de21e03"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_clear_trigger_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.hwtimer_t" title="hwtimer_t"><span class="n"><span class="pre">hwtimer_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_clear_trigger_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear an event trigger on a timer. </p>
<p>Makes sure no triggers are setup on a timer. Should be called when a timer is no longer being used for select and interrupt events. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <a class="reference internal" href="#hwtimer_8h_1a08855cb73d02c10ea77f3e5d07ff080f"><span class="std std-ref">hwtimer_wait_until()</span></a> and <a class="reference internal" href="#hwtimer_8h_1a141040bfe6f8d5e39cf96f78e19cf5b7"><span class="std std-ref">hwtimer_delay()</span></a> call <a class="reference internal" href="#hwtimer_8h_1a946c7839fb3aae8f1679a7c52de21e03"><span class="std std-ref">hwtimer_clear_trigger_time()</span></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__t</strong> – The timer to tear down events on</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid timer. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the timer. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_wait_until">
<span class="target" id="hwtimer_8h_1a08855cb73d02c10ea77f3e5d07ff080f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_wait_until</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__t</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__until</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_wait_until" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Wait until after a specified time. </p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>This will destroy any select or interrupt event triggers set on this resource.</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__t</strong> – The timer to use for timing </p></li>
<li><p><strong>__until</strong> – The time to wait until </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated timer. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the timer. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The time we actually waited until</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_delay">
<span class="target" id="hwtimer_8h_1a141040bfe6f8d5e39cf96f78e19cf5b7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_delay</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__t</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__period</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_delay" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Delay for a specified time using a specific timer. </p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>This will destroy any select or interrupt event triggers set on this resource</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__t</strong> – The timer resource to use </p></li>
<li><p><strong>__period</strong> – The amount of time to wait (in reference time ticks, usually 10ns steps)</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated timer. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the timer. </p>
</dd>
<dt class="field-even">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-even"><p>invalid **now* argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.hwtimer_time_after">
<span class="target" id="hwtimer_8h_1a3cec9e8bda11f08b777588a9edbcf820"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hwtimer_time_after</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__a</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hwtimer_time_after" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Compare two timestamps. </p>
<p>Convenience function which checks if a timestamp <em>a</em> is later than another timestamp <strong></strong>. Returns a nonzero value if <em>a</em> occurs after <em>b</em>, or zero otherwise. Returns 0 if <em>a</em> and <em>b</em> are equal.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Timestamps have a limited range and can overflow and wrap to 0 (hence they cannot be compared trivially). A timestamp is considered ‘after’ another one if it is ahead by no more than half the range of a hwtimer. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Equivalent to XC’s <em>timeafter</em> from <em>xs1.h</em> </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__a</strong> – Timestamp to compare to <em>__b</em> </p></li>
<li><p><strong>__b</strong> – Reference timestamp</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.get_reference_time">
<span class="target" id="hwtimer_8h_1a05a6ffc3399895835f057eabafc931bd"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_reference_time</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_reference_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>get the chip reference time </p>
<p>Gets the current reference time without requiring an allocated timer on chips where a reference time is available. This can be tested with <em>LIBXCORE_HWTIMER_HAS_REFERENCE_TIME</em> which will be defined if and only if a refence time is available. If no reference time is available then 0 is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The reference time </p>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-interrupt-wrappers-h">
<h3>xcore/interrupt_wrappers.h<a class="headerlink" href="#xcore-interrupt-wrappers-h" title="Permalink to this heading">#</a></h3>
<p>Helpers for implementing interrupt-enabled functions. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.LIBXCORE_KSTACK_WORDS">
<span class="target" id="interrupt__wrappers_8h_1abaab51c5f0c343467635ac05abaabd1e"></span><span class="sig-name descname"><span class="n"><span class="pre">LIBXCORE_KSTACK_WORDS</span></span></span><a class="headerlink" href="#c.LIBXCORE_KSTACK_WORDS" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Specify the minimum kernel stack size the interrupt permitting function should create. </p>
<p>The user may specify a minimum kstack size by setting the <a class="reference internal" href="#interrupt__wrappers_8h_1abaab51c5f0c343467635ac05abaabd1e"><span class="std std-ref">LIBXCORE_KSTACK_WORDS</span></a> define in their Makefile. This should be done when the kstack is being used by more than interrupt_callback_t functions. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFINE_INTERRUPT_PERMITTED">
<span class="target" id="interrupt__wrappers_8h_1ab3931919687f6aa0af8a028fa23ee386"></span><span class="sig-name descname"><span class="n"><span class="pre">DEFINE_INTERRUPT_PERMITTED</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__group</span></span>, <span class="n"><span class="pre">__ret</span></span>, <span class="n"><span class="pre">__root_function</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_INTERRUPT_PERMITTED" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Define a function that allows interrupts to occur within its scope. </p>
<p>This macro will define two functions for you:<ul class="simple">
<li><p>An ordinary function that may be called directly Its signature will be <code class="docutils literal notranslate">  <span class="pre">(</span> <span class="pre">...</span> <span class="pre">)</span></code></p></li>
<li><p>A function that will also reserve space for and set up a stack for handling interrupts. The function name is accessed using the <a class="reference internal" href="#interrupt__wrappers_8h_1ade5cd6df6c5ae91d261cf1a27aa03597"><span class="std std-ref">INTERRUPT_PERMITTED()</span></a> macro</p></li>
</ul>
</p>
<p>You would normally use this macro on the definition of the root function which will be called in a par statement. The interrupt stack (kernel stack) is created on the core’s stack with the ksp and sp being modified as necessary. When the functions exits, neither the kernel stack nor ksp is valid.</p>
<p>The kernel stack allocated has enough space for the interrupt_callback_t function (+callees) in the given <em>group</em>. The use of the <em>group</em> identifier allows a kernel stack to be no larger than that required by its greediest member.</p>
<p>
The user may specify a larger kernel stack by defining LIBXCORE_KSTACK_WORDS.</p>
<p>Example usage:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DEFINE_INTERRUPT_PERMITTED</span><span class="p">(</span><span class="n">groupA</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">rootfunc</span><span class="p">,</span> <span class="n">chanend</span> <span class="n">c</span><span class="p">,</span> <span class="nb">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">body</span> <span class="n">of</span> <span class="s1">&#39;int rootfunc(chanend c, int i)&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The kernel stack is not re-entrant so kernel mode must not be masked from within an interrupt_callback_t</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__group</strong> – this is the group of interrupt_callback_t function that may be safely enabled - see <a class="reference internal" href="#interrupt__wrappers_8h_1af100b86f3a19155e092d9ee8e738856c"><span class="std std-ref">DEFINE_INTERRUPT_CALLBACK()</span></a> </p></li>
<li><p><strong>__ret</strong> – the return type of the ordinary function; the return type must be a non-union, non-aggregate type not larger than <code class="docutils literal notranslate"><span class="pre">int</span></code> </p></li>
<li><p><strong>__root_function</strong> – the name of the ordinary function </p></li>
<li><p><strong>...</strong> – the arguments of the ordinary function; there may be no more than 4 parameters, and they must each have non-union, non-aggregate type not larger than <code class="docutils literal notranslate"><span class="pre">int</span></code> </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DECLARE_INTERRUPT_PERMITTED">
<span class="target" id="interrupt__wrappers_8h_1adac1d061c3bec22e2e6a5f76d19adf6e"></span><span class="sig-name descname"><span class="n"><span class="pre">DECLARE_INTERRUPT_PERMITTED</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__ret</span></span>, <span class="n"><span class="pre">__root_function</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_INTERRUPT_PERMITTED" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Declare an interrupt permitting function. </p>
<p>Use this macro when you require a declaration of your interrupt permitting function types</p>
<p>Example usage:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">In</span> <span class="n">another</span> <span class="n">file</span><span class="p">:</span>
<span class="o">//</span>   <span class="n">DEFINE_INTERRUPT_PERMITTED</span><span class="p">(</span><span class="n">groupA</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">rootfunc</span><span class="p">,</span> <span class="n">chanend</span> <span class="n">c</span><span class="p">,</span> <span class="nb">int</span> <span class="n">i</span><span class="p">)</span>
<span class="o">//</span>   <span class="n">DEFINE_INTERRUPT_PERMITTED</span><span class="p">(</span><span class="n">groupB</span><span class="p">,</span> <span class="n">void</span><span class="p">,</span> <span class="n">anotherfunc</span><span class="p">,</span> <span class="n">void</span><span class="p">)</span>
<span class="n">DECLARE_INTERRUPT_PERMITTED</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">rootfunc</span><span class="p">,</span> <span class="n">chanend</span> <span class="n">c</span><span class="p">,</span> <span class="nb">int</span> <span class="n">i</span><span class="p">);</span>
<span class="n">DECLARE_INTERRUPT_PERMITTED</span><span class="p">(</span><span class="n">void</span><span class="p">,</span> <span class="n">anotherfunc</span><span class="p">,</span> <span class="n">void</span><span class="p">);</span>
<span class="o">...</span>
  <span class="n">par</span> <span class="p">{</span>
      <span class="nb">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">INTERRUPT_PERMITTED</span><span class="p">(</span><span class="n">rootfunc</span><span class="p">)(</span><span class="n">c</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>  <span class="o">//</span> <span class="n">kstack</span> <span class="k">for</span> <span class="n">groupA</span><span class="o">.</span>
      <span class="n">INTERRUPT_PERMITTED</span><span class="p">(</span><span class="n">anotherfunc</span><span class="p">)();</span>  <span class="o">//</span> <span class="n">kstack</span> <span class="k">for</span> <span class="n">groupB</span><span class="o">.</span>
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__ret</strong> – the return type of the ordinary function </p></li>
<li><p><strong>__root_function</strong> – the name of the ordinary function; the return type must be a non-union, non-aggregate type not larger than <code class="docutils literal notranslate"><span class="pre">int</span></code> </p></li>
<li><p><strong>...</strong> – the arguments of the ordinary function; there may be no more than 4 parameters, and they must each have non-union, non-aggregate type not larger than <code class="docutils literal notranslate"><span class="pre">int</span></code> </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.INTERRUPT_PERMITTED">
<span class="target" id="interrupt__wrappers_8h_1ade5cd6df6c5ae91d261cf1a27aa03597"></span><span class="sig-name descname"><span class="n"><span class="pre">INTERRUPT_PERMITTED</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__root_function</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.INTERRUPT_PERMITTED" title="Permalink to this definition">#</a><br /></dt>
<dd><p>The name of the defined interrupt permitting function. </p>
<p>Use this macro for retriving the name of the declared interrupt function. This is the name used to invoke the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the name of the defined interrupt permitting function </p>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFINE_INTERRUPT_CALLBACK">
<span class="target" id="interrupt__wrappers_8h_1af100b86f3a19155e092d9ee8e738856c"></span><span class="sig-name descname"><span class="n"><span class="pre">DEFINE_INTERRUPT_CALLBACK</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__group</span></span>, <span class="n"><span class="pre">__intrpt</span></span>, <span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_INTERRUPT_CALLBACK" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Define an interrupt handling function. </p>
<p>This macro will define two functions for you:<ul class="simple">
<li><p>An ordinary function that may be called directly Its signature will be <code class="docutils literal notranslate"><span class="pre">void</span>  <span class="pre">(</span> <span class="pre">void*</span>  <span class="pre">)</span></code></p></li>
<li><p>An interrupt_callback_t function for passing to a res_setup_interrupt_callback function. The interrupt_callback_t function name is accessed using the <a class="reference internal" href="#interrupt__wrappers_8h_1a0993265aaf8668906d9df02f95b31fa3"><span class="std std-ref">INTERRUPT_CALLBACK()</span></a> macro</p></li>
</ul>
</p>
<p>
Example usage:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DEFINE_INTERRUPT_CALLBACK</span><span class="p">(</span><span class="n">groupA</span><span class="p">,</span> <span class="n">myfunc</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">body</span> <span class="n">of</span> <span class="s1">&#39;void myfunc(void* arg)&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The kernel stack is not re-entrant so kernel mode must not be masked from within an interrupt_callback_t</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__group</strong> – the group of interrupt_callback_t function we belong to see <a class="reference internal" href="#interrupt__wrappers_8h_1ab3931919687f6aa0af8a028fa23ee386"><span class="std std-ref">DEFINE_INTERRUPT_PERMITTED()</span></a> </p></li>
<li><p><strong>__intrpt</strong> – this is the name of the ordinary function </p></li>
<li><p><strong>__data</strong> – the name to use for the void* argument </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DECLARE_INTERRUPT_CALLBACK">
<span class="target" id="interrupt__wrappers_8h_1aebb0b448acb5debdcc26518d0ae8f684"></span><span class="sig-name descname"><span class="n"><span class="pre">DECLARE_INTERRUPT_CALLBACK</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__intrpt</span></span>, <span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_INTERRUPT_CALLBACK" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Declare an interrupt handling function. </p>
<p>Use this macro when you require a declaration of your interrupt function types</p>
<p>Example usage:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DECLARE_INTERRUPT_CALLBACK</span><span class="p">(</span><span class="n">myfunc</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="n">chanend_setup_interrupt_callback</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">INTERRUPT_CALLBACK</span><span class="p">(</span><span class="n">myfunc</span><span class="p">));</span>
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__intrpt</strong> – this is the name of the ordinary function </p></li>
<li><p><strong>__data</strong> – the name to use for the void* argument </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.INTERRUPT_CALLBACK">
<span class="target" id="interrupt__wrappers_8h_1a0993265aaf8668906d9df02f95b31fa3"></span><span class="sig-name descname"><span class="n"><span class="pre">INTERRUPT_CALLBACK</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__intrpt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.INTERRUPT_CALLBACK" title="Permalink to this definition">#</a><br /></dt>
<dd><p>The name of the defined <code class="docutils literal notranslate"><span class="pre">interrupt_callback_t</span></code> function. </p>
<p>Use this macro for retriving the name of the declared interrupt callback function. This is the name that is passed to <code class="docutils literal notranslate"><span class="pre">*_setup_interrupt_callback</span></code>() for registration.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the name of the defined interrupt_callback_t function </p>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-interrupt-h">
<h3>xcore/interrupt.h<a class="headerlink" href="#xcore-interrupt-h" title="Permalink to this heading">#</a></h3>
<p>API for configuring interrupts. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.interrupt_mask_all">
<span class="target" id="interrupt_8h_1a4161fa33e544eb474f81f1374bde73db"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">interrupt_mask_all</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.interrupt_mask_all" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Mask all interrupts on this logical core. </p>
<p>Prevent any enabled <a class="reference internal" href="#triggerable_8h_1a647be9afa8b1cf81eeaa3f35067c6d84"><span class="std std-ref">triggerable_setup_interrupt_callback()</span></a> functions from triggering. This has no effect on <a class="reference internal" href="#triggerable_8h_1a4b33d4a716306563be546a97562ade65"><span class="std std-ref">TRIGGERABLE_SETUP_EVENT_VECTOR()</span></a> triggering. They can be restored by using <a class="reference internal" href="#interrupt_8h_1a82fa7be067926750f8b3a81600563df3"><span class="std std-ref">interrupt_unmask_all()</span></a>. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.interrupt_unmask_all">
<span class="target" id="interrupt_8h_1a82fa7be067926750f8b3a81600563df3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">interrupt_unmask_all</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.interrupt_unmask_all" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Unmask all interrupts on this logical core. </p>
<p>Allow <a class="reference internal" href="#triggerable_8h_1a647be9afa8b1cf81eeaa3f35067c6d84"><span class="std std-ref">triggerable_setup_interrupt_callback()</span></a> functions to trigger. They can be suppressed by using <a class="reference internal" href="#interrupt_8h_1a4161fa33e544eb474f81f1374bde73db"><span class="std std-ref">interrupt_mask_all()</span></a>. </p>
</dd></dl>

</div>
</section>
<section id="xcore-lock-h">
<h3>xcore/lock.h<a class="headerlink" href="#xcore-lock-h" title="Permalink to this heading">#</a></h3>
<p>provides hardware-based locking </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.lock_t">
<span class="target" id="lock_8h_1a2771b7eda50a0efabb40bef1a728e420"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lock_t</span></span></span><a class="headerlink" href="#c.lock_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Hardware lock handle type. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.lock_alloc">
<span class="target" id="lock_8h_1acc3d5aced88693f2b83d01129cbf0c54"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.lock_t" title="lock_t"><span class="n"><span class="pre">lock_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lock_alloc</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_alloc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Allocates a lock. </p>
<p>If there are no locks availble the function returns 0. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the lock is no longer required, <a class="reference internal" href="#lock_8h_1a9920c1689ddc28191409fc4364190ba5"><span class="std std-ref">lock_free()</span></a> must be called to deallocate it.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>handle for the allocated lock, 0 is no locks were available </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.lock_free">
<span class="target" id="lock_8h_1a9920c1689ddc28191409fc4364190ba5"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lock_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.lock_t" title="lock_t"><span class="n"><span class="pre">lock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__l</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Deallocates a given lock. </p>
<p>The lock must be released prior to calling this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__l</strong> – The lock_t to be freed</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated lock, or the lock has not been released. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the lock. </p>
</dd>
<dt class="field-even">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-even"><p>invalid <em>l</em> argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.lock_acquire">
<span class="target" id="lock_8h_1a591d6b310ffe98abbbcbcdcc71e9b3b6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lock_acquire</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.lock_t" title="lock_t"><span class="n"><span class="pre">lock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__l</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_acquire" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Acquire a lock. </p>
<p>Only one core at a time can acquire a lock. This provides a hardware mutex which have very low overheads. If another thread has already acquired this lock then this function will pause until the lock is released and this core becomes the owner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__l</strong> – The lock_t to acquire</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated lock. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the lock. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.lock_release">
<span class="target" id="lock_8h_1aa28e545f1a42862752e998c845c83adc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lock_release</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.lock_t" title="lock_t"><span class="n"><span class="pre">lock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__l</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_release" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Release a lock. </p>
<p>Releases the lock and allocates the next owner from the list of waiting cores in round-robin manner. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are no checks that the core releasing the lock is the current owner.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__l</strong> – The lock_t to use release</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not an allocated lock. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the lock. </p>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-minicache-h">
<h3>xcore/minicache.h<a class="headerlink" href="#xcore-minicache-h" title="Permalink to this heading">#</a></h3>
<p>Cache maintenance interface for the XS3 MiniCache. </p>
<p>The minicache is fully associative and consists of a small number of naturally aligned lines. The minicache caches all reads and writes to and from software memory and external RAM. A single read or write can cause up to two lines to be filled or evicted (in the case that the address range affected spans multiple lines). When there are insufficient lines free to service a fill then allocated lines will be evicted, up to the number of lines to be filled. Evicted lines are chosen based a ‘psuedo leaast recently used’ algorithm.</p>
<p>Flush and invlidate operations queue until the cache is idle (i.e. until all ongoing fills and evicts have finished). During this wait, and whilst the operation completes, all new loads and stores through the cache will block.</p>
<p>This header is only available when targeting platforms with a compatible cache. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.minicache_prefetch">
<span class="target" id="minicache_8h_1a4685afec13688fcc35d1bc7c2bc8a928"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">minicache_prefetch</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__address</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.minicache_prefetch" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Prefetch an address into the cache without blocking. </p>
<p>Begins filling a cache line corresponding to the given <em>__address</em>. The address must be word-aligned and within a read-enabled region. If the region is an ‘uncached’ one (e.g. RAM) then this has no effect. If the address is cache line-aligned then a single line will be filled, otherwise the line corresponding to the address will be prefetched and additionally the next line in the address space (if such a line would have a valid address).</p>
<p>For each line prefetched: <ul class="simple">
<li><p>If the address is already in the cache then no action is taken; </p></li>
<li><p>Otherwise, a fill is started for that line; </p></li>
<li><p>If there is not an available (unallocated) cache line, then an allocated one will be evicted before the fill can begin.</p></li>
</ul>

Prefetching an address is non-blocking even if it causes a fill and/or eviction.</p>
<p>If the address does not correspond to a valid region, is not word aligned, or is within a region for which filling is disabled then a trap will occur.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__address</strong> – The address to prefetch </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.minicache_flush">
<span class="target" id="minicache_8h_1a9f2a071d97fb680016076bf1f9b347f2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">minicache_flush</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.minicache_flush" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Flush all dirty data in the cache back to its respective memory. </p>
<p>Sets a flush operation waiting on the cache. This will wait for all ongoing fills and then write all dirty lines back to their respective memories. The data remains in the cache, however its dirty state is cleared. During the flush operation (and whilst waiting to start it) all access to cached memory is blocking.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If an invalidate operation is already waiting when a flush is queued, it is unspecified which will execute first. </p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.minicache_invalidate">
<span class="target" id="minicache_8h_1a313e3896e0ad92b7884a606349b22207"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">minicache_invalidate</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.minicache_invalidate" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Invalidates all data in the cache. </p>
<p>Sets an invalidate operation waiting on the cache. This will mark all cache lines invalid - meaning that any unflushed writes are effectively reversed.</p>
<p>/note If a flush is queued before an invlidate has completed it is unspecified which will execute first.</p>
<p>/warning This may cause the observed value at a cached address to change. </p>
</dd></dl>

</div>
</section>
<section id="xcore-parallel-h">
<h3>xcore/parallel.h<a class="headerlink" href="#xcore-parallel-h" title="Permalink to this heading">#</a></h3>
<p>Helper macros for fork/join style parallel execution. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PAR_FUNCS">
<span class="target" id="parallel_8h_1a2919ee4cec4b47760635266b031725e6"></span><span class="sig-name descname"><span class="n"><span class="pre">PAR_FUNCS</span></span></span><span class="sig-paren">(</span><span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PAR_FUNCS" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Calls a list of <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(void*)</span></code> functions with each utilising a different hardware thread. </p>
<p>Expands to a block which evaluates each of the given function call descriptions such that each runs in a different thread. For each <code class="docutils literal notranslate"><span class="pre">PFUNC</span></code>, a stack will be allocated from the current stack and used to call <code class="docutils literal notranslate"><span class="pre">FUNCTION</span></code> with <code class="docutils literal notranslate"><span class="pre">ARGUMENT</span></code><p>as its sole argument. The block is blocking until all function calls have returned.</p>
<p>There must be at least enough unallocated logical cores to execute each PFUNC in its own thread, including the current thread as one available logical core.</p>
</p>
<p>
Example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PAR_FUNCS</span><span class="p">(</span><span class="n">PFUNC</span><span class="p">(</span><span class="n">my_print_function</span><span class="p">,</span> <span class="s2">&quot;Hello 1&quot;</span><span class="p">),</span>
          <span class="n">PFUNC</span><span class="p">(</span><span class="n">my_print_function</span><span class="p">,</span> <span class="s2">&quot;Hello 2&quot;</span><span class="p">));</span>
</pre></div>
</div>
 <div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#parallel_8h_1a5f37947bbc6397be5041b80ca79ad1da"><span class="std std-ref">PFUNC</span></a> </p>
</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One function call will be evaluated in the current thread.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>...</strong> – Functions to call, each the result of expanding <code class="docutils literal notranslate"><span class="pre">PFUNC</span></code> </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PFUNC">
<span class="target" id="parallel_8h_1a5f37947bbc6397be5041b80ca79ad1da"></span><span class="sig-name descname"><span class="n"><span class="pre">PFUNC</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_FUNCTION</span></span>, <span class="n"><span class="pre">_ARGUMENT</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PFUNC" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Specifies a parallelised function call. </p>
<p>Expands to a function call description which can be used as an argument to PAR_FUNCS. <div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#parallel_8h_1a2919ee4cec4b47760635266b031725e6"><span class="std std-ref">PAR_FUNCS</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_FUNCTION</strong> – a function with signature <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(void</span> <span class="pre">*)</span></code> </p></li>
<li><p><strong>_ARGUMENT</strong> – the argument to pass to <em>_FUNCTION</em> - must be implicitly convertible to <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DECLARE_JOB">
<span class="target" id="parallel_8h_1acacbc4def14e7bbe65d01a9d45632e20"></span><span class="sig-name descname"><span class="n"><span class="pre">DECLARE_JOB</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_NAME</span></span>, <span class="n"><span class="pre">_ARG_TYPES_PACK</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_JOB" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Declare a <code class="docutils literal notranslate"><span class="pre">void</span></code> function with arbitrary parameters which can be dispatched in another thread. </p>
<p>Expands to the declaration of a function named <em>_NAME</em><p>and additional definitions required to execute that function in a different thread.</p>
<p>The</p>
<em>_ARG_TYPES_PACK</em> parameter must be a comma-separated sequence of permitted types; permitted types may be: <ul class="simple">
<li><p>A type specifier with optional qualification (e.g. <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span></code>, <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">my_enum</span></code>). In the case of an enum, union or struct a declaration list must not be included. </p></li>
<li><p>An (optionally qualified) pointer to a permitted type.</p></li>
</ul>

All parameter types must be complete at the point where <a class="reference internal" href="#parallel_8h_1acacbc4def14e7bbe65d01a9d45632e20"><span class="std std-ref">DECLARE_JOB()</span></a> is expanded, unless the first parameter type is <code class="docutils literal notranslate"><span class="pre">void</span></code> in which case this must be the only parameter and the parameter pack must be exactly <code class="docutils literal notranslate"></code>(void) (i.e. an alias of <code class="docutils literal notranslate"><span class="pre">void</span></code> must not be used).</p>
<p>Example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DECLARE_JOB</span><span class="p">(</span><span class="n">thread_sum</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">unsigned</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span><span class="p">));</span>
<span class="n">void</span> <span class="n">thread_sum</span><span class="p">(</span><span class="n">const</span> <span class="n">unsigned</span> <span class="o">*</span> <span class="n">const</span> <span class="n">ints</span><span class="p">,</span> <span class="n">const</span> <span class="n">size_t</span> <span class="n">number</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span> <span class="n">const</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">unsigned</span> <span class="n">long</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="nb">sum</span> <span class="o">+=</span> <span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
  <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
 <div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><ul class="simple">
<li><p><a class="reference internal" href="#parallel_8h_1a861115d76f0a209d4f5faab6f187ae27"><span class="std std-ref">PJOB</span></a> </p></li>
<li><p><a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> </p></li>
</ul>
</p>
</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These restrictions mean that array types and pointer-to-function types may not appear in a parameter pack. However, typedefs of these types are allowed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_NAME</strong> – Name of function to declare </p></li>
<li><p><strong>_ARG_TYPES_PACK</strong> – A pack of type specifiers which form the parameter part of the function signature (must not include names)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PAR_JOBS">
<span class="target" id="parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"></span><span class="sig-name descname"><span class="n"><span class="pre">PAR_JOBS</span></span></span><span class="sig-paren">(</span><span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PAR_JOBS" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Calls, in parallel, a list of functions declared using DECLARE_JOB. </p>
<p>Expands to a block which executes each of the given function call specifications such that each call takes place in a different hardware thread. Each call specification should be the result of expanding PJOB and the <code class="docutils literal notranslate"><span class="pre">FUNCTION</span></code> should be one which was declared using DECLARE_JOB. Each thread’s stack will be allocated from the current stack. Each function will execute as if <code class="docutils literal notranslate"><span class="pre">FUNCTION</span></code> <code class="docutils literal notranslate"><span class="pre">ARGPACK</span></code><p>; had been executed in its assigned thread. The block is blocking until all functions have returned.</p>
<p>There must be at least enough unallocated logical cores to execute each PJOB in its own thread, including the current thread as one available logical core.</p>
</p>
<p>
Example:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">long</span> <span class="n">sum1</span><span class="p">,</span> <span class="n">sum2</span><span class="p">;</span>
<span class="n">PAR_JOBS</span><span class="p">(</span><span class="n">PJOB</span><span class="p">(</span><span class="n">thread_sum</span><span class="p">,</span> <span class="p">(</span><span class="n">ints1</span><span class="p">,</span> <span class="n">ints1_length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sum1</span><span class="p">)),</span>
         <span class="n">PJOB</span><span class="p">(</span><span class="n">thread_sum</span><span class="p">,</span> <span class="p">(</span><span class="n">ints2</span><span class="p">,</span> <span class="n">ints2_length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sum2</span><span class="p">)));</span>
</pre></div>
</div>
 <div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><ul class="simple">
<li><p><a class="reference internal" href="#parallel_8h_1a861115d76f0a209d4f5faab6f187ae27"><span class="std std-ref">PJOB</span></a> </p></li>
<li><p><a class="reference internal" href="#parallel_8h_1acacbc4def14e7bbe65d01a9d45632e20"><span class="std std-ref">DECLARE_JOB</span></a> </p></li>
</ul>
</p>
</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One function call will be evaluated in the current thread.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>...</strong> – Function call specifications as expanded from PJOB.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PJOB">
<span class="target" id="parallel_8h_1a861115d76f0a209d4f5faab6f187ae27"></span><span class="sig-name descname"><span class="n"><span class="pre">PJOB</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_FUNCTION</span></span>, <span class="n"><span class="pre">_ARGPACK</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PJOB" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Specifies a parallelised call of a function declared with DECLARE_JOB. </p>
<p>Expands to a function call description which can be used as an argument to PAR_JOBS. <div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><ul class="simple">
<li><p><a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> </p></li>
<li><p><a class="reference internal" href="#parallel_8h_1acacbc4def14e7bbe65d01a9d45632e20"><span class="std std-ref">DECLARE_JOB</span></a> </p></li>
</ul>
</p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_FUNCTION</strong> – a function which was declared using DECLARE_JOB </p></li>
<li><p><strong>_ARGPACK</strong> – pack of the arguments to pass to <em>_FUNCTION</em> - each must be implicitly convertible to its respective parameter type. E.g. <code class="docutils literal notranslate"><span class="pre">(5,</span> <span class="pre">NULL)</span></code> for <code class="docutils literal notranslate"><span class="pre">void(int,</span> <span class="pre">int</span> <span class="pre">*)</span></code> </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PAR_SYNC">
<span class="target" id="parallel_8h_1ae182a9ff8b4b933f37b64067ab9f2be3"></span><span class="sig-name descname"><span class="n"><span class="pre">PAR_SYNC</span></span></span><a class="headerlink" href="#c.PAR_SYNC" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Job parameter macro to access the respective thread’s synchronizer. </p>
<p>When expanded as a parameter to <a class="reference internal" href="#parallel_8h_1a861115d76f0a209d4f5faab6f187ae27"><span class="std std-ref">PJOB</span></a> as part of a <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> expansion, expands to a value compatible with synchronizer_t which represents that thread’s synchronizer handle. This can be used to synchronise all threads in the <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> when used with <a class="reference internal" href="#parallel_8h_1ad03a49007aea90845ab784b367f64ae4"><span class="std std-ref">par_jobs_synchronize</span></a> .</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As synchronization affects all threads in the enclosing <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a>, it is never useful for any <a class="reference internal" href="#parallel_8h_1a861115d76f0a209d4f5faab6f187ae27"><span class="std std-ref">PJOB</span></a> in a <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> to include a <a class="reference internal" href="#parallel_8h_1ae182a9ff8b4b933f37b64067ab9f2be3"><span class="std std-ref">PAR_SYNC</span></a> parameter unless <strong>all</strong> PJOBs in that <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> do so.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Accessing the synchroniser forces allocation of a hardware synchroniser resource, even if one would not ordinarily be required. This means that a <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> expansion with only a single <a class="reference internal" href="#parallel_8h_1a861115d76f0a209d4f5faab6f187ae27"><span class="std std-ref">PJOB</span></a> will require a hardware synchroniser if that <a class="reference internal" href="#parallel_8h_1a861115d76f0a209d4f5faab6f187ae27"><span class="std std-ref">PJOB</span></a> is passed <a class="reference internal" href="#parallel_8h_1ae182a9ff8b4b933f37b64067ab9f2be3"><span class="std std-ref">PAR_SYNC</span></a>. This can potentially lead to synchroniser exhaustion. Note that <a class="reference internal" href="#parallel_8h_1ad03a49007aea90845ab784b367f64ae4"><span class="std std-ref">par_jobs_synchronize</span></a> has no observable effect if there is only one thread in the group. </p>
</div>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.synchronizer_t">
<span class="target" id="parallel_8h_1acd5ac7bdd50f9bfa2579b805bd7d524e"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">synchronizer_t</span></span></span><a class="headerlink" href="#c.synchronizer_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Synchronizer handle which may be used to explicitly synchronise jobs executed by PAR_JOBS. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The synchronizer handles for each thread in a <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> are neither guaranteed to compare equal nor non-equal to other handles, regardless of whether they are participating in the same <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a>. </p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Synchronizer handles are not portable between threads; they are meaningful only within the thread to which they are originally passed by a <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> expansion. </p>
</div>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.par_jobs_synchronize">
<span class="target" id="parallel_8h_1ad03a49007aea90845ab784b367f64ae4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">par_jobs_synchronize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.synchronizer_t" title="synchronizer_t"><span class="n"><span class="pre">synchronizer_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.par_jobs_synchronize" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Synchronise all threads in a PAR_JOBS. </p>
<p>When passed a value of type <a class="reference internal" href="#parallel_8h_1acd5ac7bdd50f9bfa2579b805bd7d524e"><span class="std std-ref">synchronizer_t</span></a>, as obtained using <a class="reference internal" href="#parallel_8h_1ae182a9ff8b4b933f37b64067ab9f2be3"><span class="std std-ref">PAR_SYNC</span></a> as a parameter to the <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> which started the current thread, blocks until all threads started by that <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> call <a class="reference internal" href="#parallel_8h_1ad03a49007aea90845ab784b367f64ae4"><span class="std std-ref">par_jobs_synchronize</span></a> with their respective <a class="reference internal" href="#parallel_8h_1acd5ac7bdd50f9bfa2579b805bd7d524e"><span class="std std-ref">synchronizer_t</span></a> values. If all other threads started by the <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> are already blocking in a call to <a class="reference internal" href="#parallel_8h_1ad03a49007aea90845ab784b367f64ae4"><span class="std std-ref">par_jobs_synchronize</span></a> then causes all of those threads to return from those calls, and returns immediately.</p>
<p>If the synchronizer passed was not obtained by expanding <a class="reference internal" href="#parallel_8h_1ae182a9ff8b4b933f37b64067ab9f2be3"><span class="std std-ref">PAR_SYNC</span></a> in the parameter pack of the <a class="reference internal" href="#parallel_8h_1a861115d76f0a209d4f5faab6f187ae27"><span class="std std-ref">PJOB</span></a> expansion relating to the calling thread, the behaviour is undefined. That is, synchronizers must not be passed between threads, including to child threads.</p>
<p>If any thread calls <a class="reference internal" href="#parallel_8h_1ad03a49007aea90845ab784b367f64ae4"><span class="std std-ref">par_jobs_synchronize</span></a> when any other job in the respective <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> has already returned, or if any job returns whilst another job in its respective <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> is blocked on a call to <a class="reference internal" href="#parallel_8h_1ad03a49007aea90845ab784b367f64ae4"><span class="std std-ref">par_jobs_synchronize</span></a>, then the behaviour is undefined. Effectively, each job in a <a class="reference internal" href="#parallel_8h_1afa197aa052d7b05ef8332c4c58dc7d85"><span class="std std-ref">PAR_JOBS</span></a> expansion must call <a class="reference internal" href="#parallel_8h_1ad03a49007aea90845ab784b367f64ae4"><span class="std std-ref">par_jobs_synchronize</span></a> the same number of times</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__s</strong> – The synchronizer handle for this thread </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-port-protocol-h">
<h3>xcore/port_protocol.h<a class="headerlink" href="#xcore-port-protocol-h" title="Permalink to this heading">#</a></h3>
<p>Helper functions for port usage patterns. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.port_protocol_in_handshake">
<span class="target" id="port__protocol_8h_1acf7f3c641208368548faef5a0f0144f1"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_protocol_in_handshake</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__readyin</span></span>, <a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__readyout</span></span>, <a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_protocol_in_handshake" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configure a port to be a clocked input port in handshake mode. </p>
<p>If the ready-in or ready-out ports are not 1-bit ports, an exception is raised. The ready-out port is asserted on the falling edge of the clock when the port’s buffer is not full. The port samples its pins on its sampling edge when both the ready-in and ready-out ports are asserted.</p>
<p>By default the port’s sampling edge is the rising edge of clock. This can be changed by the function <a class="reference internal" href="#port_8h_1a33c1b1668d1da8a073e882cf526cbcf0"><span class="std std-ref">port_set_sample_falling_edge()</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A handshaken port must be buffered, so this function will also make the port buffered.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to configure </p></li>
<li><p><strong>__readyin</strong> – A 1-bit port to use for the ready-in signal </p></li>
<li><p><strong>__readyout</strong> – A 1-bit port to use for the ready-out signal </p></li>
<li><p><strong>__clk</strong> – The clock used to configure the port</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port/clock or clock is running, or readyin/readyout not a one bit port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing a port/clock </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_protocol_out_handshake">
<span class="target" id="port__protocol_8h_1aeed8da018400aa990b885bc71ac64a3b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_protocol_out_handshake</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__readyin</span></span>, <a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__readyout</span></span>, <a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__initial</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_protocol_out_handshake" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configures a port to be a clocked output port in handshake mode. </p>
<p>If the ready-in or ready-out ports are not 1-bit ports an exception is raised. the port drives the initial value on its pins until an output statement changes the value driven.</p>
<p>The ready-in port is read on the sampling edge of the port. outputs are driven on the next falling edge of the clock where the previous value read from the ready-in port was high.</p>
<p>On the falling edge of the clock the ready-out port is driven high if data is output on that edge, otherwise it is driven low.</p>
<p>By default the port’s sampling edge is the rising edge of clock. this can be changed by the function <a class="reference internal" href="#port_8h_1a33c1b1668d1da8a073e882cf526cbcf0"><span class="std std-ref">port_set_sample_falling_edge()</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A handshaken port must be buffered, so this function will also make the port buffered.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – the port to configure </p></li>
<li><p><strong>__readyin</strong> – a 1-bit port to use for the ready-in signal </p></li>
<li><p><strong>__readyout</strong> – a 1-bit port to use for the ready-out signal </p></li>
<li><p><strong>__clk</strong> – the clock used to configure the port </p></li>
<li><p><strong>__initial</strong> – the initial value to output on the port</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port/clock or clock is running, or readyin/readyout not a one bit port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing a port/clock </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_protocol_in_strobed_master">
<span class="target" id="port__protocol_8h_1a0e20da64d05e6b671ba60ea628d07c2c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_protocol_in_strobed_master</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__readyout</span></span>, <a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_protocol_in_strobed_master" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configures a port to be a clocked input port in strobed master mode. </p>
<p>If the ready-out port is not a 1-bit port, an exception is raised. the ready-out port is asserted on the falling edge of the clock when the port’s buffer is not full. the port samples its pins on its sampling edge after the ready-out port is asserted.</p>
<p>By default the port’s sampling edge is the rising edge of clock. this can be changed by the function set_port_sample_delay().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A strobed port must be buffered, so this function will also make the port buffered.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – the port to configure </p></li>
<li><p><strong>__readyout</strong> – a 1-bit port to use for the ready-out signal </p></li>
<li><p><strong>__clk</strong> – the clock used to configure the port</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port/clock or clock is running, or readyout not a one bit port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing a port/clock </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_protocol_out_strobed_master">
<span class="target" id="port__protocol_8h_1a9d32dc19d611861ff300251269e56300"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_protocol_out_strobed_master</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__readyout</span></span>, <a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__initial</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_protocol_out_strobed_master" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configures a port to be a clocked output port in strobed master mode. </p>
<p>If the ready-out port is not a 1-bit port, an exception is raised. the port drives the initial value on its pins until an output statement changes the value driven. outputs are driven on the next falling edge of the clock. on the falling edge of the clock the ready-out port is driven high if data is output on that edge, otherwise it is driven low.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A strobed port must be buffered, so this function will also make the port buffered.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – the port to configure </p></li>
<li><p><strong>__readyout</strong> – a 1-bit port to use for the ready-out signal </p></li>
<li><p><strong>__clk</strong> – the clock used to configure the port </p></li>
<li><p><strong>__initial</strong> – the initial value to output on the port</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port/clock or clock is running, or readyout not a one bit port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing a port/clock </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_protocol_in_strobed_slave">
<span class="target" id="port__protocol_8h_1a9a6e1c71d76ef1c0ff2ccab619b82bc2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_protocol_in_strobed_slave</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__readyin</span></span>, <a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_protocol_in_strobed_slave" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configures a port to be a clocked input port in strobed slave mode. </p>
<p>If the ready-in port is not a 1-bit port, an exception is raised. the port samples its pins on its sampling edge when the ready-in signal is high. by default the port’s sampling edge is the rising edge of clock. this can be changed by the function set_port_sample_delay().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A strobed port must be buffered, so this function will also make the port buffered.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – the port to configure </p></li>
<li><p><strong>__readyin</strong> – a 1-bit port to use for the ready-in signal </p></li>
<li><p><strong>__clk</strong> – the clock used to configure the port</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port/clock or clock is running, or readyin not a one bit port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing a port/clock </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_protocol_out_strobed_slave">
<span class="target" id="port__protocol_8h_1a67ebf2c745ea688d28bbd9918f73dc22"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_protocol_out_strobed_slave</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__readyin</span></span>, <a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__initial</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_protocol_out_strobed_slave" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configures a port to be a clocked output port in strobed slave mode. </p>
<p>If the ready-in port is not a 1-bit port, an exception is raised. the port drives the initial value on its pins until an output statement changes the value driven. the ready-in port is read on the port’s sampling edge. outputs are driven on the next falling edge of the clock where the previous value read from the ready-in port is high. by default the port’s sampling edge is the rising edge of clock. this can be changed by the function set_port_sample_delay().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A strobed port must be buffered, so this function will also make the port buffered.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – the port to configure </p></li>
<li><p><strong>__readyin</strong> – a 1-bit port to use for the ready-in signal </p></li>
<li><p><strong>__clk</strong> – the clock used to configure the port </p></li>
<li><p><strong>__initial</strong> – the initial value to output on the port</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port/clock or clock is running, or readyin not a one bit port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing a port/clock </p>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-port-h">
<h3>xcore/port.h<a class="headerlink" href="#xcore-port-h" title="Permalink to this heading">#</a></h3>
<p>API for IO using ports. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PORT_TIMESTAMP_MIN">
<span class="target" id="port_8h_1abd187aad966b5266218833bcdfaa28b1"></span><span class="sig-name descname"><span class="n"><span class="pre">PORT_TIMESTAMP_MIN</span></span></span><a class="headerlink" href="#c.PORT_TIMESTAMP_MIN" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Lowest legal value for a port timestamp. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PORT_TIMESTAMP_MAX">
<span class="target" id="port_8h_1a9054464ccf5f8c9ebbbbee6d2016f5a3"></span><span class="sig-name descname"><span class="n"><span class="pre">PORT_TIMESTAMP_MAX</span></span></span><a class="headerlink" href="#c.PORT_TIMESTAMP_MAX" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Largest legal value for a port timestamp. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.port_t">
<span class="target" id="port_8h_1a308dc925eace75f7be2efa9b7eb17de8"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_t</span></span></span><a class="headerlink" href="#c.port_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Port handle type. </p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.port_timestamp_t">
<span class="target" id="port_8h_1a0b2ee3024dd83679813dec1210e4e754"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_timestamp_t</span></span></span><a class="headerlink" href="#c.port_timestamp_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Integer type capable of holding all possible values of a port timestamp. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The actual valid range of timestamps is given by <a class="reference internal" href="#port_8h_1abd187aad966b5266218833bcdfaa28b1"><span class="std std-ref">PORT_TIMESTAMP_MIN</span></a> and <a class="reference internal" href="#port_8h_1a9054464ccf5f8c9ebbbbee6d2016f5a3"><span class="std std-ref">PORT_TIMESTAMP_MAX</span></a> which are the lowest and highest valid timestamps respectively. </p>
</div>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-enums">Enums</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.port_type_t">
<span class="target" id="port_8h_1aeb624a1369a8ea2bf2bf5fb7044af3e1"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_type_t</span></span></span><a class="headerlink" href="#c.port_type_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Enumeration to declare how the port was set up. </p>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.port_type_t.PORT_UNBUFFERED">
<span class="target" id="port_8h_1aeb624a1369a8ea2bf2bf5fb7044af3e1a21932962b2c9b42b0204d8b99ed65869"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PORT_UNBUFFERED</span></span></span><a class="headerlink" href="#c.port_type_t.PORT_UNBUFFERED" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.port_type_t.PORT_BUFFERED">
<span class="target" id="port_8h_1aeb624a1369a8ea2bf2bf5fb7044af3e1a46d513c417c2ee4f11487f617846788a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PORT_BUFFERED</span></span></span><a class="headerlink" href="#c.port_type_t.PORT_BUFFERED" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.port_enable">
<span class="target" id="port_8h_1a73d9d06bf3b70d94117582e38220cd79"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_enable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_enable" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Enables a port. </p>
<p>Either this function or <a class="reference internal" href="#port_8h_1a955aa1526ff81c5c14013a09624d6f04"><span class="std std-ref">port_start_buffered()</span></a> must be called once for each variable of type <code class="docutils literal notranslate"><span class="pre">port</span></code> before use. <a class="reference internal" href="#port_8h_1a8cf492344bc09ccd41ab056ea341f71f"><span class="std std-ref">port_disable()</span></a> must be called afterwards.</p>
<p>The port’s state is set to: input, unbuffered, inout_data, no_invert, rising_edge, master, no_ready, no triggers, clocked by XS1_CLKBLK_REF.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>port_enable_buffered </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to enable</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_reset">
<span class="target" id="port_8h_1a9ce726490a572b846ac47a98a3e73721"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_reset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_reset" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Reset a port. </p>
<p>Clears a ports settings back to the default state at <a class="reference internal" href="#port_8h_1a73d9d06bf3b70d94117582e38220cd79"><span class="std std-ref">port_enable()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to be reset</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_start_buffered">
<span class="target" id="port_8h_1a955aa1526ff81c5c14013a09624d6f04"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_start_buffered</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__transfer_width</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_start_buffered" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Allocates a port to buffer and serialise/deserialise data. </p>
<p>Either this function or <a class="reference internal" href="#port_8h_1a73d9d06bf3b70d94117582e38220cd79"><span class="std std-ref">port_enable()</span></a> must be called once for each port_t before it is used.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#port_8h_1a73d9d06bf3b70d94117582e38220cd79"><span class="std std-ref">port_enable</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Value that identifies which port to drive </p></li>
<li><p><strong>__transfer_width</strong> – Number of bits to serialise; must be 1, 4, 8, or 32. The number of bits must be &gt;= to the physical port width.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port, or is not legal width for the port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_disable">
<span class="target" id="port_8h_1a8cf492344bc09ccd41ab056ea341f71f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_disable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_disable" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Disable a port. </p>
<p>Disables the port so it is no longer ready for use. It must be re-enabled if it is used again. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to be disabled</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_transfer_width">
<span class="target" id="port_8h_1ad13865a7ccc9204e7d4c0969b3e1efd4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_transfer_width</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">__transfer_width</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_transfer_width" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Change the transfer width of a port. </p>
<p>The default transfer width is the same as the physical port width.</p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>A port must have been set to buffered if the width is different from the physical port width</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to change the transfer width of </p></li>
<li><p><strong>__transfer_width</strong> – Number of bits to serialise; must be 1, 4, 8, or 32. The number of bits must be &gt;= to the physical port width.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port, or is not legal width for the port, or the port is unbuffered. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_buffered">
<span class="target" id="port_8h_1a7a78ae9aebb50335c07d8ff0b9069dd3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_buffered</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_buffered" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sets a port to be buffered. </p>
<p>Configures a port into buffered mode where it can automatically serialise or deserialise data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to set as buffered</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_unbuffered">
<span class="target" id="port_8h_1a6a85c465a844b450a64752c54330a762"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_unbuffered</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_unbuffered" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sets a port to be unbuffered (default state). </p>
<p>Configures a port into unbuffered mode. Note that before this is called, a a port needs to have its transfer width equal to the port width and be configured as a master port.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to set as unbuffered</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_write_control_word">
<span class="target" id="port_8h_1a42e22d73346c408dcfb05cf9f83e06a3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_write_control_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__word</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_write_control_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configure the port with a platform-specific value. </p>
<p>Uses the value of <em>__word</em> to configure the port. The effect of this is platform dependent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to configure </p></li>
<li><p><strong>__word</strong> – The config word to set on the port</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port or <em>__word</em> is not valid </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_clock">
<span class="target" id="port_8h_1afbd6d2f3b0a2472c399368f7629480d7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_clock</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.xclock_t" title="xclock_t"><span class="n"><span class="pre">xclock_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_clock" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the clock clocking a port. </p>
<p>Changes the clock used for a port’s control functions. The default clock is XS1_CLKBLK_REF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port whose clock is being changed. </p></li>
<li><p><strong>__clk</strong> – Clock to attach to the port.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port/clock, or clock is running. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_inout_data">
<span class="target" id="port_8h_1a6bf2c2bb084830afcc3d07803409806e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_inout_data</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_inout_data" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set a port drive out the data value (default state). </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to change the mode of.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_out_clock">
<span class="target" id="port_8h_1add1fc43f591b81b249abf9fb8404975d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_out_clock</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_out_clock" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set a port to drive out its clocking signal. </p>
<p>Configures the port to drive the clock signal instead of its own data values. The clock signal that is driven out is configured using the <a class="reference internal" href="#port_8h_1afbd6d2f3b0a2472c399368f7629480d7"><span class="std std-ref">port_set_clock()</span></a> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to change the mode of.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_out_ready">
<span class="target" id="port_8h_1a4d25cccee77feb9ddae4bfb3e8ad5344"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_out_ready</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__ready_source</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_out_ready" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set a port to drive out the ready signal of another port. </p>
<p>Configures the port to drive the ready signal of another port instead of its own data values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to change the mode of. This must be a 1-bit port or this function will trap. </p></li>
<li><p><strong>__ready_source</strong> – The port whose ready signal will be output.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>not a valid port </p></li>
<li><p><em>p</em> not a one bit port. </p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_invert">
<span class="target" id="port_8h_1af313c860597ca2506eebba1cc31cb40b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_invert</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_invert" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port to invert its data. </p>
<p>Configures a port to invert the data on the pin. This can be reverted by calling <a class="reference internal" href="#port_8h_1a6d7d7c150bbeac38b25b9b769e89acb0"><span class="std std-ref">port_set_no_invert()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to set its data to be inverted. This must be a 1-bit port or a trap will be raised.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>not a valid port </p></li>
<li><p>p not a one bit port. </p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_no_invert">
<span class="target" id="port_8h_1a6d7d7c150bbeac38b25b9b769e89acb0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_no_invert</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_no_invert" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port to not invert its data (default state). </p>
<p>Configures a port to not invert the data on the pin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to set the data to not be inverted.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_sample_falling_edge">
<span class="target" id="port_8h_1a33c1b1668d1da8a073e882cf526cbcf0"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_sample_falling_edge</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_sample_falling_edge" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port to sample on the falling edge. </p>
<p>The default is for a port to sample data on the rising edge of the clock. This function changes the port to sample on the falling edge instead. This change can be reverted by calling <a class="reference internal" href="#port_8h_1a2bd352a0a813e497ae5d1dc73287742a"><span class="std std-ref">port_set_sample_rising_edge()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to change its sampling edge.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_sample_rising_edge">
<span class="target" id="port_8h_1a2bd352a0a813e497ae5d1dc73287742a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_sample_rising_edge</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_sample_rising_edge" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port to sample on the rising edge (default state). </p>
<p>Restores a port to sampling data on the rising edge of the clock.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to change its sampling edge.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_master">
<span class="target" id="port_8h_1ac32abfc1c1aa08584c8bcfee93b44ca8"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_master</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_master" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port to master mode (default state). </p>
<p>Configures a port to be a master. This is only relevant when using ready signals (<a class="reference internal" href="#port_8h_1ab6ed3a6ef6efd65d72a48e1216bd762c"><span class="std std-ref">port_set_ready_strobed()</span></a> / <a class="reference internal" href="#port_8h_1ada926c8e361d4ad267ddc39d78a5af08"><span class="std std-ref">port_set_ready_handshake()</span></a>).</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>xcore/port_protocol.h </p>
</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is highly recommended to use the <code class="docutils literal notranslate"><span class="pre">port_protocol_*</span></code> functions to put a port into its desired mode as the order of operations is critical. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to set as a master</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_slave">
<span class="target" id="port_8h_1a67acf038a334b095d3318043fd4305da"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_slave</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_slave" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port to slave mode. </p>
<p>Configures a port to be a master. This is only relevant when using a ready strobe (<a class="reference internal" href="#port_8h_1ab6ed3a6ef6efd65d72a48e1216bd762c"><span class="std std-ref">port_set_ready_strobed()</span></a>)</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>xcore/port_protocol.h </p>
</div>
<dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>the port must be set to use a ready strobe, otherwise this function will raise an exception.</p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is highly recommended to use the <code class="docutils literal notranslate"><span class="pre">port_protocol_*</span></code> functions to put a port into its desired mode as the order of operations is critical. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to set as a slave</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_no_ready">
<span class="target" id="port_8h_1af91b316dfcb6838d5d76056fb710bfc4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_no_ready</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_no_ready" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port to use no ready signals (default state). </p>
<p>Changes a port to not use ready signals. A port can be configured to use strobes or handshaking signals using <a class="reference internal" href="#port_8h_1ab6ed3a6ef6efd65d72a48e1216bd762c"><span class="std std-ref">port_set_ready_strobed()</span></a> or <a class="reference internal" href="#port_8h_1ada926c8e361d4ad267ddc39d78a5af08"><span class="std std-ref">port_set_ready_handshake()</span></a>.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>xcore/port_protocol.h </p>
</div>
<dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>the port must be a <code class="docutils literal notranslate"><span class="pre">master</span></code> port otherwise this function will raise an exception.</p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is highly recommended to use the <code class="docutils literal notranslate"><span class="pre">port_protocol_*</span></code> functions to put a port into its desired mode as the order of operations is critical. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to change to not use ready signals</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_ready_strobed">
<span class="target" id="port_8h_1ab6ed3a6ef6efd65d72a48e1216bd762c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_ready_strobed</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_ready_strobed" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port to use a single strobe. </p>
<p>Changes a port to not use ready signals. A port can be configured to use strobes or handshaking signals using <a class="reference internal" href="#port_8h_1ab6ed3a6ef6efd65d72a48e1216bd762c"><span class="std std-ref">port_set_ready_strobed()</span></a> or <a class="reference internal" href="#port_8h_1ada926c8e361d4ad267ddc39d78a5af08"><span class="std std-ref">port_set_ready_handshake()</span></a>.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>xcore/port_protocol.h </p>
</div>
<dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>the port must be a buffered port otherwise this function will raise an exception.</p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is highly recommended to use the <code class="docutils literal notranslate"><span class="pre">port_protocol_*</span></code> functions to put a port into its desired mode as the order of operations is critical. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to change to not use ready signals</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_ready_handshake">
<span class="target" id="port_8h_1ada926c8e361d4ad267ddc39d78a5af08"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_ready_handshake</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_ready_handshake" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port to be fully handshaken. </p>
<p>Changes a port to use both a ready input and drive a ready output in order to control when data is sampled or written.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>xcore/port_protocol.h </p>
</div>
<dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>the port must be a master buffered port otherwise this function will raise an exception.</p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is highly recommended to use the <code class="docutils literal notranslate"><span class="pre">port_protocol_*</span></code> functions to put a port into its desired mode as the order of operations is critical. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to change to not use ready signals</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_get_trigger_time">
<span class="target" id="port_8h_1ac9fd72ce8c61c722953870bf8712fbf5"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.port_timestamp_t" title="port_timestamp_t"><span class="n"><span class="pre">port_timestamp_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_get_trigger_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_get_trigger_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gets the timestamp of the last input or output operation on a port. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned timestamp will be a valid timestamp no less than <a class="reference internal" href="#port_8h_1abd187aad966b5266218833bcdfaa28b1"><span class="std std-ref">PORT_TIMESTAMP_MIN</span></a> and no greater than <a class="reference internal" href="#port_8h_1a9054464ccf5f8c9ebbbbee6d2016f5a3"><span class="std std-ref">PORT_TIMESTAMP_MAX</span></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to get the timestamp from </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The timestamp of the last operation</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_trigger_time">
<span class="target" id="port_8h_1ab9cf5f9898a5673dd9478c0a6d37658e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_trigger_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_timestamp_t" title="port_timestamp_t"><span class="n"><span class="pre">port_timestamp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_trigger_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the timestamp at which the port will input/output data. </p>
<p>Sets the time condition for the next input or output on a port. If the port is unbuffered or the buffer is empty/full a call to <a class="reference internal" href="#port_8h_1a987a26f40909a377cf1c0c38c49de4f4"><span class="std std-ref">port_in()</span></a> or <a class="reference internal" href="#port_8h_1aaf8fe0e5c572c2caa3178d9d1aa1af34"><span class="std std-ref">port_out()</span></a> will pause until the specified time. The trigger is cleared by a input/output or by calling <a class="reference internal" href="#port_8h_1a7fb38719fc41c92b5713bbd7acc7a8a6"><span class="std std-ref">port_clear_trigger_time()</span></a>. The given timestamp must be a valid port timestamp no less than <a class="reference internal" href="#port_8h_1abd187aad966b5266218833bcdfaa28b1"><span class="std std-ref">PORT_TIMESTAMP_MIN</span></a> and no greater than <a class="reference internal" href="#port_8h_1a9054464ccf5f8c9ebbbbee6d2016f5a3"><span class="std std-ref">PORT_TIMESTAMP_MAX</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to set the condition on </p></li>
<li><p><strong>__t</strong> – The port timestamp to match</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_clear_trigger_time">
<span class="target" id="port_8h_1a7fb38719fc41c92b5713bbd7acc7a8a6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_clear_trigger_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_clear_trigger_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear the timestamp trigger on a port. </p>
<p>Clears any trigger_time condition on the port so the next input or output will happen unconditionally in respect to the timestamp. This function does not clear the trigger_in condition on the port.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to clear the trigger_time on</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_trigger_in_equal">
<span class="target" id="port_8h_1a8c7bca5a94cf9a89e2a5035346815d69"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_trigger_in_equal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_trigger_in_equal" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Setup an event to trigger on a port when its input value matches. </p>
<p>On a unbuffered port the trigger will apply to all future inputs until the trigger is set again. On an buffered port the trigger will only hold for the next input after which the trigger_in_equal will be cleared.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to set the trigger on </p></li>
<li><p><strong>__v</strong> – The value to match</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_trigger_in_not_equal">
<span class="target" id="port_8h_1a899c5c82c1e8391dd70da8393ff1e349"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_trigger_in_not_equal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_trigger_in_not_equal" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Setup an event to trigger on a port when its input value does not matches. </p>
<p>On a unbuffered port the trigger will apply to all future inputs until the trigger is set again. On an buffered port the trigger will only hold for the next input after which the trigger_in_not_equal will be cleared.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to set the trigger on </p></li>
<li><p><strong>__v</strong> – The value to not match</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_clear_trigger_in">
<span class="target" id="port_8h_1af6b083ad15f93e881c78f2a835f6c8b7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_clear_trigger_in</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_clear_trigger_in" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear the in trigger on a port. </p>
<p>Clears any trigger_in condition on the port so the next input will happen unconditionally in respect to the input value. This function does not clear the trigger_time condition on the port.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to clear the trigger_in on</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_peek">
<span class="target" id="port_8h_1a7614a77bdc29d14ac55a920175ed2a8d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_peek</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_peek" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Peek at the value on a port. </p>
<p>Peeking a port returns the current value on the pins of a port, regardless of whether the port is an output or input and without affecting its direciton. Peek will not pause, regardless of any triggers that have been set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to be peeked </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The current value on the pins</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_out">
<span class="target" id="port_8h_1aaf8fe0e5c572c2caa3178d9d1aa1af34"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_out</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_out" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Outputs a value onto a port. </p>
<p>In the case of an unbuffered port, the value will be driven on the pins on the next clock cycle. In the case of a buffered port, the data will be stored in the buffer, and be serialised onto the output pins.</p>
<p>If there is a time trigger setup and the port is unbuffered or the buffer is full the call will pause until the specified time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to output to </p></li>
<li><p><strong>__data</strong> – Value to output</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_in">
<span class="target" id="port_8h_1a987a26f40909a377cf1c0c38c49de4f4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_in</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_in" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a value from a port. </p>
<p>For unbuffered port with no trigger, the data will be whatever is on the input pins. For unbuffered port with a trigger, the data will be the value read when the trigger fired. The call will pause if the trigger has not yet fired. For buffered port, this function will pause until the buffer is filled up with deserialised data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to input from </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The inputted data</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_out_shift_right">
<span class="target" id="port_8h_1abdcddcd11d156bb0a5f51b5ba4917aa1"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_out_shift_right</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_out_shift_right" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Outputs a value onto a port and shift the output data. </p>
<p>In the case of an unbuffered port, the value will be driven on the pins on the next clock cycle. In the case of a buffered port, the data will be stored in the buffer, and be serialised onto the output pins.</p>
<p>If there is a time trigger setup and the port is unbuffered or the buffer is full the call will pause until the specified time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to output to </p></li>
<li><p><strong>__data</strong> – <em>data</em> is shifted right by the transfer width of the port, with the bits shifting out onto the port. </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The remaining shifted bits of <em>data</em> </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_in_shift_right">
<span class="target" id="port_8h_1a923b3fd25495b5eb11490126acb163f9"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_in_shift_right</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_in_shift_right" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input a value from a port and shift the data. </p>
<p>For unbuffered port with no trigger, the data will be whatever is on the input pins. For unbuffered port with a trigger, the data will be the value read when the trigger fired. The call will pause if the trigger has not yet fired. For buffered port, this function will pause until the buffer is filled up with deserialised data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to input from </p></li>
<li><p><strong>__data</strong> – Initial value to shift input data into </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of shifting <em>data</em> right by the port width and storing the input data in the most significant bits</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_out_at_time">
<span class="target" id="port_8h_1a8ea402678328ecfeb59a7b01ffd23e59"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_out_at_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_timestamp_t" title="port_timestamp_t"><span class="n"><span class="pre">port_timestamp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_out_at_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Outputs a value onto a port at a specified port timestamp. </p>
<p>In the case of an unbuffered port, the value will be driven on the pins when on the clock cycle that moves the port timestamp to the specified time. In the case of a buffered port, the data will be stored in the buffer, and be serialised onto the output pins at the point that the time is reached. The given timestamp must be a valid port timestamp no less than <a class="reference internal" href="#port_8h_1abd187aad966b5266218833bcdfaa28b1"><span class="std std-ref">PORT_TIMESTAMP_MIN</span></a> and no greater than <a class="reference internal" href="#port_8h_1a9054464ccf5f8c9ebbbbee6d2016f5a3"><span class="std std-ref">PORT_TIMESTAMP_MAX</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to output to </p></li>
<li><p><strong>__t</strong> – The timestamp to do the output on </p></li>
<li><p><strong>__data</strong> – Value to output</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_in_at_time">
<span class="target" id="port_8h_1ae20829a4f349e056e66908fca1c0a684"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_in_at_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_timestamp_t" title="port_timestamp_t"><span class="n"><span class="pre">port_timestamp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_in_at_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input data from a port when its counter is at a specific time. </p>
<p>In the case of an unbuffered port, the data will be inputted when the counter reaches time <em>t</em>. In the case of a buffered port, an input will wait until the given time and then will start capturing data, returning a value when the buffer is full. The given timestamp must be a valid port timestamp no less than <a class="reference internal" href="#port_8h_1abd187aad966b5266218833bcdfaa28b1"><span class="std std-ref">PORT_TIMESTAMP_MIN</span></a> and no greater than <a class="reference internal" href="#port_8h_1a9054464ccf5f8c9ebbbbee6d2016f5a3"><span class="std std-ref">PORT_TIMESTAMP_MAX</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to input from </p></li>
<li><p><strong>__t</strong> – The timestamp to do input on </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The inputted data</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_out_shift_right_at_time">
<span class="target" id="port_8h_1af531f11d505cc94c2b225f85a19bdbd7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_out_shift_right_at_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_timestamp_t" title="port_timestamp_t"><span class="n"><span class="pre">port_timestamp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_out_shift_right_at_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Outputs a value onto a port at a specified time and shifts the output data. </p>
<p>In the case of an unbuffered port, the value will be driven on the pins when on the clock cycle that moves the port counter to the specified time. In the case of a buffered port, the data will be stored in the buffer, and be serialised onto the output pins at the point that the time is reached. The given timestamp must be a valid port timestamp no less than <a class="reference internal" href="#port_8h_1abd187aad966b5266218833bcdfaa28b1"><span class="std std-ref">PORT_TIMESTAMP_MIN</span></a> and no greater than <a class="reference internal" href="#port_8h_1a9054464ccf5f8c9ebbbbee6d2016f5a3"><span class="std std-ref">PORT_TIMESTAMP_MAX</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to output to </p></li>
<li><p><strong>__t</strong> – The timestamp of the output </p></li>
<li><p><strong>__data</strong> – data is shifted right by the transfer width of the port, with the bits shifting out onto the port. </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The remaining shifted bits</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_in_shift_right_at_time">
<span class="target" id="port_8h_1a441c357f983a61555e58102f25ad2093"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_in_shift_right_at_time</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_timestamp_t" title="port_timestamp_t"><span class="n"><span class="pre">port_timestamp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__t</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_in_shift_right_at_time" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input data from a port at a specific time and shift the data. </p>
<p>In the case of an unbuffered port, the data will be inputted when the counter reaches time <em>t</em>. In the case of a buffered port, an input will wait until the given time and then will start capturing data, returning a value when the buffer is full. The given timestamp must be a valid port timestamp no less than <a class="reference internal" href="#port_8h_1abd187aad966b5266218833bcdfaa28b1"><span class="std std-ref">PORT_TIMESTAMP_MIN</span></a> and no greater than <a class="reference internal" href="#port_8h_1a9054464ccf5f8c9ebbbbee6d2016f5a3"><span class="std std-ref">PORT_TIMESTAMP_MAX</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to input from </p></li>
<li><p><strong>__t</strong> – The timestamp to do input on </p></li>
<li><p><strong>__data</strong> – Initial value to shift input data into </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of shifting <em>data</em> right by the port width and storing the input data in the most significant bits</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_in_when_pinseq">
<span class="target" id="port_8h_1a0ffd13cbff83a4e162991a194ef7577f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_in_when_pinseq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_type_t" title="port_type_t"><span class="n"><span class="pre">port_type_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__pt</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_in_when_pinseq" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input data from a port when its pins match a specific value. </p>
<p>In the case of an unbuffered port, the data inputted be identical to the value. In the case of a buffered port, an input will wait until the value appears on the pins and then return that value and some previous values that have been deserialised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to input from </p></li>
<li><p><strong>__pt</strong> – If port is buffered or unbuffered. </p></li>
<li><p><strong>__value</strong> – The value to match against the pins </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The inputted data</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_in_when_pinsneq">
<span class="target" id="port_8h_1afd4e5a0e792f97dd0b412660ee62634a"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_in_when_pinsneq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_type_t" title="port_type_t"><span class="n"><span class="pre">port_type_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__pt</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_in_when_pinsneq" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input data from a port when its pins do not match a specific value. </p>
<p>In the case of an unbuffered port, the inputted data will be the non-matching pin values. In the case of a buffered port, this function will wait until a non matching value appears on the pins, and then return that value and previous values that have been deserialised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to input from </p></li>
<li><p><strong>__pt</strong> – If port is buffered or unbuffered. </p></li>
<li><p><strong>__value</strong> – The value to match against the pins </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The inputted data</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_in_shift_right_when_pinseq">
<span class="target" id="port_8h_1ae9e2bb435d3ca03e04a28e1341f89308"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_in_shift_right_when_pinseq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_type_t" title="port_type_t"><span class="n"><span class="pre">port_type_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__pt</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__value</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_in_shift_right_when_pinseq" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input data from a port when its pins match a specific value and shift the data. </p>
<p>In the case of an unbuffered port, the data inputted be identical to the value. In the case of a buffered port, an input will wait until the value appears on the pins and then return that value and some previous values that have been deserialised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to input from </p></li>
<li><p><strong>__pt</strong> – If port is buffered or unbuffered. </p></li>
<li><p><strong>__value</strong> – The value to match against the pins </p></li>
<li><p><strong>__data</strong> – Initial value to shift input data into </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of shifting <em>data</em> right by the port width and storing the input data in the most significant bits</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_in_shift_right_when_pinsneq">
<span class="target" id="port_8h_1ab387bdff7e19be9a9e438cf5e3cbd02f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_in_shift_right_when_pinsneq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <a class="reference internal" href="#c.port_type_t" title="port_type_t"><span class="n"><span class="pre">port_type_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__pt</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__value</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_in_shift_right_when_pinsneq" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Input data from a port when its pins do not match a specific value and shift the data. </p>
<p>In the case of an unbuffered port, the inputted data will be the non-matching pin values. In the case of a buffered port, this macro will wait until a non matching value appears on the pins, and then return that value and previous values that have been deserialised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – Port to input from </p></li>
<li><p><strong>__pt</strong> – If port is buffered or unbuffered. </p></li>
<li><p><strong>__value</strong> – The value to match against the pins </p></li>
<li><p><strong>__data</strong> – Initial value to shift input data into </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of shifting <em>data</em> right by the port width and storing the input data in the most significant bits</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_clear_buffer">
<span class="target" id="port_8h_1a953c0136184044324f6cf999b9499ac2"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_clear_buffer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_clear_buffer" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clears the buffer used by a port. </p>
<p>Any data sampled by the port which has not been input by the processor is discarded. Any data output by the processor which has not been driven by the port is discarded. If the port is in the process of serialising output, it is interrupted immediately. If a pending output would have caused a change in direction of the port then that change of direction does not take place. If the port is driving a value on its pins when this function is called then it continues to drive the value until an output statement changes the value driven.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port whose buffer is to be cleared</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_endin">
<span class="target" id="port_8h_1a886d68d094cd65ccc11c171551114c02"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_endin</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_endin" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Ends the current input on a buffered port. </p>
<p>The number of bits sampled by the port but not yet input by the processor is returned. This count includes both data in the transfer register and data in the shift register used for deserialisation. Subsequent inputs on the port return transfer-width bits of data until there is less than one transfer-width bits of data remaining. Any remaining data can be read with one further input, which returns transfer-width bits of data with the remaining buffered data in the most significant bits of this value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to end the current input on </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bits of data remaining</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_force_input">
<span class="target" id="port_8h_1a0ebdb8510318bfe418ca92b7969750e4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_force_input</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_force_input" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Force an input on a buffered port. </p>
<p>Perform an input on a buffered port even if the buffer is only partially full.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to do the input on </p></li>
<li><p><strong>__data</strong> – <strong>[out]</strong> The inputted data</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively changing the port. </p>
</dd>
<dt class="field-even">Throws ET_LOAD_STORE<span class="colon">:</span></dt>
<dd class="field-even"><p>invalid <em>data</em> argument. </p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of bits input</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_trigger_value">
<span class="target" id="port_8h_1ad92d34ba38711dda204db1e9dcf8aa17"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_trigger_value</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_trigger_value" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sets the trigger value for a port with a configured trigger. </p>
<p>Changes only the trigger value of a port which has already been configured to trigger on a value using <a class="reference internal" href="#port_8h_1a8c7bca5a94cf9a89e2a5035346815d69"><span class="std std-ref">port_set_trigger_in_equal()</span></a> or <a class="reference internal" href="#port_8h_1a899c5c82c1e8391dd70da8393ff1e349"><span class="std std-ref">port_set_trigger_in_not_equal()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to change the trigger value of </p></li>
<li><p><strong>__value</strong> – The new trigger value to set</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_sync">
<span class="target" id="port_8h_1aca746b56212717438b04aa0344dc4e61"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_sync</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_sync" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Synchronise with the port to ensure all data has been output. </p>
<p>Block until all data has been shifted out of the port, with the final port-width bits being held for one clock period.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to synchronise</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid port. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_set_shift_count">
<span class="target" id="port_8h_1a9dc1ec9879dd783c6086ff07b7b012e1"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_set_shift_count</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__sc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_set_shift_count" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the port shift count for input and output operations. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to set the shift count for </p></li>
<li><p><strong>__sc</strong> – Shift count to set</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>Not a valid buffered port, or the shift count is not valid for the port width. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_out_part_word">
<span class="target" id="port_8h_1a7f19c0b1b4e48b2551d17a44250e8f99"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_out_part_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_t" title="port_t"><span class="n"><span class="pre">port_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__p</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__d</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__bitp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_out_part_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Output a part word to a port. </p>
<p>Writes a specified number of bits of a given value to the a buffered port</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is equivalent to using <a class="reference internal" href="#port_8h_1a9dc1ec9879dd783c6086ff07b7b012e1"><span class="std std-ref">port_set_shift_count()</span></a> followed by <a class="reference internal" href="#port_8h_1aaf8fe0e5c572c2caa3178d9d1aa1af34"><span class="std std-ref">port_out()</span></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__p</strong> – The port to output to </p></li>
<li><p><strong>__d</strong> – The word to take the part word from </p></li>
<li><p><strong>__bitp</strong> – The number of bits of __d to output.</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>Not a valid buffered port, the port is busy, or an invalid part-word width has been used. </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the port. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.port_time_after">
<span class="target" id="port_8h_1aaff84bda0aa8a7e8fa64f098544158ab"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">port_time_after</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.port_timestamp_t" title="port_timestamp_t"><span class="n"><span class="pre">port_timestamp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__a</span></span>, <a class="reference internal" href="#c.port_timestamp_t" title="port_timestamp_t"><span class="n"><span class="pre">port_timestamp_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.port_time_after" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Compare two port timestamps. </p>
<p>Convenience function which checks if a port timestamp <em>a</em> is later than another port timestamp <strong></strong>. Returns a nonzero value if <em>a</em> occurs after <em>b</em>, or zero otherwise. Returns 0 if <em>a</em> and <em>b</em> are equal.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Port timestamps have a limited range and can overflow and wrap to 0 (hence they cannot be compared trivially). A timestamp is considered ‘after’ another one if it is ahead by no more than half the range of a port timer. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Equivalent to XC’s <em>porttimeafter</em> from <em>xs1.h</em> </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__a</strong> – Port timestamp to compare to <em>__b</em> </p></li>
<li><p><strong>__b</strong> – Reference port timestamp</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-select-h">
<h3>xcore/select.h<a class="headerlink" href="#xcore-select-h" title="Permalink to this heading">#</a></h3>
<p>Macros for efficiently handling events from multiple resources. </p>
<p>Provides macros which expand to code for efficiently waiting for events on an arbitrary group of resources (analogous to a socket <code class="docutils literal notranslate"><span class="pre">select</span></code>). The general form of user code is:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT_MACRO</span><span class="p">(</span><span class="n">CASE_MACRO</span><span class="p">([</span><span class="o">...</span><span class="p">,]</span> <span class="n">CASE_LABEL</span><span class="p">)</span> <span class="p">[,</span> <span class="o">...</span><span class="p">])</span>
<span class="o">//</span> <span class="s2">&quot;select block&quot;</span><span class="p">:</span>
<span class="p">{</span>
<span class="n">CASE_LABEL</span><span class="p">:</span>
  <span class="p">[</span><span class="o">...</span><span class="p">;]</span>
  <span class="n">CASE_TERMINATOR</span><span class="p">;</span>
<span class="p">[</span><span class="o">...</span><span class="p">;]</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">of</span> <span class="n">select</span> <span class="n">block</span>
</pre></div>
</div>
</p>
<p>Where:</p>
<p><code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> defines the how the checking of events is implemented and is one of: <ul class="simple">
<li><p><a class="reference internal" href="#select_8h_1ae265e9b10593327ca5a580bfa59842fb"><span class="std std-ref">SELECT_RES()</span></a> - Repeatedly wait for an event on an arbitrary set of resources. </p></li>
<li><p><a class="reference internal" href="#select_8h_1a95d4b16819a89229bd0c444bd3c289fe"><span class="std std-ref">SELECT_RES_ORDERED()</span></a> - Repeatedly wait for an event on an arbitrary set of events giving priority to resources based on order.</p></li>
</ul>
<code class="docutils literal notranslate"><span class="pre">CASE_MACRO</span></code> determines the condition under which a case label will be jumped to and is one of: <ul class="simple">
<li><p><a class="reference internal" href="#select_8h_1a8bba6b25989f91699bdfe1651dbe7345"><span class="std std-ref">CASE_THEN()</span></a> - Unconditionally wait for an event on a given resource. </p></li>
<li><p><a class="reference internal" href="#select_8h_1a3d00cb2a05fa34f9bc43f9f69a3856e3"><span class="std std-ref">CASE_GUARD_THEN()</span></a> - Wait for an event on a given resource if a condition evaluates true. </p></li>
<li><p><a class="reference internal" href="#select_8h_1a0ad9063aa0b8d302b283b4454df09c63"><span class="std std-ref">CASE_NGUARD_THEN()</span></a> - Wait for an event on a given resource is a condition evaluates false. </p></li>
<li><p><a class="reference internal" href="#select_8h_1a45384c3df5c1c6a6c1b988e4c7d8443c"><span class="std std-ref">DEFAULT_THEN()</span></a> - Defines a label to jump to if no enabled resource events are ready. </p></li>
<li><p><a class="reference internal" href="#select_8h_1abd59e7929056bcef1063902995d122dc"><span class="std std-ref">DEFAULT_GUARD_THEN()</span></a> - Defines a label to jump to if no enabled resource events are ready and a condition evaluates true. </p></li>
<li><p><a class="reference internal" href="#select_8h_1a8c35736e54f7706688c751fda91f8990"><span class="std std-ref">DEFAULT_NGUARD_THEN()</span></a> Defines a label to jump to if no enabled resource events are ready and a condition evaluates false.</p></li>
</ul>
<code class="docutils literal notranslate"><span class="pre">CASE_LABEL</span></code> is a label inside the ‘select block’</p>
<p>The <strong>select</strong> <strong>block</strong> is compound statement consisting of sequences of statements prefixed with a <code class="docutils literal notranslate"><span class="pre">CASE_LABEL</span></code> and followed by a <code class="docutils literal notranslate"><span class="pre">CASE_TERMINATOR</span></code> </p>
<p><code class="docutils literal notranslate"><span class="pre">CASE_TERMINATOR</span></code> determines whether control exits the select block or handles further events and is one of: <ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">break</span></code> - Exits the select block </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">continue</span></code> - Waits for/handles another event or default </p></li>
<li><p><a class="reference internal" href="#select_8h_1acef6f9cc714536f75eae736963c86ad1"><span class="std std-ref">SELECT_CONTINUE_RESET</span></a> - Restores the configuration of the immediately enclosing select block and continues. </p></li>
<li><p><a class="reference internal" href="#select_8h_1aadf1898c53f7e5aa87c252e899eaedfd"><span class="std std-ref">SELECT_CONTINUE_NO_RESET</span></a> - Continues to handle another event in the immediately inclosing select block without applying global resource setup.</p></li>
</ul>

The default case is a case with no associated resource which is passed using one of the <code class="docutils literal notranslate"><span class="pre">DEFAULT_*</span></code> macros. There may only be one default case; if more than one expansion of a <code class="docutils literal notranslate"><span class="pre">DEFAULT_*</span></code> macro is passed to a <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> then it is unspecified which one is effective, even if a condition means only one can ever be enabled. If the effective default case is expanded from <a class="reference internal" href="#select_8h_1abd59e7929056bcef1063902995d122dc"><span class="std std-ref">DEFAULT_GUARD_THEN()</span></a> and its condition is false <strong>or</strong> it is expanded from <a class="reference internal" href="#select_8h_1a8c35736e54f7706688c751fda91f8990"><span class="std std-ref">DEFAULT_NGUARD_THEN()</span></a> and its condition is true, then the effect is as if there were no default case.</p>
<p>When the code expanded from a <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> is executed, qualifying resources are checked for events. Qualifying resources are those which were passed to the immediately enclosing select block’s SELECT_MACRO: <ul class="simple">
<li><p>By expanding <a class="reference internal" href="#select_8h_1a8bba6b25989f91699bdfe1651dbe7345"><span class="std std-ref">CASE_THEN()</span></a>; or </p></li>
<li><p>By expanding <a class="reference internal" href="#select_8h_1a3d00cb2a05fa34f9bc43f9f69a3856e3"><span class="std std-ref">CASE_GUARD_THEN()</span></a> and where the condition evaluates true; or </p></li>
<li><p>By expanding <a class="reference internal" href="#select_8h_1a0ad9063aa0b8d302b283b4454df09c63"><span class="std std-ref">CASE_NGUARD_THEN()</span></a> and where the conditional evaluates false.</p></li>
</ul>

If there is an event waiting on a qualifying resource then control is transferred to the associated label (as passed to its <code class="docutils literal notranslate"><span class="pre">CASE_MACRO</span></code>). If no such event is available then: <ul class="simple">
<li><p>If there is a default case (and it is not disabled by a condition) then control is transferred to the associated label; </p></li>
<li><p>Otherwise execution pauses until an event is available at which point control is transferred to its associated label.</p></li>
</ul>

Control continues as usual within a select block until a <code class="docutils literal notranslate"><span class="pre">CASE_TERMINATOR</span></code> is executed. At that point the behaviour depends on the terminator: <ul class="simple">
<li><p>If control reaches a <code class="docutils literal notranslate"><span class="pre">break</span></code> then control will exit the immediately enclosing select block. </p></li>
<li><p>If control reaches the expansion of <code class="docutils literal notranslate"><span class="pre">SELECT_CONTINUE_NO_RESET</span></code> then the effect is as if control were transferred back to the beginning of the expansion of the <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code>, except that some setup is skipped. If an inner (i.e. nested) <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> expansion has been executed (even as a result of calling a function), since control was transferred into the immediately enclosing select block by the immediately preceding <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> expansion, then the use of <code class="docutils literal notranslate"><span class="pre">SELECT_CONTINUE_NO_RESET</span></code> to terminate the outer select construct has undefined behaviour. </p></li>
<li><p>If control reaches the expansion of <a class="reference internal" href="#select_8h_1acef6f9cc714536f75eae736963c86ad1"><span class="std std-ref">SELECT_CONTINUE_RESET</span></a> then the effect is as if control were transferred to the beginning of the expansion of the <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> for the immediately enclosing select block. This effectively resets the select construct and makes ineffective any setup performed by any nested <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> which would affect the execution of the immediately enclosing one. </p></li>
<li><p>If control reaches a <code class="docutils literal notranslate"><span class="pre">continue</span></code> then the effect is as if control had reached the expansion of SELECT_CONTINUE_RESET if a SELECT_MACRO expansion has been executed since since control was transferred into the immediately enclosing select block by the immediately preceding <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code>. Otherwise the effect is as if the expansion of <code class="docutils literal notranslate"><span class="pre">SELECT_CONTINUE_RESET</span></code> were executed. </p></li>
<li><p>If control reaches the end of a select block without reaching a CASE_TERMINATOR then the behaviour will be as if a <code class="docutils literal notranslate"><span class="pre">CASE_TERMINATOR</span></code> had been reached but it is unspecified which one. (Thus this may result in undefined behaviour if a nested select construct has been executed.)</p></li>
</ul>

The behaviour is undefined if control is transferred into a select block by any other means than by: <ul class="simple">
<li><p>Executing the immediately preceding <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> expansion; </p></li>
<li><p>Returning from a function call; </p></li>
<li><p>Executing a <code class="docutils literal notranslate"><span class="pre">CASE_TERMINATOR</span></code>. Additionally, transferring control out of a select block by any means other than calling a function or executing <code class="docutils literal notranslate"><span class="pre">break</span></code> as a <code class="docutils literal notranslate"><span class="pre">CASE_TERMINATOR</span></code> has undefined behaviour.</p></li>
</ul>

If the expansion of a <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> or a <code class="docutils literal notranslate"><span class="pre">CASE_TERMINATOR</span></code> is executed and: <ul class="simple">
<li><p>There are no qualifying resources, and </p></li>
<li><p>There is no default case or the effective default case is disabled by a condition,</p></li>
</ul>

then the behaviour is undefined. <code class="docutils literal notranslate"><span class="pre">CASE_MACRO</span></code> (including default case) conditions are evaluated on initial entry to the SELECT_MACRO expansion and after each execution of a <code class="docutils literal notranslate"><span class="pre">CASE_TERMINATOR</span></code> other than <code class="docutils literal notranslate"><span class="pre">break</span></code>. If evaluation of a case condition has side effects then the behaviour is of the select construct is undefined.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">CASE_LABEL</span></code> is placed within a select block such that it would be illegal to use <code class="docutils literal notranslate"><span class="pre">goto</span></code> to jump to it from the point at which <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> is expanded, then the behaviour is undefined.</p>
<p>Each resource passed (though a <code class="docutils literal notranslate"><span class="pre">CASE_MACRO</span></code>) to a <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> must be unique within that <code class="docutils literal notranslate"><span class="pre">SELECT_MACRO</span></code> expansion, otherwise the behaviour of the select construct is undefined. That is, the same resource must not be used for two different cases. This applies even if cases are guarded by mutually exclusive conditions. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is intended to provide a safe means of handling further events if arbitrary code has been executed which may have used a select construct. Its use is likely to incur a runtime performance penalty compared to using the most appropriate of <code class="docutils literal notranslate"><span class="pre">SELECT_CONTINUE_RESET</span></code> and <code class="docutils literal notranslate"><span class="pre">SELECT_CONTINUE_NO_RESET</span></code>. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Normal language rules apply - <code class="docutils literal notranslate"><span class="pre">break</span></code> and <code class="docutils literal notranslate"><span class="pre">continue</span></code> affect the relevant enclosing construct - so if they are nested within e.g. a loop then they will not terminate the select block. This also applies to other case terminators which must only appear within a select block. Thus it is impossible to exit a select block from a function.</p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.SELECT_RES">
<span class="target" id="select_8h_1ae265e9b10593327ca5a580bfa59842fb"></span><span class="sig-name descname"><span class="n"><span class="pre">SELECT_RES</span></span></span><span class="sig-paren">(</span><span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.SELECT_RES" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Repeatedly wait for an event on an arbitrary set of resources. </p>
<p>Selects on one or more resources with an optional default. If more than one event is available then it is upspecified which one will be taken.</p>
<p>
Example: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">button_up</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">button_event_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">SELECT_RES</span><span class="p">(</span>
  <span class="n">CASE_GUARD_THEN</span><span class="p">(</span><span class="n">button_chanend</span><span class="p">,</span> <span class="n">button_event_count</span> <span class="o">&lt;</span> <span class="mi">21</span><span class="p">,</span> <span class="n">event_button_chanend</span><span class="p">),</span>
  <span class="n">CASE_THEN</span><span class="p">(</span><span class="n">led_chanend</span><span class="p">,</span> <span class="n">event_led_chanend</span><span class="p">),</span>
  <span class="n">DEFAULT_NGUARD_THEN</span><span class="p">(</span><span class="n">button_up</span><span class="p">,</span> <span class="n">default_label</span><span class="p">))</span>
<span class="p">{</span>
<span class="n">default_label</span><span class="p">:</span>
  <span class="n">puts</span><span class="p">(</span><span class="s2">&quot;Button is still down!&quot;</span><span class="p">);</span>
  <span class="n">SELECT_RESET</span><span class="p">;</span>
<span class="n">event_button_chanend</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">chan_in_word</span><span class="p">(</span><span class="n">button_chanend</span><span class="p">);</span>
    <span class="n">chan_out_word</span><span class="p">(</span><span class="n">led_chanend</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="n">button_up</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">button_event_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">continue</span><span class="p">;</span>
<span class="n">event_led_chanend</span><span class="p">:</span>
  <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">chan_in_word</span><span class="p">(</span><span class="n">led_chanend</span><span class="p">);</span>
    <span class="n">chan_out_word</span><span class="p">(</span><span class="n">button_chanend</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>...</strong> – case specifications as expanded from the <code class="docutils literal notranslate"><span class="pre">CASE_*</span></code> or <code class="docutils literal notranslate"><span class="pre">DEFAULT_*</span></code> macros</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.SELECT_RES_ORDERED">
<span class="target" id="select_8h_1a95d4b16819a89229bd0c444bd3c289fe"></span><span class="sig-name descname"><span class="n"><span class="pre">SELECT_RES_ORDERED</span></span></span><span class="sig-paren">(</span><span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.SELECT_RES_ORDERED" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Repeatedly wait for an event on an arbitrary set of events giving priority to resources based on order. </p>
<p>Behaviour is like <a class="reference internal" href="#select_8h_1ae265e9b10593327ca5a580bfa59842fb"><span class="std std-ref">SELECT_RES()</span></a> except that events are checked in the order their respective <code class="docutils literal notranslate"><span class="pre">CASE_*</span></code> expansions are passed. This can be used to ensure that high priority events are serviced before lower priority ones.</p>
<p>If there is an event on the highest priority qualifying resource upon execution of the expansion of <a class="reference internal" href="#select_8h_1a95d4b16819a89229bd0c444bd3c289fe"><span class="std std-ref">SELECT_RES_ORDERED()</span></a>, or a select terminator within its immediately following select block, then if is guaranteed that event will be taken. For any other priority in this case (if it is the highest priority event) then it is guarateed that it will be taken, but only if no higher priority event becomes available (in which case the event taken is unspecified). If no event is available then the default case will be taken if there is a default case and it is enabled. If there is no default case or the default case is disabled by a condition then execution will pause and wait for an event on a qualifying resource - in this case prioties no longer apply and the first event which becomes available will be taken.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a runtime overhead associated with checking events in order so it is suggested that <a class="reference internal" href="#select_8h_1ae265e9b10593327ca5a580bfa59842fb"><span class="std std-ref">SELECT_RES()</span></a> be used whenever possible. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>...</strong> – case specifications as expanded from the <code class="docutils literal notranslate"><span class="pre">CASE_*</span></code> or <code class="docutils literal notranslate"><span class="pre">DEFAULT_*</span></code> macros</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.SELECT_CONTINUE_RESET">
<span class="target" id="select_8h_1acef6f9cc714536f75eae736963c86ad1"></span><span class="sig-name descname"><span class="n"><span class="pre">SELECT_CONTINUE_RESET</span></span></span><a class="headerlink" href="#c.SELECT_CONTINUE_RESET" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Restores the configuration of the immediately enclosing select block and continues. </p>
<p>This may be used instead of <code class="docutils literal notranslate"><span class="pre">continue</span></code> as a select terminator if a different (to the immediately enclosing one) select construct has been executed. The effect is that the resource setup which happens at the start of the select construct is guaranteed to re-run so that the correct events will be enabled. Using this instead of <code class="docutils literal notranslate"><span class="pre">continue</span></code> (when required) is likely to result in a slight performance boost as it eliminates the need to check global state. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.SELECT_CONTINUE_NO_RESET">
<span class="target" id="select_8h_1aadf1898c53f7e5aa87c252e899eaedfd"></span><span class="sig-name descname"><span class="n"><span class="pre">SELECT_CONTINUE_NO_RESET</span></span></span><a class="headerlink" href="#c.SELECT_CONTINUE_NO_RESET" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Continues to handle another event in the immediately inclosing select block without applying global resource setup. </p>
<p>This may be used in stead of <code class="docutils literal notranslate"><span class="pre">continue</span></code> as a select terminator if different select block has not been executed during handling of the previous event (or default). In the event that another select construct has executed this will have undefined behaviour.</p>
<p>Using this instead of <code class="docutils literal notranslate"><span class="pre">continue</span></code> (when safe to do so) is likely to result in a slight performance improvement. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.CASE_THEN">
<span class="target" id="select_8h_1a8bba6b25989f91699bdfe1651dbe7345"></span><span class="sig-name descname"><span class="n"><span class="pre">CASE_THEN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_RES</span></span>, <span class="n"><span class="pre">_LABEL</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.CASE_THEN" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Unconditionally wait for an event on a given resource. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_RES</strong> – The resource to wait for an event on. </p></li>
<li><p><strong>_LABEL</strong> – The label (within the following select block) to jump to when an event occurs on <em>res</em>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.CASE_GUARD_THEN">
<span class="target" id="select_8h_1a3d00cb2a05fa34f9bc43f9f69a3856e3"></span><span class="sig-name descname"><span class="n"><span class="pre">CASE_GUARD_THEN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_RES</span></span>, <span class="n"><span class="pre">_GUARD_EXPR</span></span>, <span class="n"><span class="pre">_LABEL</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.CASE_GUARD_THEN" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Wait for an event on a given resource if a condition evaluates true. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_RES</strong> – The resource to wait for an event on. </p></li>
<li><p><strong>_GUARD_EXPR</strong> – Expression to evaluate to determine if this case should be enabled. Must not have side effects. </p></li>
<li><p><strong>_LABEL</strong> – The label (within the following select block) to jump to when an event occurs on <em>res</em>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.CASE_NGUARD_THEN">
<span class="target" id="select_8h_1a0ad9063aa0b8d302b283b4454df09c63"></span><span class="sig-name descname"><span class="n"><span class="pre">CASE_NGUARD_THEN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_RES</span></span>, <span class="n"><span class="pre">_GUARD_EXPR</span></span>, <span class="n"><span class="pre">_LABEL</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.CASE_NGUARD_THEN" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Wait for an event on a given resource is a condition evaluates false. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_RES</strong> – The resource to wait for an event on. </p></li>
<li><p><strong>_GUARD_EXPR</strong> – Expression to evaluate to determine if this case should be disabled. Must not have side effects. </p></li>
<li><p><strong>_LABEL</strong> – The label (within the following select block) to jump to when an event occurs on <em>res</em>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFAULT_THEN">
<span class="target" id="select_8h_1a45384c3df5c1c6a6c1b988e4c7d8443c"></span><span class="sig-name descname"><span class="n"><span class="pre">DEFAULT_THEN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_LABEL</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFAULT_THEN" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Defines a label to jump to if no enabled resource events are ready. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_LABEL</strong> – The label (within the following select block) to jump to if there are no events to take. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFAULT_GUARD_THEN">
<span class="target" id="select_8h_1abd59e7929056bcef1063902995d122dc"></span><span class="sig-name descname"><span class="n"><span class="pre">DEFAULT_GUARD_THEN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_GUARD_EXPR</span></span>, <span class="n"><span class="pre">_LABEL</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFAULT_GUARD_THEN" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Defines a label to jump to if no enabled resource events are ready and a condition evaluates true. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_LABEL</strong> – The label (within the following select block) to jump to if there are no events to take. </p></li>
<li><p><strong>_GUARD_EXPR</strong> – Expression to determine it the default case should be enabled. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFAULT_NGUARD_THEN">
<span class="target" id="select_8h_1a8c35736e54f7706688c751fda91f8990"></span><span class="sig-name descname"><span class="n"><span class="pre">DEFAULT_NGUARD_THEN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">_GUARD_EXPR</span></span>, <span class="n"><span class="pre">_LABEL</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFAULT_NGUARD_THEN" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Defines a label to jump to if no enabled resource events are ready and a condition evaluates false. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_LABEL</strong> – The label (within the following select block) to jump to if there are no events to take. </p></li>
<li><p><strong>_GUARD_EXPR</strong> – Expression to determine it the default case should be disabled. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-swmem-evict-h">
<h3>xcore/swmem_evict.h<a class="headerlink" href="#xcore-swmem-evict-h" title="Permalink to this heading">#</a></h3>
<p>API for implementing software memory fill (write) </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.SWMEM_EVICT_SIZE_WORDS">
<span class="target" id="swmem__evict_8h_1ac39dfd1932a22a96203a2381c2b4223c"></span><span class="sig-name descname"><span class="n"><span class="pre">SWMEM_EVICT_SIZE_WORDS</span></span></span><a class="headerlink" href="#c.SWMEM_EVICT_SIZE_WORDS" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Number of words which must be evicted per eviction request. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.swmem_evict_t">
<span class="target" id="swmem__evict_8h_1a6608b4bd6b7b00da68ea7007d5b537b4"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_evict_t</span></span></span><a class="headerlink" href="#c.swmem_evict_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Handle type for a SwMem evict resource. </p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.evict_slot_t">
<span class="target" id="swmem__evict_8h_1a2ab68e2117995ebf5447d8804ab43a5e"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">evict_slot_t</span></span></span><a class="headerlink" href="#c.evict_slot_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Pointer to an eviction slot - this is the lowest address which must be evicted. </p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.evict_mask_t">
<span class="target" id="swmem__evict_8h_1aabe99fa6501b8737d74585fb8a07405d"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">evict_mask_t</span></span></span><a class="headerlink" href="#c.evict_mask_t" title="Permalink to this definition">#</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_evict_get">
<span class="target" id="swmem__evict_8h_1afb1bcbe8e196a1b6397e386d4a712ec8"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.swmem_evict_t" title="swmem_evict_t"><span class="n"><span class="pre">swmem_evict_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_evict_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_evict_get" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gets and enables a swmem evict resource. </p>
<p>The handle must be passed to <a class="reference internal" href="#swmem__evict_8h_1a806f9bbb60a6199e1128f4ca4c6f2a89"><span class="std std-ref">swmem_evict_free()</span></a> before this function is called again.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#swmem__evict_8h_1a806f9bbb60a6199e1128f4ca4c6f2a89"><span class="std std-ref">swmem_evict_free()</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The swmem evict handle.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_evict_free">
<span class="target" id="swmem__evict_8h_1a806f9bbb60a6199e1128f4ca4c6f2a89"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_evict_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_evict_t" title="swmem_evict_t"><span class="n"><span class="pre">swmem_evict_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_evict_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Disables a swmem evict resource as returned by <a class="reference internal" href="#swmem__evict_8h_1afb1bcbe8e196a1b6397e386d4a712ec8"><span class="std std-ref">swmem_evict_get()</span></a> </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#swmem__evict_8h_1afb1bcbe8e196a1b6397e386d4a712ec8"><span class="std std-ref">swmem_evict_get()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_evict_in_address">
<span class="target" id="swmem__evict_8h_1ac54e8ce6cafbb33557d4d1106f9fa783"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.evict_slot_t" title="evict_slot_t"><span class="n"><span class="pre">evict_slot_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_evict_in_address</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_evict_t" title="swmem_evict_t"><span class="n"><span class="pre">swmem_evict_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_evict_in_address" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Returns the slot handle of the waiting swmem eviction request, blocks if there isn’t one. </p>
<p>When a eviction request is raised, the contents of the ‘eviction slot’ are available to be read until the request is completed. Fulfilling the request may unblock another thread which is attempting to write.</p>
<p>The handle returned is the lowest address in the eviction request; the length of the request is always <a class="reference internal" href="#swmem__evict_8h_1ac39dfd1932a22a96203a2381c2b4223c"><span class="std std-ref">SWMEM_EVICT_SIZE_WORDS</span></a> words.</p>
<p>Words can be read from the eviction slot individually using <a class="reference internal" href="#swmem__evict_8h_1a73839d538a4613781695a8d438c53ad4"><span class="std std-ref">swmem_evict_read_word()</span></a>; once all required words have been read <a class="reference internal" href="#swmem__evict_8h_1aa3770481d271d79739132ccaa4d1a4fb"><span class="std std-ref">swmem_evict_read_word_done()</span></a> should be called to complete the request. Alternatively, <a class="reference internal" href="#swmem__evict_8h_1a54d8c894db78680fb24a4b663a0c03c4"><span class="std std-ref">swmem_evict_to_buffer()</span></a> may be used to read and complete the request in a single call.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#swmem__evict_8h_1a806f9bbb60a6199e1128f4ca4c6f2a89"><span class="std std-ref">swmem_evict_free()</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__r</strong> – The swmem evict resource handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An eviction slot handle</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_evict_read_word">
<span class="target" id="swmem__evict_8h_1a73839d538a4613781695a8d438c53ad4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_evict_read_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_evict_t" title="swmem_evict_t"><span class="n"><span class="pre">swmem_evict_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span>, <a class="reference internal" href="#c.evict_slot_t" title="evict_slot_t"><span class="n"><span class="pre">evict_slot_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__slot</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">__word_index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_evict_read_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Read a single word from an eviction slot. </p>
<p>Returns the word from the eviction slot at the given index. To complete the eviction <a class="reference internal" href="#swmem__evict_8h_1aa3770481d271d79739132ccaa4d1a4fb"><span class="std std-ref">swmem_evict_read_word_done()</span></a> should be called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__r</strong> – The swmem evict resource handle </p></li>
<li><p><strong>__slot</strong> – The eviction slot to read from (returned by <a class="reference internal" href="#swmem__evict_8h_1ac54e8ce6cafbb33557d4d1106f9fa783"><span class="std std-ref">swmem_evict_in_address()</span></a>) </p></li>
<li><p><strong>__word_index</strong> – The index of the word (must be less than <a class="reference internal" href="#swmem__evict_8h_1ac39dfd1932a22a96203a2381c2b4223c"><span class="std std-ref">SWMEM_EVICT_SIZE_WORDS</span></a>) </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The word at the given <em>__word_index</em> within the evict slot </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_evict_get_dirty_mask">
<span class="target" id="swmem__evict_8h_1ae8c00c41bf09d9c967920de9f0eff394"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.evict_mask_t" title="evict_mask_t"><span class="n"><span class="pre">evict_mask_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_evict_get_dirty_mask</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_evict_t" title="swmem_evict_t"><span class="n"><span class="pre">swmem_evict_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span>, <a class="reference internal" href="#c.evict_slot_t" title="evict_slot_t"><span class="n"><span class="pre">evict_slot_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_evict_get_dirty_mask" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gets the dirty mask for the current eviction. </p>
<p>The mask returned is a bytewise dirty mask with one bit per byte in the entire eviction slot. This must only be called before the eviction request has been completed - i.e. it must be called <strong>before</strong> <a class="reference internal" href="#swmem__evict_8h_1aa3770481d271d79739132ccaa4d1a4fb"><span class="std std-ref">swmem_evict_read_word_done()</span></a> or <a class="reference internal" href="#swmem__evict_8h_1a54d8c894db78680fb24a4b663a0c03c4"><span class="std std-ref">swmem_evict_to_buffer()</span></a> for a given eviction request.</p>
<p>A byte is dirty if it has been written since it was last filled, or if it has been written but has never been filled (see swmem_fill.h).</p>
<p>The least significant bit in the dirty mask corresponds to the lowest byte address in the fill slot and each subsequent byte address corresponds to the next least significant bit of the dirty mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__r</strong> – The evict resource </p></li>
<li><p><strong>__slot</strong> – The current eviction slot </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A bytewise dirty mask for the given eviction on the given resource </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_evict_read_word_done">
<span class="target" id="swmem__evict_8h_1aa3770481d271d79739132ccaa4d1a4fb"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_evict_read_word_done</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_evict_t" title="swmem_evict_t"><span class="n"><span class="pre">swmem_evict_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span>, <a class="reference internal" href="#c.evict_slot_t" title="evict_slot_t"><span class="n"><span class="pre">evict_slot_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_evict_read_word_done" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Complete an eviction and unblock waiting threads. </p>
<p>This should be called after <a class="reference internal" href="#swmem__evict_8h_1a73839d538a4613781695a8d438c53ad4"><span class="std std-ref">swmem_evict_read_word()</span></a> has been used to get all required words from the evict request.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is not necessary (or safe) to call this if the request is fulfilled by calling <a class="reference internal" href="#swmem__evict_8h_1a54d8c894db78680fb24a4b663a0c03c4"><span class="std std-ref">swmem_evict_to_buffer()</span></a>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__r</strong> – The swmem evict resource handle </p></li>
<li><p><strong>__slot</strong> – The evict slot for the current eviction requesst</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_evict_to_buffer">
<span class="target" id="swmem__evict_8h_1a54d8c894db78680fb24a4b663a0c03c4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_evict_to_buffer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_evict_t" title="swmem_evict_t"><span class="n"><span class="pre">swmem_evict_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span>, <a class="reference internal" href="#c.evict_slot_t" title="evict_slot_t"><span class="n"><span class="pre">evict_slot_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__slot</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_evict_to_buffer" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Evict a slot into a buffer. </p>
<p>For an evict slot returned by <a class="reference internal" href="#swmem__evict_8h_1ac54e8ce6cafbb33557d4d1106f9fa783"><span class="std std-ref">swmem_evict_in_address()</span></a>, reads the eviction slot into the given buffer and completes the eviction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the dirty mask is required for the data read then it should be retrieved prior to calling this function. (Since the eviction will be complete on return.)</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__r</strong> – The swmem evict resource handle </p></li>
<li><p><strong>__slot</strong> – The eviction slot to read (returned by <a class="reference internal" href="#swmem__evict_8h_1ac54e8ce6cafbb33557d4d1106f9fa783"><span class="std std-ref">swmem_evict_in_address()</span></a>) </p></li>
<li><p><strong>__buf</strong> – Buffer of at least <a class="reference internal" href="#swmem__evict_8h_1ac39dfd1932a22a96203a2381c2b4223c"><span class="std std-ref">SWMEM_EVICT_SIZE_WORDS</span></a> words to evict the slot to </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-swmem-fill-h">
<h3>xcore/swmem_fill.h<a class="headerlink" href="#xcore-swmem-fill-h" title="Permalink to this heading">#</a></h3>
<p>API for implementing software memory fill (read) </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.SWMEM_FILL_SIZE_WORDS">
<span class="target" id="swmem__fill_8h_1a8c1b435a15eef23ed0fa42263d11fb11"></span><span class="sig-name descname"><span class="n"><span class="pre">SWMEM_FILL_SIZE_WORDS</span></span></span><a class="headerlink" href="#c.SWMEM_FILL_SIZE_WORDS" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Number of words which must be filled per fill request. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.swmem_fill_buffer_t">
<span class="target" id="swmem__fill_8h_1a6431e4458545e8928e0ae3a005312214"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_fill_buffer_t</span></span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#c.SWMEM_FILL_SIZE_WORDS" title="SWMEM_FILL_SIZE_WORDS"><span class="n"><span class="pre">SWMEM_FILL_SIZE_WORDS</span></span></a><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#c.swmem_fill_buffer_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Buffer type which holds the correct number of words for a complete fill. </p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.swmem_fill_t">
<span class="target" id="swmem__fill_8h_1a6b776a560b0d7d48ad42f516531ed852"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_fill_t</span></span></span><a class="headerlink" href="#c.swmem_fill_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Handle type for a SwMem fill resource. </p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.fill_slot_t">
<span class="target" id="swmem__fill_8h_1adf0638b994092780cf3c2d5c304ebfcf"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fill_slot_t</span></span></span><a class="headerlink" href="#c.fill_slot_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Pointer to a fill slot - this is the lowest address which must be filled. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_fill_get">
<span class="target" id="swmem__fill_8h_1a92165c5b3b07fa934ce1f1f14d00e6ae"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.swmem_fill_t" title="swmem_fill_t"><span class="n"><span class="pre">swmem_fill_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_fill_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_fill_get" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gets and enables a swmem fill resource. </p>
<p>The handle must be passed to <a class="reference internal" href="#swmem__fill_8h_1add65450537ec7f8baecf60bec7c02654"><span class="std std-ref">swmem_fill_free()</span></a> before this function is called again.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#swmem__fill_8h_1add65450537ec7f8baecf60bec7c02654"><span class="std std-ref">swmem_fill_free()</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The swmem fill handle.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_fill_free">
<span class="target" id="swmem__fill_8h_1add65450537ec7f8baecf60bec7c02654"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_fill_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_fill_t" title="swmem_fill_t"><span class="n"><span class="pre">swmem_fill_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_fill_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Disables a swmem fill resource as returned by <a class="reference internal" href="#swmem__fill_8h_1a92165c5b3b07fa934ce1f1f14d00e6ae"><span class="std std-ref">swmem_fill_get()</span></a> </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#swmem__fill_8h_1a92165c5b3b07fa934ce1f1f14d00e6ae"><span class="std std-ref">swmem_fill_get()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_fill_in_address">
<span class="target" id="swmem__fill_8h_1a253162a74665e8be53af1fc0668c6e1e"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.fill_slot_t" title="fill_slot_t"><span class="n"><span class="pre">fill_slot_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_fill_in_address</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_fill_t" title="swmem_fill_t"><span class="n"><span class="pre">swmem_fill_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_fill_in_address" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Returns the slot handle of the waiting swmem fill request, blocks if there isn’t one. </p>
<p>When a fill request is raised, the complete ‘fill slot’ must be populated. There are two ways of doing this: <ul class="simple">
<li><p>Passing a complete buffer of length <a class="reference internal" href="#swmem__fill_8h_1a8c1b435a15eef23ed0fa42263d11fb11"><span class="std std-ref">SWMEM_FILL_SIZE_WORDS</span></a> words to <a class="reference internal" href="#swmem__fill_8h_1acbfd50a3bb69bb754651f354ed26c4b3"><span class="std std-ref">swmem_fill_populate_from_buffer()</span></a> </p></li>
<li><p>Calling <a class="reference internal" href="#swmem__fill_8h_1a4b93071f97358ea28a18b84d729adb6b"><span class="std std-ref">swmem_fill_populate_word()</span></a> for each individual word in the fill slot (i.e. at least <a class="reference internal" href="#swmem__fill_8h_1a8c1b435a15eef23ed0fa42263d11fb11"><span class="std std-ref">SWMEM_FILL_SIZE_WORDS</span></a> times) and then calling <a class="reference internal" href="#swmem__fill_8h_1ac6a7c6bf81c22d23f798dc3b11877d04"><span class="std std-ref">swmem_fill_populate_word_done()</span></a>.</p></li>
</ul>

The handle returned is the lowest address in the fill request; the length of the fill request is always <a class="reference internal" href="#swmem__fill_8h_1a8c1b435a15eef23ed0fa42263d11fb11"><span class="std std-ref">SWMEM_FILL_SIZE_WORDS</span></a> words.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__r</strong> – The swmem fill resource handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A fill slot handle which must be populated </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_fill_populate_word">
<span class="target" id="swmem__fill_8h_1a4b93071f97358ea28a18b84d729adb6b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_fill_populate_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_fill_t" title="swmem_fill_t"><span class="n"><span class="pre">swmem_fill_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span>, <a class="reference internal" href="#c.fill_slot_t" title="fill_slot_t"><span class="n"><span class="pre">fill_slot_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__slot</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">__word_index</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">__value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_fill_populate_word" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Populate a single word in a fill slot. </p>
<p>Fills a single word in a fill slot for a waiting fill request. The fill slot must be the last one returned by <a class="reference internal" href="#swmem__fill_8h_1a253162a74665e8be53af1fc0668c6e1e"><span class="std std-ref">swmem_fill_in_address()</span></a> and the fill request must not have been completed either by calling <a class="reference internal" href="#swmem__fill_8h_1ac6a7c6bf81c22d23f798dc3b11877d04"><span class="std std-ref">swmem_fill_populate_word_done()</span></a> or by calling <a class="reference internal" href="#swmem__fill_8h_1acbfd50a3bb69bb754651f354ed26c4b3"><span class="std std-ref">swmem_fill_populate_from_buffer()</span></a>. To fulfill a request this function should be called for each word in the fill slot (i.e. with word_index set to each of <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">SWMEM_FILL_SIZE_WORDS)</span></code>. Once all words have been populated in the fill slot, <a class="reference internal" href="#swmem__fill_8h_1ac6a7c6bf81c22d23f798dc3b11877d04"><span class="std std-ref">swmem_fill_populate_word_done()</span></a> should be called to complete the fulfillment of the request and unblock any threads waiting for the fill.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is safe to call this multiple times for the same word_index of a fill request, but only the last such call will have any effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__r</strong> – The swmem fill resource handle </p></li>
<li><p><strong>__slot</strong> – The fill slot to populate (returned by <a class="reference internal" href="#swmem__fill_8h_1a253162a74665e8be53af1fc0668c6e1e"><span class="std std-ref">swmem_fill_in_address()</span></a>) </p></li>
<li><p><strong>__word_index</strong> – The index of the word (must be less than <a class="reference internal" href="#swmem__fill_8h_1a8c1b435a15eef23ed0fa42263d11fb11"><span class="std std-ref">SWMEM_FILL_SIZE_WORDS</span></a>) </p></li>
<li><p><strong>__value</strong> – The value to set at the given index </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_fill_populate_word_done">
<span class="target" id="swmem__fill_8h_1ac6a7c6bf81c22d23f798dc3b11877d04"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_fill_populate_word_done</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_fill_t" title="swmem_fill_t"><span class="n"><span class="pre">swmem_fill_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span>, <a class="reference internal" href="#c.fill_slot_t" title="fill_slot_t"><span class="n"><span class="pre">fill_slot_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_fill_populate_word_done" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Complete a fill and unblock waiting threads. </p>
<p>This should be called after <a class="reference internal" href="#swmem__fill_8h_1a4b93071f97358ea28a18b84d729adb6b"><span class="std std-ref">swmem_fill_populate_word()</span></a> has been used to fill each word in the fill request.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is not necessary (or safe) to call this if the request is fulfilled by calling <a class="reference internal" href="#swmem__fill_8h_1acbfd50a3bb69bb754651f354ed26c4b3"><span class="std std-ref">swmem_fill_populate_from_buffer()</span></a>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__r</strong> – The swmem fill resource handle </p></li>
<li><p><strong>__slot</strong> – The fill slot for the ongoing fill request</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.swmem_fill_populate_from_buffer">
<span class="target" id="swmem__fill_8h_1acbfd50a3bb69bb754651f354ed26c4b3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">swmem_fill_populate_from_buffer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.swmem_fill_t" title="swmem_fill_t"><span class="n"><span class="pre">swmem_fill_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__r</span></span>, <a class="reference internal" href="#c.fill_slot_t" title="fill_slot_t"><span class="n"><span class="pre">fill_slot_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__slot</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__source</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.swmem_fill_populate_from_buffer" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Service a fill request using data in a suitably sized buffer. </p>
<p>For a fill slot returned by <a class="reference internal" href="#swmem__fill_8h_1a253162a74665e8be53af1fc0668c6e1e"><span class="std std-ref">swmem_fill_in_address()</span></a>, services the waiting fill request using data from <em>__source</em> - this must point to a buffer of at least <a class="reference internal" href="#swmem__fill_8h_1a8c1b435a15eef23ed0fa42263d11fb11"><span class="std std-ref">SWMEM_FILL_SIZE_WORDS</span></a> words; source[0] will be used to fill the 0th word in the fill slot, and so on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__r</strong> – The swmem fill resource handle </p></li>
<li><p><strong>__slot</strong> – The fill slot to populate (returned by <a class="reference internal" href="#swmem__fill_8h_1a253162a74665e8be53af1fc0668c6e1e"><span class="std std-ref">swmem_fill_in_address()</span></a>) </p></li>
<li><p><strong>__source</strong> – Buffer of at least <a class="reference internal" href="#swmem__fill_8h_1a8c1b435a15eef23ed0fa42263d11fb11"><span class="std std-ref">SWMEM_FILL_SIZE_WORDS</span></a> words to fill the slot from </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-thread-h">
<h3>xcore/thread.h<a class="headerlink" href="#xcore-thread-h" title="Permalink to this heading">#</a></h3>
<p>Hardware-assisted threading support. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.xthread_t">
<span class="target" id="thread_8h_1adecec4f41692b1bc56a401c52a0236f0"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xthread_t</span></span></span><a class="headerlink" href="#c.xthread_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Handle for a single joinable thread. </p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.threadgroup_t">
<span class="target" id="thread_8h_1a0ffff81639819c366612eadbf11f4344"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">threadgroup_t</span></span></span><a class="headerlink" href="#c.threadgroup_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Handle for a group of threads which are jointly joinable. </p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.thread_function_t">
<span class="target" id="thread_8h_1ab72db9e3a087a7321761fb61d07ee88a"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">thread_function_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.thread_function_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Callback type which can be executed in another thread. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-enums">Enums</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.thread_mode_t">
<span class="target" id="thread_8h_1a6fcc8b11795017ed060af947d33971f4"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_mode_t</span></span></span><a class="headerlink" href="#c.thread_mode_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Thread mode bits enumeration. </p>
<p>Mode bits which may be passed to <a class="reference internal" href="#thread_8h_1a82227e5daa32c7b565fc0de6f6979d71"><span class="std std-ref">local_thread_mode_set_bits()</span></a> and <a class="reference internal" href="#thread_8h_1af2174a6c3984b6dd82527fbeef717228"><span class="std std-ref">local_thread_mode_clear_bits()</span></a> or to interpret the result of calling <a class="reference internal" href="#thread_8h_1a2a68459a0c9801aa6fc0403f1724fce4"><span class="std std-ref">local_thread_mode_get_bits()</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The effect of setting/clearing these bits is platform-dependent; setting/clearing a bit is not guaranteed to have any effect. </p>
</div>
<p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.thread_mode_t.thread_mode_fast">
<span class="target" id="thread_8h_1a6fcc8b11795017ed060af947d33971f4a932acc18b9ed149e213c91eee720655f"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_mode_fast</span></span></span><a class="headerlink" href="#c.thread_mode_t.thread_mode_fast" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Fast mode bit </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.thread_mode_t.thread_mode_high_priority">
<span class="target" id="thread_8h_1a6fcc8b11795017ed060af947d33971f4a77b2dd718f32a5bb22ca9c6b9977e401"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_mode_high_priority</span></span></span><a class="headerlink" href="#c.thread_mode_t.thread_mode_high_priority" title="Permalink to this definition">#</a><br /></dt>
<dd><p>High priority mode bit </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.thread_group_alloc">
<span class="target" id="thread_8h_1a1babb0f626fc6b29c9464ceac7138113"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.threadgroup_t" title="threadgroup_t"><span class="n"><span class="pre">threadgroup_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_group_alloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thread_group_alloc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Allocates a hardware thread. </p>
<p>Attempts to allocate a thread group from the pool on the current tile. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The thread group should be freed using <a class="reference internal" href="#thread_8h_1a8b4389e18db9aa04c80d41131ce065ec"><span class="std std-ref">thread_group_free()</span></a> when it is no longer required. (Or freed as a consequence of calling <a class="reference internal" href="#thread_8h_1a6c3ae132551e4d1eadd1e5d787371b55"><span class="std std-ref">thread_group_wait_and_free()</span></a>.)</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A thread group handle, or 0 if none were available. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.thread_group_add">
<span class="target" id="thread_8h_1a8b96496070759f1a8ebe8da7820847ca"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_group_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.threadgroup_t" title="threadgroup_t"><span class="n"><span class="pre">threadgroup_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__group</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.thread_function_t" title="thread_function_t"><span class="n"><span class="pre">thread_function_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__func</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__argument</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__stack_base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thread_group_add" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Add a new task to a thread group. </p>
<p>Adds a thead function invocation to a thread group allocated using <a class="reference internal" href="#thread_8h_1a1babb0f626fc6b29c9464ceac7138113"><span class="std std-ref">thread_group_alloc()</span></a>. This configures a hardware thread to execute <em>func</em> with <em>argument</em> as its sole parameter and with its stack pointer initialised to <em>stack_base</em>. <em>stack_base</em> must be word aligned and point to the last word of a block of memory sufficient to satisfy <code class="docutils literal notranslate"><span class="pre">func</span></code>’s stack requirements. That is, for a stack requirement of <code class="docutils literal notranslate"><span class="pre">s</span></code> words, <code class="docutils literal notranslate"><span class="pre">[stack_base-s*word_size,</span> <span class="pre">stack_base]</span></code> will be used as the thread’s stack and will be clobbered.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#thread_8h_1a8b96496070759f1a8ebe8da7820847ca"><span class="std std-ref">thread_group_add()</span></a> </p>
</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Execution of <em>func</em> will not begin until the group is started using <a class="reference internal" href="#thread_8h_1a5b84ac80329c74b62c0f640df1647cda"><span class="std std-ref">thread_group_start()</span></a>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__group</strong> – Thread group handle as returned by <a class="reference internal" href="#thread_8h_1a1babb0f626fc6b29c9464ceac7138113"><span class="std std-ref">thread_group_alloc()</span></a>. </p></li>
<li><p><strong>__func</strong> – Function to call in separate thread with signature <code class="docutils literal notranslate"><span class="pre">void(void*)</span></code>. </p></li>
<li><p><strong>__argument</strong> – <strong>[in]</strong> Parameter to pass to <em>func</em>. </p></li>
<li><p><strong>__stack_base</strong> – <strong>[in]</strong> Word aligned pointer to the last word of the region to use as a stack when calling <em>func</em>. Note that this can be calculated with <a class="reference internal" href="#thread_8h_1a72e2b96467f893d739d11e1cf8ac90c8"><span class="std std-ref">stack_base()</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.thread_group_try_add">
<span class="target" id="thread_8h_1ad34c540cb1fc55f276cdbd27d1ecc0c5"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">__xcore_bool_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_group_try_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.threadgroup_t" title="threadgroup_t"><span class="n"><span class="pre">threadgroup_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__group</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.thread_function_t" title="thread_function_t"><span class="n"><span class="pre">thread_function_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__func</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__argument</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__stack_base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thread_group_try_add" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Attempts to add a new task to a thread group. </p>
<p>As <a class="reference internal" href="#thread_8h_1a8b96496070759f1a8ebe8da7820847ca"><span class="std std-ref">thread_group_add()</span></a> except returns false if no threads are available. If false is returned, the thread group has not been modified and no new resources have been allocated. If the result is nonzero then the task was successfully added to the group and will be launched when the group is started.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__group</strong> – Thread group handle as returned by <a class="reference internal" href="#thread_8h_1a1babb0f626fc6b29c9464ceac7138113"><span class="std std-ref">thread_group_alloc()</span></a>. </p></li>
<li><p><strong>__func</strong> – Function to call in separate thread with signature <code class="docutils literal notranslate"><span class="pre">void(void*)</span></code>. </p></li>
<li><p><strong>__argument</strong> – <strong>[in]</strong> Parameter to pass to <em>func</em>. </p></li>
<li><p><strong>__stack_base</strong> – <strong>[in]</strong> Word aligned pointer to the last word of the region to use as a stack when calling <em>func</em>. Note that this can be calculated with <a class="reference internal" href="#thread_8h_1a72e2b96467f893d739d11e1cf8ac90c8"><span class="std std-ref">stack_base()</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.thread_group_start">
<span class="target" id="thread_8h_1a5b84ac80329c74b62c0f640df1647cda"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_group_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.threadgroup_t" title="threadgroup_t"><span class="n"><span class="pre">threadgroup_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__group</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thread_group_start" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Starts all threads in a group running. </p>
<p>Starts execution of the thread functions for each thread in the group (as added using <a class="reference internal" href="#thread_8h_1a8b96496070759f1a8ebe8da7820847ca"><span class="std std-ref">thread_group_add()</span></a>). This function will return immediately regardless of the state of the threads. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use <a class="reference internal" href="#thread_8h_1ae2a933b909446384290683f9fb825595"><span class="std std-ref">thread_group_wait()</span></a> or <a class="reference internal" href="#thread_8h_1a6c3ae132551e4d1eadd1e5d787371b55"><span class="std std-ref">thread_group_wait_and_free()</span></a> to wait for the thread group to finish.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__group</strong> – The thread group to start. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.thread_group_free">
<span class="target" id="thread_8h_1a8b4389e18db9aa04c80d41131ce065ec"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_group_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.threadgroup_t" title="threadgroup_t"><span class="n"><span class="pre">threadgroup_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__group</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thread_group_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Frees a thread group. </p>
<p>Returns the thread group to the pool so that it may be allocated again. The group handle is invalid once passed to this function so must not be re-used. <dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>This function must not be called on a thread group which has been started but not waited upon, even if its constituent threads have finished executing.</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__group</strong> – The group to free. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.thread_group_wait">
<span class="target" id="thread_8h_1ae2a933b909446384290683f9fb825595"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_group_wait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.threadgroup_t" title="threadgroup_t"><span class="n"><span class="pre">threadgroup_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__group</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thread_group_wait" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Wait for all threads in a thread group to finish. </p>
<p>The group must have been started using <a class="reference internal" href="#thread_8h_1a5b84ac80329c74b62c0f640df1647cda"><span class="std std-ref">thread_group_start()</span></a>. Calls to this function will block until all threads in the group have finished executing. Upon return of this function, the <em>group</em> remains valid but will no longer have any threads associated with it. The group may be re-used but threads must be re-added to it.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since the group remains valid, it should be freed with <a class="reference internal" href="#thread_8h_1a8b4389e18db9aa04c80d41131ce065ec"><span class="std std-ref">thread_group_free()</span></a> if no longer required.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__group</strong> – The group to wait for completion. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.thread_group_wait_and_free">
<span class="target" id="thread_8h_1a6c3ae132551e4d1eadd1e5d787371b55"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thread_group_wait_and_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.threadgroup_t" title="threadgroup_t"><span class="n"><span class="pre">threadgroup_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__group</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thread_group_wait_and_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Waits for a thread group to finish then frees it. </p>
<p>Helper to both wait for and free a thread group. The group must have been started using <a class="reference internal" href="#thread_8h_1a5b84ac80329c74b62c0f640df1647cda"><span class="std std-ref">thread_group_start()</span></a> and the group will be invalid once this function returns.</p>
<p><strong>Calls</strong> <ul class="simple">
<li><p><a class="reference internal" href="#thread_8h_1ae2a933b909446384290683f9fb825595"><span class="std std-ref">thread_group_wait()</span></a> </p></li>
<li><p><a class="reference internal" href="#thread_8h_1a8b4389e18db9aa04c80d41131ce065ec"><span class="std std-ref">thread_group_free()</span></a> </p></li>
</ul>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.xthread_alloc_and_start">
<span class="target" id="thread_8h_1a07e55a1c961156f17ee88282cd8df320"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.xthread_t" title="xthread_t"><span class="n"><span class="pre">xthread_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xthread_alloc_and_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.thread_function_t" title="thread_function_t"><span class="n"><span class="pre">thread_function_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__func</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__argument</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__stack_base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xthread_alloc_and_start" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Runs a function in another thread and returns a waitable handle. </p>
<p>Starts executing <em>func</em> in a separate hardware thread with <em>argument</em> as its sole parameter and with its stack pointer initialised to <em>stack_base</em>. <em>stack_base</em> must be word aligned and point to the last word of a block of memory sufficient to satisfy <code class="docutils literal notranslate"><span class="pre">func</span></code>’s stack requirements. That is, for a stack requirement of <code class="docutils literal notranslate"><span class="pre">s</span></code> words, <code class="docutils literal notranslate"><span class="pre">[stack_base-s*word_size,</span> <span class="pre">stack_base]</span></code> will be used as the thread’s stack and will be clobbered.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The thread will begin execution immediately and this function will return. The thread will not be returned to the pool upon completion - it is necessary to call <a class="reference internal" href="#thread_8h_1a4811a9bb400ff957fa9a0fdf89f2930c"><span class="std std-ref">xthread_wait_and_free()</span></a> to free the thread so that it may be reused.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__func</strong> – Function to call in separate thread with signature <code class="docutils literal notranslate"><span class="pre">void(void*)</span></code>. </p></li>
<li><p><strong>__argument</strong> – <strong>[in]</strong> Parameter to pass to <em>func</em>. </p></li>
<li><p><strong>__stack_base</strong> – <strong>[in]</strong> Word aligned pointer to the last word of the region to use as a stack when calling <em>func</em>. Note that this can be calculated with <a class="reference internal" href="#thread_8h_1a72e2b96467f893d739d11e1cf8ac90c8"><span class="std std-ref">stack_base()</span></a>. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A waitable handle for the hardware thread, or zero if the thread resource could not be allocated. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.xthread_wait_and_free">
<span class="target" id="thread_8h_1a4811a9bb400ff957fa9a0fdf89f2930c"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xthread_wait_and_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.xthread_t" title="xthread_t"><span class="n"><span class="pre">xthread_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__xthread</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xthread_wait_and_free" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Wait for a thread to finish and then free it. </p>
<p><em>thread</em> must have been allocated and started using <a class="reference internal" href="#thread_8h_1a07e55a1c961156f17ee88282cd8df320"><span class="std std-ref">xthread_alloc_and_start()</span></a>. Calls to this function will block until the function called by <em>thread</em> has returned and upon completion it will free the associated hardware thread. <em>thread</em> must not be re-used after it has been freed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__xthread</strong> – The thread to wait on, as returned by <a class="reference internal" href="#thread_8h_1a07e55a1c961156f17ee88282cd8df320"><span class="std std-ref">xthread_alloc_and_start()</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.run_async">
<span class="target" id="thread_8h_1a20fe5be459883128851645523217966d"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">run_async</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.thread_function_t" title="thread_function_t"><span class="n"><span class="pre">thread_function_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__func</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__argument</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__stack_base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.run_async" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Runs a function in another hardware thread. </p>
<p>Starts executing <em>func</em> in a separate hardware thread with <em>argument</em> as its sole parameter and with its stack pointer initialised to <em>stack_base</em>. <em>stack_base</em> must be word aligned and point to the last word of a block of memory sufficient to satisfy <code class="docutils literal notranslate"><span class="pre">func</span></code>’s stack requirements. That is, for a stack requirement of <code class="docutils literal notranslate"><span class="pre">s</span></code> words, <code class="docutils literal notranslate"><span class="pre">[stack_base-s*word_size,</span> <span class="pre">stack_base]</span></code> will be used as the thread’s stack and will be clobbered.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The associated hardware thread will be freed once <em>func</em> returns, but it is not trivially possible to determine wether or not this has happened from the calling thread. If it necessary to wait for the completion of <em>func</em> then <a class="reference internal" href="#thread_8h_1a07e55a1c961156f17ee88282cd8df320"><span class="std std-ref">xthread_alloc_and_start()</span></a> and <a class="reference internal" href="#thread_8h_1a4811a9bb400ff957fa9a0fdf89f2930c"><span class="std std-ref">xthread_wait_and_free()</span></a> should be used instead.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__func</strong> – Function to call in separate thread with signature <code class="docutils literal notranslate"><span class="pre">void(void*)</span></code>. </p></li>
<li><p><strong>__argument</strong> – <strong>[in]</strong> Parameter to pass to <em>func</em>. </p></li>
<li><p><strong>__stack_base</strong> – <strong>[in]</strong> Word aligned pointer to the last word of the region to use as a stack when calling <em>func</em>. Note that this can be calculated with <a class="reference internal" href="#thread_8h_1a72e2b96467f893d739d11e1cf8ac90c8"><span class="std std-ref">stack_base()</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.stack_base">
<span class="target" id="thread_8h_1a72e2b96467f893d739d11e1cf8ac90c8"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">stack_base</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__mem_base</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">__words</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.stack_base" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Returns a stack pointer suitable for use as a <code class="docutils literal notranslate"><span class="pre">stack_base</span></code> argument given a base address and a size. </p>
<p>Given a base pointer (e.g. as returned by malloc or found by taking the address of an object) and the size of the intended stack in words, returns a stack base pointer to the last word of the stack - which is suitable for passing to the <code class="docutils literal notranslate"><span class="pre">stack_base</span></code> arguments of <a class="reference internal" href="#thread_8h_1a07e55a1c961156f17ee88282cd8df320"><span class="std std-ref">xthread_alloc_and_start()</span></a>, <a class="reference internal" href="#thread_8h_1a20fe5be459883128851645523217966d"><span class="std std-ref">run_async()</span></a> and <a class="reference internal" href="#thread_8h_1a8b96496070759f1a8ebe8da7820847ca"><span class="std std-ref">thread_group_add()</span></a>. The given base address must be suitably aligned as the resulting stack pointer is required to be aligned also. The alignment requirement is a multiple of the word size and is target dependent. The resulting pointer will be a valid stack pointer for a stack <code class="docutils literal notranslate"><span class="pre">words</span></code> words in size. If used as a stack pointer for a function with a stack requirement no greater than <code class="docutils literal notranslate"><span class="pre">words</span></code> words then the memory region used as a stack by that function will not be beyond <code class="docutils literal notranslate"><span class="pre">[mem_base,</span> <span class="pre">(char</span> <span class="pre">*)mem_base</span> <span class="pre">+</span> <span class="pre">words*WORD_SIZE)</span></code> in either direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__mem_base</strong> – <strong>[in]</strong> The base (lowest) address of the object/region to use as a stack. Must be word aligned. </p></li>
<li><p><strong>__words</strong> – Size of the stack the returned pointed will return to in words </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The stack pointer. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.local_thread_mode_set_bits">
<span class="target" id="thread_8h_1a82227e5daa32c7b565fc0de6f6979d71"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">local_thread_mode_set_bits</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.thread_mode_t" title="thread_mode_t"><span class="n"><span class="pre">thread_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.local_thread_mode_set_bits" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set mode bits for the current thread. </p>
<p>Sets platform-dependent mode bits for the calling thread given a mask of bits to set. The mode bits passed must be a value from thread_mode_t or the bitwise disjunuction of two or more such values. The actual effect of setting mode bits varies by target; no bit is guaranteed to have any particular effect or any effect whatsoever. This function can only set bits - using a mode value with a bit unset will not clear that bit in the local thread mode. Instead, <a class="reference internal" href="#thread_8h_1af2174a6c3984b6dd82527fbeef717228"><span class="std std-ref">local_thread_mode_clear_bits()</span></a> must be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__mode</strong> – Mask of bits to set </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.local_thread_mode_get_bits">
<span class="target" id="thread_8h_1a2a68459a0c9801aa6fc0403f1724fce4"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#c.thread_mode_t" title="thread_mode_t"><span class="n"><span class="pre">thread_mode_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">local_thread_mode_get_bits</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.local_thread_mode_get_bits" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Get the current thread’s mode bits. </p>
<p>Gets the platform-dependent mode bits for the current thread. The value returned will be the bitwise disjunction of zero or more values from thread_mode_t, and those members may be used as masks to interpret the result of this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The calling thread’s mode bits </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.local_thread_mode_clear_bits">
<span class="target" id="thread_8h_1af2174a6c3984b6dd82527fbeef717228"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">local_thread_mode_clear_bits</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.thread_mode_t" title="thread_mode_t"><span class="n"><span class="pre">thread_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.local_thread_mode_clear_bits" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Clear bits in the current thread’s mode. </p>
<p>Given a mask, clear any bits which are set in that mask in the current thread’s mode. The mask must be a value from thread_mode_t or the bitwise disjunction of two or more such values. This can be used to unset bits which were set using <a class="reference internal" href="#thread_8h_1a82227e5daa32c7b565fc0de6f6979d71"><span class="std std-ref">local_thread_mode_set_bits()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__mode</strong> – The mask of bits to clear </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</section>
<section id="xcore-triggerable-h">
<h3>xcore/triggerable.h<a class="headerlink" href="#xcore-triggerable-h" title="Permalink to this heading">#</a></h3>
<p>Functions applicable to Chanends, Ports and Timers for configuring events and interrupts. </p>
<p>Low level API for handling events and interrupts. It is generally recommended to use the SELECT API instead.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><ul class="simple">
<li><p>xcore/select.h </p></li>
<li><p>xcore/interrupt.h </p></li>
</ul>
</p>
</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A resource may only be configured for interrupts <strong>or</strong> events at a given time. Configuring interrupts for a resource may overwrite any event configuration and configuring events may overwrite any interrupt configurataion. A trigger controls the condition for both interrups and for events (whichever is enabled for the resource).</p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.TRIGGERABLE_EV_BASE">
<span class="target" id="triggerable_8h_1a0a0f52bd1477d82cc0e320d760a487ee"></span><span class="sig-name descname"><span class="n"><span class="pre">TRIGGERABLE_EV_BASE</span></span></span><a class="headerlink" href="#c.TRIGGERABLE_EV_BASE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Minimum event vector value. </p>
<p>Interrupt values passed as iunterrupt data must be no less than this value. On targets where this is nonzero, the value must be in the range: [ <code class="docutils literal notranslate"><span class="pre">TRIGGERABLE_EV_BASE</span></code>, <code class="docutils literal notranslate"><span class="pre">2*TRIGGERABLE_EV_BASE</span></code> ) </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.TRIGGERABLE_SETUP_EVENT_VECTOR">
<span class="target" id="triggerable_8h_1a4b33d4a716306563be546a97562ade65"></span><span class="sig-name descname"><span class="n"><span class="pre">TRIGGERABLE_SETUP_EVENT_VECTOR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__resource</span></span>, <span class="n"><span class="pre">__label</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.TRIGGERABLE_SETUP_EVENT_VECTOR" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Configure the vector which handles events on a given resource. </p>
<p>Expands to a statement which configures the event vector for the given <em>resource</em> such that handling an event on that resource causes control to transfer to the given <em>label</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This will overwrite any interrupt vector which has been set on the resource.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__resource</strong> – The resource to configure </p></li>
<li><p><strong>__label</strong> – The label to jump to when an event is handled on <em>resource</em> </p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid chanend, port or timer </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the resource. </p>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.TRIGGERABLE_WAIT_EVENT">
<span class="target" id="triggerable_8h_1a976dabd12f8a920e2ca0514b39c17aa1"></span><span class="sig-name descname"><span class="n"><span class="pre">TRIGGERABLE_WAIT_EVENT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__labels...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.TRIGGERABLE_WAIT_EVENT" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Wait for a configured and enabled event to occur. </p>
<p>Expands to a statements which waits for a configured event to occur and jumps to its event vector. Note that any possible event vector which may be jumped to (i.e. the labels configured as event vectors on all resources where events are enabled and an event may occur) must be passed as arguments otherwise the effect is undefined. Passing labels which cannot be reached by an enabled event may be ill formed if jumping to that label would be ill formed and may result in sub-optimal performance.</p>
<p>For a resource to raise an event: <ul class="simple">
<li><p>Its trigger must be enabled with <a class="reference internal" href="#triggerable_8h_1ace9753589aad145073361ea3700dc147"><span class="std std-ref">triggerable_enable_trigger()</span></a> or <a class="reference internal" href="#triggerable_8h_1a7e3e3207a30e9e93ec8ac7924178f4bc"><span class="std std-ref">triggerable_set_trigger_enabled()</span></a> </p></li>
<li><p>Its trigger must occur; for a chanend this happens when data is available to be read, for ports and timers this will depend on the trigger which has been configured using the respective API. If at the point an event occurs the event vector has not been configured using <a class="reference internal" href="#triggerable_8h_1a4b33d4a716306563be546a97562ade65"><span class="std std-ref">TRIGGERABLE_SETUP_EVENT_VECTOR()</span></a> then handling the event will have undefined behaviour.</p></li>
</ul>
<dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>The expansion of this macro will block until the trigger occurs on a resource where events are enabled. If no events are enabled then this can never complete.</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__labels</strong> – The labels configured as event vectors for all events which may occur. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.TRIGGERABLE_TAKE_EVENT">
<span class="target" id="triggerable_8h_1a3d70e5671851472427a8331733abac36"></span><span class="sig-name descname"><span class="n"><span class="pre">TRIGGERABLE_TAKE_EVENT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__labels...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.TRIGGERABLE_TAKE_EVENT" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Jump to an event vector if an event is ready. </p>
<p>Has the same effect as <a class="reference internal" href="#triggerable_8h_1a976dabd12f8a920e2ca0514b39c17aa1"><span class="std std-ref">TRIGGERABLE_WAIT_EVENT()</span></a> except that if no event is waiting then this expansion does not block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__labels</strong> – Labels which may be jumped to if an event is ready </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.interrupt_callback_t">
<span class="target" id="triggerable_8h_1a6aa1b529587d112da0559c8a10eddb09"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">__xcore_interrupt_callback_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">interrupt_callback_t</span></span></span><a class="headerlink" href="#c.interrupt_callback_t" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Interrupt handler type. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.triggerable_setup_interrupt_callback">
<span class="target" id="triggerable_8h_1a647be9afa8b1cf81eeaa3f35067c6d84"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">triggerable_setup_interrupt_callback</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__res</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__data</span></span>, <a class="reference internal" href="#c.interrupt_callback_t" title="interrupt_callback_t"><span class="n"><span class="pre">interrupt_callback_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">__func</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.triggerable_setup_interrupt_callback" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Setup interrupt event on a resource. </p>
<p>Once the interrupts is setup you need to call port_enable_trigger() to enable it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__res</strong> – The resource to setup the interrupt event on.</p></li>
<li><p><strong>__data</strong> – <strong>[in]</strong> The value to be passed to the interrupt_callback_t function On XS1 bit 16 must be set (see TRIGGERABLE_EV_BASE) </p></li>
<li><p><strong>__func</strong> – The interrupt_callback_t function to handle events</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid chanend, port or timer </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the resource. </p>
</dd>
<dt class="field-even">Throws ET_ECALL<span class="colon">:</span></dt>
<dd class="field-even"><p>when xassert enabled, on XS1 bit 16 not set in data. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.triggerable_enable_trigger">
<span class="target" id="triggerable_8h_1ace9753589aad145073361ea3700dc147"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">triggerable_enable_trigger</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.triggerable_enable_trigger" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Enable the trigger for a given resource. </p>
<p>This will allow the resource the generate events or interrupts when its trigger occurs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__res</strong> – Resource to enable the trigger of</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid chanend, port or timer </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the resource. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.triggerable_disable_trigger">
<span class="target" id="triggerable_8h_1ad6dd4765ad22bc2583b33f43087a9538"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">triggerable_disable_trigger</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.triggerable_disable_trigger" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Disable the trigger for a given resource. </p>
<p>This prevents the resource generating events or interrupts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__res</strong> – Resource to disable the trigger of</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid chanend, port or timer </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the resource. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.triggerable_set_trigger_enabled">
<span class="target" id="triggerable_8h_1a7e3e3207a30e9e93ec8ac7924178f4bc"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">triggerable_set_trigger_enabled</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_t</span></span><span class="w"> </span><span class="n"><span class="pre">__res</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">__enabled</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.triggerable_set_trigger_enabled" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Set the trigger enabled or disabled on a given resource. </p>
<p>Has the same effect as calling <a class="reference internal" href="#triggerable_8h_1ace9753589aad145073361ea3700dc147"><span class="std std-ref">triggerable_enable_trigger()</span></a> or <a class="reference internal" href="#triggerable_8h_1ad6dd4765ad22bc2583b33f43087a9538"><span class="std std-ref">triggerable_disable_trigger()</span></a> depending on the value of <em>enabled</em>. However, this may perform better when the value of enabled is not statically known.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>__res</strong> – The resource to enaable or disable the trigger of </p></li>
<li><p><strong>__enabled</strong> – State to set on the trigger - if true it is enabled, otherwise it is disabled</p></li>
</ul>
</dd>
<dt class="field-even">Throws ET_ILLEGAL_RESOURCE<span class="colon">:</span></dt>
<dd class="field-even"><p>not a valid chanend, port or timer </p>
</dd>
<dt class="field-odd">Throws ET_RESOURCE_DEP<span class="colon">:</span></dt>
<dd class="field-odd"><p>another core is actively using the resource. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.triggerable_disable_all">
<span class="target" id="triggerable_8h_1a339fa70117df2c5be0ec072cf96dd279"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">triggerable_disable_all</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.triggerable_disable_all" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Disables all triggers in the current thread and masks interrupts. </p>
<p>Disables the triggers on all resources in use by the current thread and disabled interrupts as if with <a class="reference internal" href="#interrupt_8h_1a4161fa33e544eb474f81f1374bde73db"><span class="std std-ref">interrupt_mask_all()</span></a>. </p>
</dd></dl>

</div>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../libxs1/lib-xs1-api.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">lib_xs1</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Libraries</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, XMOS Ltd
            </div>
            Made with 
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Jul 24, 2024</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">lib_xcore</a><ul>
<li><a class="reference internal" href="#api-details">API details</a><ul>
<li><a class="reference internal" href="#xcore-assert-h">xcore/assert.h</a></li>
<li><a class="reference internal" href="#xcore-chanend-h">xcore/chanend.h</a></li>
<li><a class="reference internal" href="#xcore-channel-streaming-h">xcore/channel_streaming.h</a></li>
<li><a class="reference internal" href="#xcore-channel-transaction-h">xcore/channel_transaction.h</a></li>
<li><a class="reference internal" href="#xcore-channel-h">xcore/channel.h</a></li>
<li><a class="reference internal" href="#xcore-clock-h">xcore/clock.h</a></li>
<li><a class="reference internal" href="#xcore-hwtimer-h">xcore/hwtimer.h</a></li>
<li><a class="reference internal" href="#xcore-interrupt-wrappers-h">xcore/interrupt_wrappers.h</a></li>
<li><a class="reference internal" href="#xcore-interrupt-h">xcore/interrupt.h</a></li>
<li><a class="reference internal" href="#xcore-lock-h">xcore/lock.h</a></li>
<li><a class="reference internal" href="#xcore-minicache-h">xcore/minicache.h</a></li>
<li><a class="reference internal" href="#xcore-parallel-h">xcore/parallel.h</a></li>
<li><a class="reference internal" href="#xcore-port-protocol-h">xcore/port_protocol.h</a></li>
<li><a class="reference internal" href="#xcore-port-h">xcore/port.h</a></li>
<li><a class="reference internal" href="#xcore-select-h">xcore/select.h</a></li>
<li><a class="reference internal" href="#xcore-swmem-evict-h">xcore/swmem_evict.h</a></li>
<li><a class="reference internal" href="#xcore-swmem-fill-h">xcore/swmem_fill.h</a></li>
<li><a class="reference internal" href="#xcore-thread-h">xcore/thread.h</a></li>
<li><a class="reference internal" href="#xcore-triggerable-h">xcore/triggerable.h</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/scripts/furo.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/tabs.js"></script>
    </body>
</html>