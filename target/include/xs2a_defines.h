/*
 *
 * Copyright XMOS Limited - (c) 2005-2022
 *
 * AUTOGENERATED - DO NOT EDIT
 * tools_xmosutils/DefinesGeneration/HashDefinesGenerator.cpp
 *
 */
/**
 * @file 
 */

#ifndef _xs2a_defines_H_
#define _xs2a_defines_H_

/**
 * \defgroup xs2aPSRegisters xs2a PS Registers
 * @{
 */
/**
 * PS_RAM_BASE processor state register ID.
 * Use getps() and setps() to access.
 * 
 * This register contains the base address of the RAM. It is initialized to 0x00040000.
 * 
 * Sub-Fields:
 * 
 * \ref WORD_ADDRESS_BITS Most significant 16 bits of all addresses.
 * 
 */
#define XS1_PS_RAM_BASE 0xb
/**
 * PS_VECTOR_BASE processor state register ID.
 * Use getps() and setps() to access.
 * 
 * Base address of event vectors in each resource. On an interrupt or event, the 16 most significant bits of the destination address are provided by this register; the least significant 16 bits come from the event vector.
 * 
 * Sub-Fields:
 * 
 * \ref VECTOR_BASE The event and interrupt vectors.
 * 
 */
#define XS1_PS_VECTOR_BASE 0x10b
/**
 * PS_XCORE_CTRL0 processor state register ID.
 * Use getps() and setps() to access.
 * 
 * Register to control features in the xCORE tile
 * 
 * Sub-Fields:
 * 
 * \ref XCORE_CTRL0_USB_ENABLE Enable the ULPI Hardware support module
 * 
 * \ref XCORE_CTRL0_USB_MODE Select between UTMI (1) and ULPI (0) mode.
 * 
 * \ref XCORE_CTRL0_CLK_DIVIDER_EN Enable the clock divider.  This divides the output of the PLL to facilitate one of the low power modes.
 * 
 * \ref XCORE_CTRL0_CLK_DIVIDER_DYN Select the dynamic mode (1) for the clock divider when the clock divider is enabled.  In dynamic mode the clock divider is only activated when all active threads are paused.  In static mode the clock divider is always enabled.
 * 
 * \ref XCORE_CTRL0_RGMII_ENABLE Enable RGMII interface periph ports
 * 
 * \ref XCORE_CTRL0_RGMII_DIVIDE RGMII TX clock divider value. TX clk rises when counter (clocked by PLL output) reaches this value and falls when counter reaches (value>>1). Value programmed into this field should be actual divide value required minus 1
 * 
 * \ref XCORE_CTRL0_RGMII_DELAY RGMII TX data delay value (in PLL output cycle increments)   
 * 
 */
#define XS1_PS_XCORE_CTRL0 0x20b
/**
 * PS_BOOT_CONFIG processor state register ID.
 * Use getps() to access.
 * 
 * This read-only register describes the boot status of the xCORE tile.
 * 
 * Sub-Fields:
 * 
 * \ref BOOT_CONFIG_PLL_MODE_PINS The boot PLL mode pin value.
 * 
 * \ref BOOT_CONFIG_BOOT_FROM_JTAG Boot ROM boots from JTAG 
 * 
 * \ref BOOT_CONFIG_BOOT_FROM_RAM Boot ROM boots from RAM 
 * 
 * \ref BOOT_CONFIG_DISABLE_OTP_POLL Cause the ROM to not poll the OTP for correct read levels
 * 
 * \ref BOOT_CONFIG_CORE1_POWER_DOWN_N Indicates if core1 has been powered off 
 * 
 * \ref BOOT_CONFIG_SECURE_BOOT Overwrite BOOT_MODE.
 * 
 * \ref BOOT_CONFIG_PROCESSOR Processor number.
 * 
 */
#define XS1_PS_BOOT_CONFIG 0x30b
/**
 * PS_BOOT_STATUS processor state register ID.
 * Use getps() and setps() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref BOOT_STATUS_LEDS Boot status LED value.
 * 
 * \ref BOOT_STATUS_BITS Other boot status LED bits.
 * 
 */
#define XS1_PS_BOOT_STATUS 0x40b
/**
 * PS_SECURITY_CONFIG processor state register ID.
 * Use getps() and setps() to access.
 * 
 * Copy of the security register as read from OTP.
 * 
 * Sub-Fields:
 * 
 * \ref SECUR_CFG_DISABLE_XCORE_JTAG Disable access to XCore's JTAG debug TAP 
 * 
 * \ref SECUR_CFG_DISABLE_PLL_JTAG Disable JTAG access to the PLL/BOOT configuration registers 
 * 
 * \ref SECUR_CFG_SECURE_BOOT Override boot mode and read boot image from OTP 
 * 
 * \ref SECUR_CFG_OTP_REDUANACY_ENABLE Enable OTP reduanacy 
 * 
 * \ref SECUR_CFG_OTP_SECTOR_LOCK lock bit for each OTP sector 
 * 
 * \ref SECUR_CFG_OTP_MASTER_LOCK lock all OTP sectors 
 * 
 * \ref SECUR_CFG_DISABLE_GLOBAL_DEBUG Disable access to XCore's global debug 
 * 
 * \ref SECUR_CFG_DISABLE_ACCESS Disables write permission on this register 
 * 
 */
#define XS1_PS_SECURITY_CONFIG 0x50b
/**
 * PS_RING_OSC_CTRL processor state register ID.
 * Use getps() and setps() to access.
 * 
 * There are four free-running oscillators that clock
 *       four counters. The oscillators can be started and stopped using this
 *       register. The counters should only be read when the ring oscillator
 *       has been stopped for at least 10 core clock cycles (this can be
 *       achieved by inserting two nop instructions between the SETPS and GETPS).
 *       The counter values can be read using four subsequent
 *       registers. The ring oscillators are asynchronous to the xCORE tile clock
 *       and can be used as a source of random bits.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_PERPH_ENABLE Peripheral ring oscillator enable.
 * 
 * \ref RING_OSC_CORE_ENABLE Core ring oscillator enable.
 * 
 */
#define XS1_PS_RING_OSC_CTRL 0x60b
/**
 * PS_RING_OSC_DATA0 processor state register ID.
 * Use getps() to access.
 * 
 * This register contains the current count of the xCORE Tile Cell ring oscillator. This value is not reset on a system reset.
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_DATA Ring oscillator Counter data.
 * 
 */
#define XS1_PS_RING_OSC_DATA0 0x70b
/**
 * PS_RING_OSC_DATA1 processor state register ID.
 * Use getps() to access.
 * 
 * This register contains the current count of the xCORE Tile Wire ring oscillator. This value is not reset on a system reset.
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_DATA Ring oscillator Counter data.
 * 
 */
#define XS1_PS_RING_OSC_DATA1 0x80b
/**
 * PS_RING_OSC_DATA2 processor state register ID.
 * Use getps() to access.
 * 
 * This register contains the current count of the Peripheral Cell ring oscillator. This value is not reset on a system reset.
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_DATA Ring oscillator Counter data.
 * 
 */
#define XS1_PS_RING_OSC_DATA2 0x90b
/**
 * PS_RING_OSC_DATA3 processor state register ID.
 * Use getps() to access.
 * 
 * This register contains the current count of the Peripheral Wire ring oscillator. This value is not reset on a system reset.
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_DATA Ring oscillator Counter data.
 * 
 */
#define XS1_PS_RING_OSC_DATA3 0xa0b
/**
 * PS_UNAVAILABLE_RESOURCE processor state register ID.
 * Use getps() and setps() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref RAM_MASK Blocks of 64k rams unavailable
 * 
 * \ref THREAD_MASK Threads unavailable
 * 
 * \ref RGMII_DISABLE RGMII accelerator disable 
 * 
 */
#define XS1_PS_UNAVAILABLE_RESOURCE 0xb0b
/**
 * PS_RAM_SIZE processor state register ID.
 * Use getps() to access.
 * 
 * The size of the RAM in bytes
 * 
 * Sub-Fields:
 * 
 * \ref WORD_ADDRESS_BITS Most significant 16 bits of all addresses.
 * 
 */
#define XS1_PS_RAM_SIZE 0xc0b
/**
 * PS_RAM_RMA processor state register ID.
 * Use getps() and setps() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref RMA0 Read margin adjust.
 * 
 * \ref RMA1 Read margin adjust.
 * 
 * \ref RMA2 Read margin adjust.
 * 
 * \ref RMA3 Read margin adjust.
 * 
 */
#define XS1_PS_RAM_RMA 0xe0b
/**
 * PS_ROM_RMA processor state register ID.
 * Use getps() and setps() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref RMA0 Read margin adjust.
 * 
 * \ref RMA1 Read margin adjust.
 * 
 * \ref RMA2 Read margin adjust.
 * 
 * \ref RMA3 Read margin adjust.
 * 
 */
#define XS1_PS_ROM_RMA 0xf0b
/**
 * PS_DBG_SSR processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * This register contains the value of the SSR register when the debugger was called.
 * 
 * Sub-Fields:
 * 
 * \ref SR_EEBLE When 1 events are enabled for the thread.
 * 
 * \ref SR_IEBLE When 1 interrupts are enabled for the thread.
 * 
 * \ref SR_INENB 1 when in an event enabling sequence.
 * 
 * \ref SR_ININT 1 when in an interrupt handler.
 * 
 * \ref SR_INK 1 when in kernel mode.
 * 
 * \ref SR_WAITING When 1 the thread is paused waiting for events, a lock or another resource.
 * 
 * \ref SR_FAST When 1 the thread is in fast mode and will continually issue.
 * 
 * \ref SR_DI Determines the issue mode (DI bit).
 * 
 * \ref SR_KEDI Determines the issue mode (DI bit) upon Kernel Entry after Exception or Interrupt.
 * 
 * \ref SR_QUEUE Address space indentifier
 * 
 */
#define XS1_PS_DBG_SSR 0x100b
/**
 * PS_DBG_SPC processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * This register contains the value of the SPC register when the debugger was called.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PS_DBG_SPC 0x110b
/**
 * PS_DBG_SSP processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * This register contains the value of the SSP register when the debugger was called.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PS_DBG_SSP 0x120b
/**
 * PS_DBG_T_NUM processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * The resource ID of the logical core whose state is to be read.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_T_NUM_NUM Thread number to be read
 * 
 */
#define XS1_PS_DBG_T_NUM 0x130b
/**
 * PS_DBG_T_REG processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * Register number to be read by DGETREG
 * 
 * Sub-Fields:
 * 
 * \ref DBG_T_REG_REG Register number to be read
 * 
 */
#define XS1_PS_DBG_T_REG 0x140b
/**
 * PS_DBG_TYPE processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * Register that specifies what activated the debug interrupt.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_TYPE_CAUSE Indicates the cause of the debug interrupt
 * 
 * 1: Host initiated a debug interrupt through JTAG
 * 
 * 2: Program executed a DCALL instruction
 * 
 * 3: Instruction breakpoint
 * 
 * 4: Data watch point
 * 
 * 5: Resource watch point
 * 
 * 
 * \ref DBG_TYPE_T_NUM Number of thread which caused the debug interrupt (always 0 in the case of =HOST=).
 * 
 * \ref DBG_TYPE_HW_NUM Number of the hardware breakpoint/watchpoint which caused the interrupt (always 0 for =HOST= and =DCALL=). If multiple breakpoints/watchpoints trigger at once, the lowest number is taken.
 * 
 */
#define XS1_PS_DBG_TYPE 0x150b
/**
 * PS_DBG_DATA processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * On a data watchpoint, this register contains 
 *       the effective address of the memory operation that triggered 
 *       the debugger. On a resource watchpoint, it countains the resource
 *       identifier.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PS_DBG_DATA 0x160b
/**
 * PS_DBG_RUN_CTRL processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * This register enables the debugger to temporarily disable logical cores. When returning from the debug interrupts, the cores set in this register will not execute. This enables single stepping to be implemented.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_RUN_CTRL_STOP 1-hot vector defining which threads are stopped when not in debug mode. Every bit which is set prevents the respective thread from running.
 * 
 */
#define XS1_PS_DBG_RUN_CTRL 0x180b
/**
 * \name PS_DBG_SCRATCH
 * \anchor PS_DBG_SCRATCH
 * A set of registers used by the debug ROM to communicate with an external debugger, for example over JTAG. This is the same set of registers as the Debug Scratch registers in the xCORE tile configuration.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_SCRATCH 0x8
/**
 * \ref PS_DBG_SCRATCH 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_0 0x200b
/**
 * \ref PS_DBG_SCRATCH 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_1 0x210b
/**
 * \ref PS_DBG_SCRATCH 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_2 0x220b
/**
 * \ref PS_DBG_SCRATCH 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_3 0x230b
/**
 * \ref PS_DBG_SCRATCH 4 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_4 0x240b
/**
 * \ref PS_DBG_SCRATCH 5 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_5 0x250b
/**
 * \ref PS_DBG_SCRATCH 6 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_6 0x260b
/**
 * \ref PS_DBG_SCRATCH 7 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_7 0x270b
///@}
/**
 * \name PS_DBG_IBREAK_ADDR
 * \anchor PS_DBG_IBREAK_ADDR
 * This register contains the address of the instruction breakpoint. If the PC matches this address, then a debug interrupt will be taken. There are four instruction breakpoints that are controlled individually.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_IBREAK_ADDR 0x4
/**
 * \ref PS_DBG_IBREAK_ADDR 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_ADDR_0 0x300b
/**
 * \ref PS_DBG_IBREAK_ADDR 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_ADDR_1 0x310b
/**
 * \ref PS_DBG_IBREAK_ADDR 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_ADDR_2 0x320b
/**
 * \ref PS_DBG_IBREAK_ADDR 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_ADDR_3 0x330b
///@}
/**
 * \name PS_DBG_IBREAK_CTRL
 * \anchor PS_DBG_IBREAK_CTRL
 * This register controls which logical cores may take an instruction breakpoint, and under which condition.
 * 
 * Sub-Fields:
 * 
 * \ref BRK_ENABLE When 1 the instruction breakpoint is enabled.
 * 
 * \ref IBRK_CONDITION When 0 break when PC == IBREAK_ADDR. When 1 = break when PC != IBREAK_ADDR.
 * 
 * \ref BRK_THREADS A bit for each thread in the machine allowing the breakpoint to be enabled individually for each thread.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_IBREAK_CTRL 0x4
/**
 * \ref PS_DBG_IBREAK_CTRL 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_CTRL_0 0x400b
/**
 * \ref PS_DBG_IBREAK_CTRL 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_CTRL_1 0x410b
/**
 * \ref PS_DBG_IBREAK_CTRL 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_CTRL_2 0x420b
/**
 * \ref PS_DBG_IBREAK_CTRL 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_CTRL_3 0x430b
///@}
/**
 * \name PS_DBG_DWATCH_ADDR1
 * \anchor PS_DBG_DWATCH_ADDR1
 * This set of registers contains the first address for the four data watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_DWATCH_ADDR1 0x4
/**
 * \ref PS_DBG_DWATCH_ADDR1 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR1_0 0x500b
/**
 * \ref PS_DBG_DWATCH_ADDR1 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR1_1 0x510b
/**
 * \ref PS_DBG_DWATCH_ADDR1 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR1_2 0x520b
/**
 * \ref PS_DBG_DWATCH_ADDR1 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR1_3 0x530b
///@}
/**
 * \name PS_DBG_DWATCH_ADDR2
 * \anchor PS_DBG_DWATCH_ADDR2
 * This set of registers contains the second address for the four data watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_DWATCH_ADDR2 0x4
/**
 * \ref PS_DBG_DWATCH_ADDR2 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR2_0 0x600b
/**
 * \ref PS_DBG_DWATCH_ADDR2 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR2_1 0x610b
/**
 * \ref PS_DBG_DWATCH_ADDR2 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR2_2 0x620b
/**
 * \ref PS_DBG_DWATCH_ADDR2 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR2_3 0x630b
///@}
/**
 * \name PS_DBG_DWATCH_CTRL
 * \anchor PS_DBG_DWATCH_CTRL
 * This set of registers controls each of the four data watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref BRK_ENABLE When 1 the instruction breakpoint is enabled.
 * 
 * \ref DBRK_CONDITION Determines the break condition: 0 = A AND B, 1 = A OR B.
 * 
 * \ref BRK_LOAD When 1 the breakpoints will be be triggered on loads.
 * 
 * \ref BRK_THREADS A bit for each thread in the machine allowing the breakpoint to be enabled individually for each thread.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_DWATCH_CTRL 0x4
/**
 * \ref PS_DBG_DWATCH_CTRL 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_CTRL_0 0x700b
/**
 * \ref PS_DBG_DWATCH_CTRL 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_CTRL_1 0x710b
/**
 * \ref PS_DBG_DWATCH_CTRL 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_CTRL_2 0x720b
/**
 * \ref PS_DBG_DWATCH_CTRL 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_CTRL_3 0x730b
///@}
/**
 * \name PS_DBG_RWATCH_ADDR1
 * \anchor PS_DBG_RWATCH_ADDR1
 * This set of registers contains the mask for the four resource watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_RWATCH_ADDR1 0x4
/**
 * \ref PS_DBG_RWATCH_ADDR1 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR1_0 0x800b
/**
 * \ref PS_DBG_RWATCH_ADDR1 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR1_1 0x810b
/**
 * \ref PS_DBG_RWATCH_ADDR1 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR1_2 0x820b
/**
 * \ref PS_DBG_RWATCH_ADDR1 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR1_3 0x830b
///@}
/**
 * \name PS_DBG_RWATCH_ADDR2
 * \anchor PS_DBG_RWATCH_ADDR2
 * This set of registers contains the value for the four resource watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_RWATCH_ADDR2 0x4
/**
 * \ref PS_DBG_RWATCH_ADDR2 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR2_0 0x900b
/**
 * \ref PS_DBG_RWATCH_ADDR2 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR2_1 0x910b
/**
 * \ref PS_DBG_RWATCH_ADDR2 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR2_2 0x920b
/**
 * \ref PS_DBG_RWATCH_ADDR2 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR2_3 0x930b
///@}
/**
 * \name PS_DBG_RWATCH_CTRL
 * \anchor PS_DBG_RWATCH_CTRL
 * This set of registers controls each of the four resource watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref BRK_ENABLE When 1 the instruction breakpoint is enabled.
 * 
 * \ref RBRK_CONDITION When 0 break when condition A is met. When 1 = break when condition B is met.
 * 
 * \ref BRK_THREADS A bit for each thread in the machine allowing the breakpoint to be enabled individually for each thread.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_RWATCH_CTRL 0x4
/**
 * \ref PS_DBG_RWATCH_CTRL 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_CTRL_0 0x9c0b
/**
 * \ref PS_DBG_RWATCH_CTRL 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_CTRL_1 0x9d0b
/**
 * \ref PS_DBG_RWATCH_CTRL 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_CTRL_2 0x9e0b
/**
 * \ref PS_DBG_RWATCH_CTRL 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_CTRL_3 0x9f0b
///@}
/// @}
/**
 * \defgroup xs2aPSWITCHRegisters xs2a PSWITCH Registers
 * @{
 */
/**
 * PSWITCH_DEVICE_ID0 processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register identifies the xCORE Tile
 * 
 * Sub-Fields:
 * 
 * \ref DEVICE_ID0_VERSION XCore version.
 * 
 * \ref DEVICE_ID0_REVISION XCore revision.
 * 
 * \ref DEVICE_ID0_NODE Number of the node in which this XCore is located.
 * 
 * \ref DEVICE_ID0_PID Processor ID of this XCore.
 * 
 */
#define XS1_PSWITCH_DEVICE_ID0_NUM 0x0
/**
 * PSWITCH_DEVICE_ID1 processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register describes the number of logical cores, synchronisers, locks and channel ends available on this xCORE tile.
 * 
 * Sub-Fields:
 * 
 * \ref DEVICE_ID1_NUM_THREADS Number of threads.
 * 
 * \ref DEVICE_ID1_NUM_SYNCS Number of synchronisers.
 * 
 * \ref DEVICE_ID1_NUM_LOCKS Number of the locks.
 * 
 * \ref DEVICE_ID1_NUM_CHANENDS Number of channel ends.
 * 
 */
#define XS1_PSWITCH_DEVICE_ID1_NUM 0x1
/**
 * PSWITCH_DEVICE_ID2 processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register describes the number of timers and clock blocks available on this xCORE tile.
 * 
 * Sub-Fields:
 * 
 * \ref DEVICE_ID2_NUM_TIMERS Number of timers.
 * 
 * \ref DEVICE_ID2_NUM_CLKBLKS Number of clock blocks.
 * 
 */
#define XS1_PSWITCH_DEVICE_ID2_NUM 0x2
/**
 * PSWITCH_DEVICE_ID3 processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 */
#define XS1_PSWITCH_DEVICE_ID3_NUM 0x3
/**
 * PSWITCH_DBG_CTRL processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register can be used to control whether the debug registers (marked with permission CRW) are accessible through the tile configuration registers. When this bit is set, write -access to those registers is disabled, preventing debugging of the xCORE tile over the interconnect.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_CTRL_PSWITCH_RO_EXT When 1 the PSwitch is restricted to RO access to all CRW registers from SSwitch 
 * 
 * \ref DBG_CTRL_PSWITCH_RO When 1 the PSwitch is restricted to RO access to all CRW registers from SSwitch, XCore(PS_DBG_Scratch) and JTAG 
 * 
 */
#define XS1_PSWITCH_DBG_CTRL_NUM 0x4
/**
 * PSWITCH_DBG_INT processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register can be used to raise a debug interrupt in this xCORE tile.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_INT_REQ_DBG Request a debug interrupt on the processor.
 * 
 * \ref DBG_INT_IN_DBG 1 when the processor is in debug mode.
 * 
 */
#define XS1_PSWITCH_DBG_INT_NUM 0x5
/**
 * PSWITCH_PLL_CLK_DIVIDER processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register contains the value used to divide the PLL clock to create the xCORE tile clock. The divider is enabled under control of the tile control register
 * 
 * Sub-Fields:
 * 
 * \ref PLL_CLK_DIVIDER Clock divider.
 * 
 * \ref PLL_CLK_DISABLE Clock disable. Writing '1' will remove the clock to the tile.
 * 
 */
#define XS1_PSWITCH_PLL_CLK_DIVIDER_NUM 0x6
/**
 * PSWITCH_SECU_CONFIG processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Copy of the security register as read from OTP.
 * 
 * Sub-Fields:
 * 
 * \ref SECUR_CFG_DISABLE_XCORE_JTAG Disable access to XCore's JTAG debug TAP 
 * 
 * \ref SECUR_CFG_DISABLE_PLL_JTAG Disable JTAG access to the PLL/BOOT configuration registers 
 * 
 * \ref SECUR_CFG_SECURE_BOOT Override boot mode and read boot image from OTP 
 * 
 * \ref SECUR_CFG_OTP_REDUANACY_ENABLE Enable OTP reduanacy 
 * 
 * \ref SECUR_CFG_OTP_SECTOR_LOCK lock bit for each OTP sector 
 * 
 * \ref SECUR_CFG_OTP_MASTER_LOCK lock all OTP sectors 
 * 
 * \ref SECUR_CFG_DISABLE_GLOBAL_DEBUG Disable access to XCore's global debug 
 * 
 * \ref SECUR_CFG_DISABLE_ACCESS Disables write permission on this register 
 * 
 */
#define XS1_PSWITCH_SECU_CONFIG_NUM 0x7
/**
 * \name PSWITCH_DBG_SCRATCH
 * \anchor PSWITCH_DBG_SCRATCH
 * A set of registers used by the debug ROM to communicate with an external debugger, for example over the switch. This is the same set of registers as the Debug Scratch registers in the processor status.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PSWITCH_DBG_SCRATCH 0x8
/**
 * \ref PSWITCH_DBG_SCRATCH 0 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_0_NUM 0x20
/**
 * \ref PSWITCH_DBG_SCRATCH 1 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_1_NUM 0x21
/**
 * \ref PSWITCH_DBG_SCRATCH 2 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_2_NUM 0x22
/**
 * \ref PSWITCH_DBG_SCRATCH 3 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_3_NUM 0x23
/**
 * \ref PSWITCH_DBG_SCRATCH 4 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_4_NUM 0x24
/**
 * \ref PSWITCH_DBG_SCRATCH 5 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_5_NUM 0x25
/**
 * \ref PSWITCH_DBG_SCRATCH 6 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_6_NUM 0x26
/**
 * \ref PSWITCH_DBG_SCRATCH 7 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_7_NUM 0x27
///@}
/**
 * PSWITCH_T0_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 0.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T0_PC_NUM 0x40
/**
 * PSWITCH_T1_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 1.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T1_PC_NUM 0x41
/**
 * PSWITCH_T2_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 2.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T2_PC_NUM 0x42
/**
 * PSWITCH_T3_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 3.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T3_PC_NUM 0x43
/**
 * PSWITCH_T4_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 4.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T4_PC_NUM 0x44
/**
 * PSWITCH_T5_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 5.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T5_PC_NUM 0x45
/**
 * PSWITCH_T6_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 6.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T6_PC_NUM 0x46
/**
 * PSWITCH_T7_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 7.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T7_PC_NUM 0x47
/**
 * PSWITCH_T0_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 0
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T0_SR_NUM 0x60
/**
 * PSWITCH_T1_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 1
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T1_SR_NUM 0x61
/**
 * PSWITCH_T2_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 2
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T2_SR_NUM 0x62
/**
 * PSWITCH_T3_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 3
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T3_SR_NUM 0x63
/**
 * PSWITCH_T4_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 4
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T4_SR_NUM 0x64
/**
 * PSWITCH_T5_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 5
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T5_SR_NUM 0x65
/**
 * PSWITCH_T6_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 6
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T6_SR_NUM 0x66
/**
 * PSWITCH_T7_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 7
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T7_SR_NUM 0x67
/// @}
/**
 * \defgroup xs2aSSWITCHRegisters xs2a SSWITCH Registers
 * @{
 */
/**
 * SSWITCH_DEVICE_ID0 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * This register contains version and revision identifiers and the mode-pins as sampled at boot-time.
 * 
 * Sub-Fields:
 * 
 * \ref SS_DEVICE_ID0_VERSION SSwitch version.
 * 
 * \ref SS_DEVICE_ID0_REVISION SSwitch revision.
 * 
 * \ref SS_DEVICE_ID0_BOOT_CTRL Sampled values of BootCtl pins on Power On Reset.
 * 
 */
#define XS1_SSWITCH_DEVICE_ID0_NUM 0x0
/**
 * SSWITCH_DEVICE_ID1 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * This register specifies the number of processors and links that are connected to this switch.
 * 
 * Sub-Fields:
 * 
 * \ref SS_DEVICE_ID1_NUM_PLINKS_PER_PROC Number of processors on the device.
 * 
 * \ref SS_DEVICE_ID1_NUM_PROCESSORS Number of processors on the SSwitch.
 * 
 * \ref SS_DEVICE_ID1_NUM_SLINKS Number of SLinks on the SSwitch.
 * 
 */
#define XS1_SSWITCH_DEVICE_ID1_NUM 0x1
/**
 * SSWITCH_DEVICE_ID2 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_DEVICE_ID2_NUM 0x2
/**
 * SSWITCH_DEVICE_ID3 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_DEVICE_ID3_NUM 0x3
/**
 * SSWITCH_NODE_CONFIG system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register enables the setting of two security modes (that disable updates to the PLL or any other registers) and the header-mode.
 * 
 * Sub-Fields:
 * 
 * \ref SS_NODE_CONFIG_HEADERS 0 = 2-byte headers, 1 = 1-byte headers (reset as 0).
 * 
 * \ref SS_NODE_CONFIG_DISABLE_PLL_CTL_REG 0 = PLL_CTL_REG has write access. 1 = PLL_CTL_REG can not be written to.
 * 
 * \ref SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE 0 = SSCTL registers have write access. 1 = SSCTL registers can not be written to.
 * 
 */
#define XS1_SSWITCH_NODE_CONFIG_NUM 0x4
/**
 * SSWITCH_NODE_ID system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register contains the node identifier.
 * 
 * Sub-Fields:
 * 
 * \ref SS_NODE_ID_ID The unique ID of this node.
 * 
 */
#define XS1_SSWITCH_NODE_ID_NUM 0x5
/**
 * SSWITCH_PLL_CTL system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * An on-chip PLL multiplies the input clock up to a higher frequency clock, used to clock the I/O, processor, and switch, see Oscillator. Note: a write to this register will cause the tile to be reset.
 * 
 * Sub-Fields:
 * 
 * \ref SS_PLL_CTL_INPUT_DIVISOR Oscilator input divider value range from 0 (8'h0) to 63 (8'h3F). R value.
 * 
 * \ref SS_PLL_CTL_FEEDBACK_MUL Feedback multiplication ratio, range from 0 (8'h0) to 4095 (8'h3FF). F value.
 * 
 * \ref SS_PLL_CTL_POST_DIVISOR Output divider value range from 0 (8'h0) to 7 (8'h7). OD value.
 * 
 * \ref SS_TEST_MODE_BOOT_RAM If set to 1, set the boot mode to jump to RAM
 * 
 * \ref SS_TEST_MODE_BOOT_JTAG If set to 1, set the boot mode to boot from JTAG
 * 
 * \ref SS_TEST_MODE_PLL_BYPASS If set to 1, set the PLL to be bypassed
 * 
 * \ref SS_PLL_CTL_NLOCK If set to 1, the chip will not wait for the PLL to re-lock. Only use this
 *       if a gradual change is made to the PLL
 * 
 * \ref SS_PLL_CTL_NRESET If set to 1, the chip will not be reset
 * 
 */
#define XS1_SSWITCH_PLL_CTL_NUM 0x6
/**
 * SSWITCH_CLK_DIVIDER system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Sets the ratio of the PLL clock and the switch clock.
 * 
 * Sub-Fields:
 * 
 * \ref SS_CLK_DIVIDER_CLK_DIV SSwitch clock generation
 * 
 */
#define XS1_SSWITCH_CLK_DIVIDER_NUM 0x7
/**
 * SSWITCH_REF_CLK_DIVIDER system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Sets the ratio of the PLL clock and the reference clock used by the node.
 * 
 * Sub-Fields:
 * 
 * \ref SS_SSWITCH_REF_CLK_DIV Software ref. clock divider
 * 
 */
#define XS1_SSWITCH_REF_CLK_DIVIDER_NUM 0x8
/**
 * SSWITCH_JTAG_DEVICE_ID system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref SS_JTAG_DEVICE_ID_CONST_VAL 
 * 
 * \ref SS_JTAG_DEVICE_ID_MANU_ID 
 * 
 * \ref SS_JTAG_DEVICE_ID_PART_NUM 
 * 
 * \ref SS_JTAG_DEVICE_ID_VERSION 
 * 
 */
#define XS1_SSWITCH_JTAG_DEVICE_ID_NUM 0x9
/**
 * SSWITCH_JTAG_USERCODE system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref SS_JTAG_USERCODE_MASKID metal fixable ID code 
 * 
 * \ref SS_JTAG_USERCODE_OTP JTAG USERCODE value programmed into OTP SR
 * 
 */
#define XS1_SSWITCH_JTAG_USERCODE_NUM 0xa
/**
 * SSWITCH_DIMENSION_DIRECTION0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register contains eight directions, for packets with a mismatch in bits 7..0 of the node-identifier. The direction in which a packet will be routed is goverened by the most significant mismatching bit.
 * 
 * Sub-Fields:
 * 
 * \ref DIM0_DIR The direction for packets whose dimension is 0.  
 * 
 * \ref DIM1_DIR The direction for packets whose dimension is 1.  
 * 
 * \ref DIM2_DIR The direction for packets whose dimension is 2.  
 * 
 * \ref DIM3_DIR The direction for packets whose dimension is 3.  
 * 
 * \ref DIM4_DIR The direction for packets whose dimension is 4.  
 * 
 * \ref DIM5_DIR The direction for packets whose dimension is 5.  
 * 
 * \ref DIM6_DIR The direction for packets whose dimension is 6.  
 * 
 * \ref DIM7_DIR The direction for packets whose dimension is 7.  
 * 
 */
#define XS1_SSWITCH_DIMENSION_DIRECTION0_NUM 0xc
/**
 * SSWITCH_DIMENSION_DIRECTION1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register contains eight directions, for packets with a mismatch in bits 15..8 of the node-identifier. The direction in which a packet will be routed is goverened by the most significant mismatching bit.
 * 
 * Sub-Fields:
 * 
 * \ref DIM8_DIR The direction for packets whose dimension is 8.  
 * 
 * \ref DIM9_DIR The direction for packets whose dimension is 9.  
 * 
 * \ref DIMA_DIR The direction for packets whose dimension is A.  
 * 
 * \ref DIMB_DIR The direction for packets whose dimension is B.  
 * 
 * \ref DIMC_DIR The direction for packets whose dimension is C.  
 * 
 * \ref DIMD_DIR The direction for packets whose dimension is D.  
 * 
 * \ref DIME_DIR The direction for packets whose dimension is E.  
 * 
 * \ref DIMF_DIR The direction for packets whose dimension is F.  
 * 
 */
#define XS1_SSWITCH_DIMENSION_DIRECTION1_NUM 0xd
/**
 * SSWITCH_XCORE0_GLOBAL_DEBUG_CONFIG system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * if DEBUGN Configures the behavior of the DEBUG_N pin.else  Reserved.
 * 
 * Sub-Fields:
 * 
 * \ref GLOBAL_DEBUG_ENABLE_INDEBUG if DEBUGN Set 1 to enable inDebug bit to drive GlobalDebug.else  Reserved.
 * 
 * \ref GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ if DEBUGN Set 1 to enable GlobalDebug to generate debug request to XCore.else  Reserved.
 * 
 */
#define XS1_SSWITCH_XCORE0_GLOBAL_DEBUG_CONFIG_NUM 0x10
/**
 * SSWITCH_XCORE1_GLOBAL_DEBUG_CONFIG system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * if DEBUGN Configures the behavior of the DEBUG_N pin.else  Reserved.
 * 
 * Sub-Fields:
 * 
 * \ref GLOBAL_DEBUG_ENABLE_INDEBUG if DEBUGN Set 1 to enable inDebug bit to drive GlobalDebug.else  Reserved.
 * 
 * \ref GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ if DEBUGN Set 1 to enable GlobalDebug to generate debug request to XCore.else  Reserved.
 * 
 */
#define XS1_SSWITCH_XCORE1_GLOBAL_DEBUG_CONFIG_NUM 0x11
/**
 * SSWITCH_GLOBAL_DEBUG_SOURCE system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * Contains the source of the most recent debug event.
 * 
 * Sub-Fields:
 * 
 * \ref GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG If set, XCore0 is the source of last GlobalDebug event.
 * 
 * \ref GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG If set, XCore1 is the source of last GlobalDebug event.
 * 
 * \ref GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG if DEBUGN If set, external pin, is the source of last GlobalDebug event.else  Reserved.
 * 
 */
#define XS1_SSWITCH_GLOBAL_DEBUG_SOURCE_NUM 0x1f
/**
 * \name SSWITCH_SLINK
 * \anchor SSWITCH_SLINK
 * These registers contain status information for low level debugging
 *         (read-only), the network number that each link belongs to, and the
 *         direction that each link is part of. The registers control links 0..7.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref LINK_SRC_INUSE 1 when the source side of the link is in use.
 * 
 * \ref LINK_DST_INUSE 1 when the dest side of the link is in use.
 * 
 * \ref LINK_JUNK 1 when the current packet is considered junk and will be thrown away.
 * 
 * \ref LINK_NETWORK Determines the network to which this link belongs, reset as 0.
 * 
 * \ref LINK_DIRECTION The direction that this link operates in.
 * 
 * \ref SLINK_SRC_TARGET_ID When the link is in use, this is the destination link number to which all packets are sent.
 * 
 * \ref SLINK_SRC_TARGET_TYPE Identify the SRC_TARGET type 0 - SLink, 1 - PLink, 2 - SSCTL, 3 - Undefine.
 * 
 */
///@{
#define XS1_NUM_SSWITCH_SLINK 0x9
/**
 * \ref SSWITCH_SLINK 0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_0_NUM 0x20
/**
 * \ref SSWITCH_SLINK 1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_1_NUM 0x21
/**
 * \ref SSWITCH_SLINK 2 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_2_NUM 0x22
/**
 * \ref SSWITCH_SLINK 3 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_3_NUM 0x23
/**
 * \ref SSWITCH_SLINK 4 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_4_NUM 0x24
/**
 * \ref SSWITCH_SLINK 5 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_5_NUM 0x25
/**
 * \ref SSWITCH_SLINK 6 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_6_NUM 0x26
/**
 * \ref SSWITCH_SLINK 7 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_7_NUM 0x27
/**
 * \ref SSWITCH_SLINK 8 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_8_NUM 0x28
///@}
/**
 * \name SSWITCH_PLINK
 * \anchor SSWITCH_PLINK
 * These registers contain status information and the network number that each processor-link belongs to.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref LINK_SRC_INUSE 1 when the source side of the link is in use.
 * 
 * \ref LINK_DST_INUSE 1 when the dest side of the link is in use.
 * 
 * \ref LINK_JUNK 1 when the current packet is considered junk and will be thrown away.
 * 
 * \ref LINK_NETWORK Determines the network to which this link belongs, reset as 0.
 * 
 * \ref PLINK_SRC_TARGET_ID When the link is in use, this is the destination link number to which all packets are sent.
 * 
 * \ref PLINK_SRC_TARGET_TYPE Identify the SRC_TARGET type 0 - SLink, 1 - PLink, 2 - SSCTL, 3 - Undefine.
 * 
 */
///@{
#define XS1_NUM_SSWITCH_PLINK 0x8
/**
 * \ref SSWITCH_PLINK 0 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_0_NUM 0x40
/**
 * \ref SSWITCH_PLINK 1 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_1_NUM 0x41
/**
 * \ref SSWITCH_PLINK 2 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_2_NUM 0x42
/**
 * \ref SSWITCH_PLINK 3 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_3_NUM 0x43
/**
 * \ref SSWITCH_PLINK 4 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_4_NUM 0x44
/**
 * \ref SSWITCH_PLINK 5 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_5_NUM 0x45
/**
 * \ref SSWITCH_PLINK 6 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_6_NUM 0x46
/**
 * \ref SSWITCH_PLINK 7 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_7_NUM 0x47
///@}
/**
 * \name SSWITCH_XLINK
 * \anchor SSWITCH_XLINK
 * These registers contain configuration and debugging information
 *         specific to external links. The link speed and width can be set,
 *         the link can be initialized, and the link status can be monitored.
 *         The registers control links 0..7.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref XLINK_INTER_TOKEN_DELAY Specify min. number of idle system clocks between two continuous transmit tokens -1.
 * 
 * \ref XLINK_INTRA_TOKEN_DELAY Specify min. number of idle system clocks between two continuous symbols witin a transmit token -1.
 * 
 * \ref XLINK_RX_RESET Reset the receiver.  The next symbol that is detected will be the first symbol in a token.
 * 
 * \ref XLINK_HELLO Clear this end of the xlink's credit and issue a HELLO token.
 * 
 * \ref TX_CREDIT This end of the xlink has credit to allow it to transmit.
 * 
 * \ref RX_CREDIT This end of the xlink has issued credit to allow the remote end to transmit
 * 
 * \ref XLINK_RX_ERROR Rx buffer overflow or illegal token encoding received.
 * 
 * \ref XLINK_WIDE 0: operate in 2 wire mode; 1: operate in 5 wire mode
 * 
 * \ref XLINK_ENABLE Write to this bit with '1' will enable the XLink, writing '0' will disable it. This bit controls the muxing of ports with overlapping xlinks.
 * 
 */
///@{
#define XS1_NUM_SSWITCH_XLINK 0x9
/**
 * \ref SSWITCH_XLINK 0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_0_NUM 0x80
/**
 * \ref SSWITCH_XLINK 1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_1_NUM 0x81
/**
 * \ref SSWITCH_XLINK 2 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_2_NUM 0x82
/**
 * \ref SSWITCH_XLINK 3 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_3_NUM 0x83
/**
 * \ref SSWITCH_XLINK 4 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_4_NUM 0x84
/**
 * \ref SSWITCH_XLINK 5 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_5_NUM 0x85
/**
 * \ref SSWITCH_XLINK 6 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_6_NUM 0x86
/**
 * \ref SSWITCH_XLINK 7 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_7_NUM 0x87
/**
 * \ref SSWITCH_XLINK 8 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_8_NUM 0x88
///@}
/**
 * \name SSWITCH_XSTATIC
 * \anchor SSWITCH_XSTATIC
 * These registers are used for static (ie, non-routed) links.
 *         When a link is made static, all traffic is forwarded to the
 *         designated channel end and no routing is attempted.
 *         The registers control links C, D, A, B, G, H, E, and F in that order.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref XSTATIC_DEST_CHAN_END The destination channel end on this node that packets received in static mode are forwarded to.
 * 
 * \ref XSTATIC_DEST_PROC The destination processor on this node that packets received in static mode are forwarded to.
 * 
 * \ref XSTATIC_ENABLE Enable static forwarding.
 * 
 */
///@{
#define XS1_NUM_SSWITCH_XSTATIC 0x8
/**
 * \ref SSWITCH_XSTATIC 0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_0_NUM 0xa0
/**
 * \ref SSWITCH_XSTATIC 1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_1_NUM 0xa1
/**
 * \ref SSWITCH_XSTATIC 2 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_2_NUM 0xa2
/**
 * \ref SSWITCH_XSTATIC 3 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_3_NUM 0xa3
/**
 * \ref SSWITCH_XSTATIC 4 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_4_NUM 0xa4
/**
 * \ref SSWITCH_XSTATIC 5 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_5_NUM 0xa5
/**
 * \ref SSWITCH_XSTATIC 6 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_6_NUM 0xa6
/**
 * \ref SSWITCH_XSTATIC 7 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_7_NUM 0xa7
///@}
/// @}
/**
 * \defgroup xs2aRegisterBitfields xs2a Register Bitfields
 * @{
 */
/**
 * \name SR_EEBLE
 * \anchor SR_EEBLE
 * When 1 events are enabled for the thread.
 */
///@{
#define XS1_SR_EEBLE_SHIFT 0x0
#define XS1_SR_EEBLE_SIZE 0x1
#define XS1_SR_EEBLE_MASK (((1 << XS1_SR_EEBLE_SIZE) - 1) << XS1_SR_EEBLE_SHIFT)
/**
 * Extract the SR_EEBLE bitfield from a packed word x and return it.
 */
#define XS1_SR_EEBLE(x) (((x) & XS1_SR_EEBLE_MASK) >> XS1_SR_EEBLE_SHIFT)
/**
 * Pack the value (v) of the SR_EEBLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_EEBLE_SET(x, v) (((x) & ~XS1_SR_EEBLE_MASK) | (((v) << XS1_SR_EEBLE_SHIFT) & XS1_SR_EEBLE_MASK))
///@}
/**
 * \name SR_IEBLE
 * \anchor SR_IEBLE
 * When 1 interrupts are enabled for the thread.
 */
///@{
#define XS1_SR_IEBLE_SHIFT 0x1
#define XS1_SR_IEBLE_SIZE 0x1
#define XS1_SR_IEBLE_MASK (((1 << XS1_SR_IEBLE_SIZE) - 1) << XS1_SR_IEBLE_SHIFT)
/**
 * Extract the SR_IEBLE bitfield from a packed word x and return it.
 */
#define XS1_SR_IEBLE(x) (((x) & XS1_SR_IEBLE_MASK) >> XS1_SR_IEBLE_SHIFT)
/**
 * Pack the value (v) of the SR_IEBLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_IEBLE_SET(x, v) (((x) & ~XS1_SR_IEBLE_MASK) | (((v) << XS1_SR_IEBLE_SHIFT) & XS1_SR_IEBLE_MASK))
///@}
/**
 * \name SR_INENB
 * \anchor SR_INENB
 * 1 when in an event enabling sequence.
 */
///@{
#define XS1_SR_INENB_SHIFT 0x2
#define XS1_SR_INENB_SIZE 0x1
#define XS1_SR_INENB_MASK (((1 << XS1_SR_INENB_SIZE) - 1) << XS1_SR_INENB_SHIFT)
/**
 * Extract the SR_INENB bitfield from a packed word x and return it.
 */
#define XS1_SR_INENB(x) (((x) & XS1_SR_INENB_MASK) >> XS1_SR_INENB_SHIFT)
/**
 * Pack the value (v) of the SR_INENB bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_INENB_SET(x, v) (((x) & ~XS1_SR_INENB_MASK) | (((v) << XS1_SR_INENB_SHIFT) & XS1_SR_INENB_MASK))
///@}
/**
 * \name SR_ININT
 * \anchor SR_ININT
 * 1 when in an interrupt handler.
 */
///@{
#define XS1_SR_ININT_SHIFT 0x3
#define XS1_SR_ININT_SIZE 0x1
#define XS1_SR_ININT_MASK (((1 << XS1_SR_ININT_SIZE) - 1) << XS1_SR_ININT_SHIFT)
/**
 * Extract the SR_ININT bitfield from a packed word x and return it.
 */
#define XS1_SR_ININT(x) (((x) & XS1_SR_ININT_MASK) >> XS1_SR_ININT_SHIFT)
/**
 * Pack the value (v) of the SR_ININT bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_ININT_SET(x, v) (((x) & ~XS1_SR_ININT_MASK) | (((v) << XS1_SR_ININT_SHIFT) & XS1_SR_ININT_MASK))
///@}
/**
 * \name SR_INK
 * \anchor SR_INK
 * 1 when in kernel mode.
 */
///@{
#define XS1_SR_INK_SHIFT 0x4
#define XS1_SR_INK_SIZE 0x1
#define XS1_SR_INK_MASK (((1 << XS1_SR_INK_SIZE) - 1) << XS1_SR_INK_SHIFT)
/**
 * Extract the SR_INK bitfield from a packed word x and return it.
 */
#define XS1_SR_INK(x) (((x) & XS1_SR_INK_MASK) >> XS1_SR_INK_SHIFT)
/**
 * Pack the value (v) of the SR_INK bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_INK_SET(x, v) (((x) & ~XS1_SR_INK_MASK) | (((v) << XS1_SR_INK_SHIFT) & XS1_SR_INK_MASK))
///@}
/**
 * \name SR_SINK
 * \anchor SR_SINK
 * Copy of the SSR INK bit.
 */
///@{
#define XS1_SR_SINK_SHIFT 0x5
#define XS1_SR_SINK_SIZE 0x1
#define XS1_SR_SINK_MASK (((1 << XS1_SR_SINK_SIZE) - 1) << XS1_SR_SINK_SHIFT)
/**
 * Extract the SR_SINK bitfield from a packed word x and return it.
 */
#define XS1_SR_SINK(x) (((x) & XS1_SR_SINK_MASK) >> XS1_SR_SINK_SHIFT)
/**
 * Pack the value (v) of the SR_SINK bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_SINK_SET(x, v) (((x) & ~XS1_SR_SINK_MASK) | (((v) << XS1_SR_SINK_SHIFT) & XS1_SR_SINK_MASK))
///@}
/**
 * \name SR_WAITING
 * \anchor SR_WAITING
 * When 1 the thread is paused waiting for events, a lock or another resource.
 */
///@{
#define XS1_SR_WAITING_SHIFT 0x6
#define XS1_SR_WAITING_SIZE 0x1
#define XS1_SR_WAITING_MASK (((1 << XS1_SR_WAITING_SIZE) - 1) << XS1_SR_WAITING_SHIFT)
/**
 * Extract the SR_WAITING bitfield from a packed word x and return it.
 */
#define XS1_SR_WAITING(x) (((x) & XS1_SR_WAITING_MASK) >> XS1_SR_WAITING_SHIFT)
/**
 * Pack the value (v) of the SR_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_WAITING_SET(x, v) (((x) & ~XS1_SR_WAITING_MASK) | (((v) << XS1_SR_WAITING_SHIFT) & XS1_SR_WAITING_MASK))
///@}
/**
 * \name SR_FAST
 * \anchor SR_FAST
 * When 1 the thread is in fast mode and will continually issue.
 */
///@{
#define XS1_SR_FAST_SHIFT 0x7
#define XS1_SR_FAST_SIZE 0x1
#define XS1_SR_FAST_MASK (((1 << XS1_SR_FAST_SIZE) - 1) << XS1_SR_FAST_SHIFT)
/**
 * Extract the SR_FAST bitfield from a packed word x and return it.
 */
#define XS1_SR_FAST(x) (((x) & XS1_SR_FAST_MASK) >> XS1_SR_FAST_SHIFT)
/**
 * Pack the value (v) of the SR_FAST bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_FAST_SET(x, v) (((x) & ~XS1_SR_FAST_MASK) | (((v) << XS1_SR_FAST_SHIFT) & XS1_SR_FAST_MASK))
///@}
/**
 * \name SR_DI
 * \anchor SR_DI
 * Determines the issue mode (DI bit).
 */
///@{
#define XS1_SR_DI_SHIFT 0x8
#define XS1_SR_DI_SIZE 0x1
#define XS1_SR_DI_MASK (((1 << XS1_SR_DI_SIZE) - 1) << XS1_SR_DI_SHIFT)
/**
 * Extract the SR_DI bitfield from a packed word x and return it.
 */
#define XS1_SR_DI(x) (((x) & XS1_SR_DI_MASK) >> XS1_SR_DI_SHIFT)
/**
 * Pack the value (v) of the SR_DI bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_DI_SET(x, v) (((x) & ~XS1_SR_DI_MASK) | (((v) << XS1_SR_DI_SHIFT) & XS1_SR_DI_MASK))
///@}
/**
 * \name SR_KEDI
 * \anchor SR_KEDI
 * Determines the issue mode (DI bit) upon Kernel Entry after Exception or Interrupt.
 */
///@{
#define XS1_SR_KEDI_SHIFT 0x9
#define XS1_SR_KEDI_SIZE 0x1
#define XS1_SR_KEDI_MASK (((1 << XS1_SR_KEDI_SIZE) - 1) << XS1_SR_KEDI_SHIFT)
/**
 * Extract the SR_KEDI bitfield from a packed word x and return it.
 */
#define XS1_SR_KEDI(x) (((x) & XS1_SR_KEDI_MASK) >> XS1_SR_KEDI_SHIFT)
/**
 * Pack the value (v) of the SR_KEDI bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_KEDI_SET(x, v) (((x) & ~XS1_SR_KEDI_MASK) | (((v) << XS1_SR_KEDI_SHIFT) & XS1_SR_KEDI_MASK))
///@}
/**
 * \name SR_QUEUE
 * \anchor SR_QUEUE
 * Address space indentifier
 */
///@{
#define XS1_SR_QUEUE_SHIFT 0xa
#define XS1_SR_QUEUE_SIZE 0x1
#define XS1_SR_QUEUE_MASK (((1 << XS1_SR_QUEUE_SIZE) - 1) << XS1_SR_QUEUE_SHIFT)
/**
 * Extract the SR_QUEUE bitfield from a packed word x and return it.
 */
#define XS1_SR_QUEUE(x) (((x) & XS1_SR_QUEUE_MASK) >> XS1_SR_QUEUE_SHIFT)
/**
 * Pack the value (v) of the SR_QUEUE bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_QUEUE_SET(x, v) (((x) & ~XS1_SR_QUEUE_MASK) | (((v) << XS1_SR_QUEUE_SHIFT) & XS1_SR_QUEUE_MASK))
///@}
/**
 * \name ID_ID
 * \anchor ID_ID
 * Number of the thread.
 */
///@{
#define XS1_ID_ID_SHIFT 0x0
#define XS1_ID_ID_SIZE 0x6
#define XS1_ID_ID_MASK (((1 << XS1_ID_ID_SIZE) - 1) << XS1_ID_ID_SHIFT)
/**
 * Extract the ID_ID bitfield from a packed word x and return it.
 */
#define XS1_ID_ID(x) (((x) & XS1_ID_ID_MASK) >> XS1_ID_ID_SHIFT)
/**
 * Pack the value (v) of the ID_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_ID_ID_SET(x, v) (((x) & ~XS1_ID_ID_MASK) | (((v) << XS1_ID_ID_SHIFT) & XS1_ID_ID_MASK))
///@}
/**
 * \name EXCEPTION_TYPE
 * \anchor EXCEPTION_TYPE
 * The exception type.
 */
///@{
#define XS1_EXCEPTION_TYPE_SHIFT 0x0
#define XS1_EXCEPTION_TYPE_SIZE 0x5
#define XS1_EXCEPTION_TYPE_MASK (((1 << XS1_EXCEPTION_TYPE_SIZE) - 1) << XS1_EXCEPTION_TYPE_SHIFT)
/**
 * Extract the EXCEPTION_TYPE bitfield from a packed word x and return it.
 */
#define XS1_EXCEPTION_TYPE(x) (((x) & XS1_EXCEPTION_TYPE_MASK) >> XS1_EXCEPTION_TYPE_SHIFT)
/**
 * Pack the value (v) of the EXCEPTION_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_EXCEPTION_TYPE_SET(x, v) (((x) & ~XS1_EXCEPTION_TYPE_MASK) | (((v) << XS1_EXCEPTION_TYPE_SHIFT) & XS1_EXCEPTION_TYPE_MASK))
///@}
/**
 * \name DBG_T_NUM_NUM
 * \anchor DBG_T_NUM_NUM
 * Thread number to be read
 */
///@{
#define XS1_DBG_T_NUM_NUM_SHIFT 0x0
#define XS1_DBG_T_NUM_NUM_SIZE 0x8
#define XS1_DBG_T_NUM_NUM_MASK (((1 << XS1_DBG_T_NUM_NUM_SIZE) - 1) << XS1_DBG_T_NUM_NUM_SHIFT)
/**
 * Extract the DBG_T_NUM_NUM bitfield from a packed word x and return it.
 */
#define XS1_DBG_T_NUM_NUM(x) (((x) & XS1_DBG_T_NUM_NUM_MASK) >> XS1_DBG_T_NUM_NUM_SHIFT)
/**
 * Pack the value (v) of the DBG_T_NUM_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_T_NUM_NUM_SET(x, v) (((x) & ~XS1_DBG_T_NUM_NUM_MASK) | (((v) << XS1_DBG_T_NUM_NUM_SHIFT) & XS1_DBG_T_NUM_NUM_MASK))
///@}
/**
 * \name DBG_T_REG_REG
 * \anchor DBG_T_REG_REG
 * Register number to be read
 */
///@{
#define XS1_DBG_T_REG_REG_SHIFT 0x0
#define XS1_DBG_T_REG_REG_SIZE 0x5
#define XS1_DBG_T_REG_REG_MASK (((1 << XS1_DBG_T_REG_REG_SIZE) - 1) << XS1_DBG_T_REG_REG_SHIFT)
/**
 * Extract the DBG_T_REG_REG bitfield from a packed word x and return it.
 */
#define XS1_DBG_T_REG_REG(x) (((x) & XS1_DBG_T_REG_REG_MASK) >> XS1_DBG_T_REG_REG_SHIFT)
/**
 * Pack the value (v) of the DBG_T_REG_REG bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_T_REG_REG_SET(x, v) (((x) & ~XS1_DBG_T_REG_REG_MASK) | (((v) << XS1_DBG_T_REG_REG_SHIFT) & XS1_DBG_T_REG_REG_MASK))
///@}
/**
 * \name BRK_ENABLE
 * \anchor BRK_ENABLE
 * When 1 the instruction breakpoint is enabled.
 */
///@{
#define XS1_BRK_ENABLE_SHIFT 0x0
#define XS1_BRK_ENABLE_SIZE 0x1
#define XS1_BRK_ENABLE_MASK (((1 << XS1_BRK_ENABLE_SIZE) - 1) << XS1_BRK_ENABLE_SHIFT)
/**
 * Extract the BRK_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_BRK_ENABLE(x) (((x) & XS1_BRK_ENABLE_MASK) >> XS1_BRK_ENABLE_SHIFT)
/**
 * Pack the value (v) of the BRK_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_BRK_ENABLE_SET(x, v) (((x) & ~XS1_BRK_ENABLE_MASK) | (((v) << XS1_BRK_ENABLE_SHIFT) & XS1_BRK_ENABLE_MASK))
///@}
/**
 * \name ALL_BITS
 * \anchor ALL_BITS
 * Value.
 */
///@{
#define XS1_ALL_BITS_SHIFT 0x0
#define XS1_ALL_BITS_SIZE 0x20
#define XS1_ALL_BITS_MASK (((1 << XS1_ALL_BITS_SIZE) - 1) << XS1_ALL_BITS_SHIFT)
/**
 * Extract the ALL_BITS bitfield from a packed word x and return it.
 */
#define XS1_ALL_BITS(x) (((x) & XS1_ALL_BITS_MASK) >> XS1_ALL_BITS_SHIFT)
/**
 * Pack the value (v) of the ALL_BITS bitfield into a packed word x and return the packed field.
 */
#define XS1_ALL_BITS_SET(x, v) (((x) & ~XS1_ALL_BITS_MASK) | (((v) << XS1_ALL_BITS_SHIFT) & XS1_ALL_BITS_MASK))
///@}
/**
 * \name KEP_ADDRESS_BITS
 * \anchor KEP_ADDRESS_BITS
 * KEP Address bits
 */
///@{
#define XS1_KEP_ADDRESS_BITS_SHIFT 0x7
#define XS1_KEP_ADDRESS_BITS_SIZE 0x19
#define XS1_KEP_ADDRESS_BITS_MASK (((1 << XS1_KEP_ADDRESS_BITS_SIZE) - 1) << XS1_KEP_ADDRESS_BITS_SHIFT)
/**
 * Extract the KEP_ADDRESS_BITS bitfield from a packed word x and return it.
 */
#define XS1_KEP_ADDRESS_BITS(x) (((x) & XS1_KEP_ADDRESS_BITS_MASK) >> XS1_KEP_ADDRESS_BITS_SHIFT)
/**
 * Pack the value (v) of the KEP_ADDRESS_BITS bitfield into a packed word x and return the packed field.
 */
#define XS1_KEP_ADDRESS_BITS_SET(x, v) (((x) & ~XS1_KEP_ADDRESS_BITS_MASK) | (((v) << XS1_KEP_ADDRESS_BITS_SHIFT) & XS1_KEP_ADDRESS_BITS_MASK))
///@}
/**
 * \name WORD_ADDRESS_BITS
 * \anchor WORD_ADDRESS_BITS
 * Most significant 16 bits of all addresses.
 */
///@{
#define XS1_WORD_ADDRESS_BITS_SHIFT 0x2
#define XS1_WORD_ADDRESS_BITS_SIZE 0x1e
#define XS1_WORD_ADDRESS_BITS_MASK (((1 << XS1_WORD_ADDRESS_BITS_SIZE) - 1) << XS1_WORD_ADDRESS_BITS_SHIFT)
/**
 * Extract the WORD_ADDRESS_BITS bitfield from a packed word x and return it.
 */
#define XS1_WORD_ADDRESS_BITS(x) (((x) & XS1_WORD_ADDRESS_BITS_MASK) >> XS1_WORD_ADDRESS_BITS_SHIFT)
/**
 * Pack the value (v) of the WORD_ADDRESS_BITS bitfield into a packed word x and return the packed field.
 */
#define XS1_WORD_ADDRESS_BITS_SET(x, v) (((x) & ~XS1_WORD_ADDRESS_BITS_MASK) | (((v) << XS1_WORD_ADDRESS_BITS_SHIFT) & XS1_WORD_ADDRESS_BITS_MASK))
///@}
/**
 * \name VECTOR_BASE
 * \anchor VECTOR_BASE
 * The event and interrupt vectors.
 */
///@{
#define XS1_VECTOR_BASE_SHIFT 0x12
#define XS1_VECTOR_BASE_SIZE 0xe
#define XS1_VECTOR_BASE_MASK (((1 << XS1_VECTOR_BASE_SIZE) - 1) << XS1_VECTOR_BASE_SHIFT)
/**
 * Extract the VECTOR_BASE bitfield from a packed word x and return it.
 */
#define XS1_VECTOR_BASE(x) (((x) & XS1_VECTOR_BASE_MASK) >> XS1_VECTOR_BASE_SHIFT)
/**
 * Pack the value (v) of the VECTOR_BASE bitfield into a packed word x and return the packed field.
 */
#define XS1_VECTOR_BASE_SET(x, v) (((x) & ~XS1_VECTOR_BASE_MASK) | (((v) << XS1_VECTOR_BASE_SHIFT) & XS1_VECTOR_BASE_MASK))
///@}
/**
 * \name IBRK_CONDITION
 * \anchor IBRK_CONDITION
 * When 0 break when PC == IBREAK_ADDR. When 1 = break when PC != IBREAK_ADDR.
 */
///@{
#define XS1_IBRK_CONDITION_SHIFT 0x1
#define XS1_IBRK_CONDITION_SIZE 0x1
#define XS1_IBRK_CONDITION_MASK (((1 << XS1_IBRK_CONDITION_SIZE) - 1) << XS1_IBRK_CONDITION_SHIFT)
/**
 * Extract the IBRK_CONDITION bitfield from a packed word x and return it.
 */
#define XS1_IBRK_CONDITION(x) (((x) & XS1_IBRK_CONDITION_MASK) >> XS1_IBRK_CONDITION_SHIFT)
/**
 * Pack the value (v) of the IBRK_CONDITION bitfield into a packed word x and return the packed field.
 */
#define XS1_IBRK_CONDITION_SET(x, v) (((x) & ~XS1_IBRK_CONDITION_MASK) | (((v) << XS1_IBRK_CONDITION_SHIFT) & XS1_IBRK_CONDITION_MASK))
///@}
/**
 * \name DBRK_CONDITION
 * \anchor DBRK_CONDITION
 * Determines the break condition: 0 = A AND B, 1 = A OR B.
 */
///@{
#define XS1_DBRK_CONDITION_SHIFT 0x1
#define XS1_DBRK_CONDITION_SIZE 0x1
#define XS1_DBRK_CONDITION_MASK (((1 << XS1_DBRK_CONDITION_SIZE) - 1) << XS1_DBRK_CONDITION_SHIFT)
/**
 * Extract the DBRK_CONDITION bitfield from a packed word x and return it.
 */
#define XS1_DBRK_CONDITION(x) (((x) & XS1_DBRK_CONDITION_MASK) >> XS1_DBRK_CONDITION_SHIFT)
/**
 * Pack the value (v) of the DBRK_CONDITION bitfield into a packed word x and return the packed field.
 */
#define XS1_DBRK_CONDITION_SET(x, v) (((x) & ~XS1_DBRK_CONDITION_MASK) | (((v) << XS1_DBRK_CONDITION_SHIFT) & XS1_DBRK_CONDITION_MASK))
///@}
/**
 * \name RBRK_CONDITION
 * \anchor RBRK_CONDITION
 * When 0 break when condition A is met. When 1 = break when condition B is met.
 */
///@{
#define XS1_RBRK_CONDITION_SHIFT 0x1
#define XS1_RBRK_CONDITION_SIZE 0x1
#define XS1_RBRK_CONDITION_MASK (((1 << XS1_RBRK_CONDITION_SIZE) - 1) << XS1_RBRK_CONDITION_SHIFT)
/**
 * Extract the RBRK_CONDITION bitfield from a packed word x and return it.
 */
#define XS1_RBRK_CONDITION(x) (((x) & XS1_RBRK_CONDITION_MASK) >> XS1_RBRK_CONDITION_SHIFT)
/**
 * Pack the value (v) of the RBRK_CONDITION bitfield into a packed word x and return the packed field.
 */
#define XS1_RBRK_CONDITION_SET(x, v) (((x) & ~XS1_RBRK_CONDITION_MASK) | (((v) << XS1_RBRK_CONDITION_SHIFT) & XS1_RBRK_CONDITION_MASK))
///@}
/**
 * \name BRK_LOAD
 * \anchor BRK_LOAD
 * When 1 the breakpoints will be be triggered on loads.
 */
///@{
#define XS1_BRK_LOAD_SHIFT 0x2
#define XS1_BRK_LOAD_SIZE 0x1
#define XS1_BRK_LOAD_MASK (((1 << XS1_BRK_LOAD_SIZE) - 1) << XS1_BRK_LOAD_SHIFT)
/**
 * Extract the BRK_LOAD bitfield from a packed word x and return it.
 */
#define XS1_BRK_LOAD(x) (((x) & XS1_BRK_LOAD_MASK) >> XS1_BRK_LOAD_SHIFT)
/**
 * Pack the value (v) of the BRK_LOAD bitfield into a packed word x and return the packed field.
 */
#define XS1_BRK_LOAD_SET(x, v) (((x) & ~XS1_BRK_LOAD_MASK) | (((v) << XS1_BRK_LOAD_SHIFT) & XS1_BRK_LOAD_MASK))
///@}
/**
 * \name BRK_THREADS
 * \anchor BRK_THREADS
 * A bit for each thread in the machine allowing the breakpoint to be enabled individually for each thread.
 */
///@{
#define XS1_BRK_THREADS_SHIFT 0x10
#define XS1_BRK_THREADS_SIZE 0x8
#define XS1_BRK_THREADS_MASK (((1 << XS1_BRK_THREADS_SIZE) - 1) << XS1_BRK_THREADS_SHIFT)
/**
 * Extract the BRK_THREADS bitfield from a packed word x and return it.
 */
#define XS1_BRK_THREADS(x) (((x) & XS1_BRK_THREADS_MASK) >> XS1_BRK_THREADS_SHIFT)
/**
 * Pack the value (v) of the BRK_THREADS bitfield into a packed word x and return the packed field.
 */
#define XS1_BRK_THREADS_SET(x, v) (((x) & ~XS1_BRK_THREADS_MASK) | (((v) << XS1_BRK_THREADS_SHIFT) & XS1_BRK_THREADS_MASK))
///@}
/**
 * \name DBG_TYPE_CAUSE
 * \anchor DBG_TYPE_CAUSE
 * Indicates the cause of the debug interrupt
 * 
 * 1: Host initiated a debug interrupt through JTAG
 * 
 * 2: Program executed a DCALL instruction
 * 
 * 3: Instruction breakpoint
 * 
 * 4: Data watch point
 * 
 * 5: Resource watch point
 */
///@{
#define XS1_DBG_TYPE_CAUSE_SHIFT 0x0
#define XS1_DBG_TYPE_CAUSE_SIZE 0x3
#define XS1_DBG_TYPE_CAUSE_MASK (((1 << XS1_DBG_TYPE_CAUSE_SIZE) - 1) << XS1_DBG_TYPE_CAUSE_SHIFT)
/**
 * Extract the DBG_TYPE_CAUSE bitfield from a packed word x and return it.
 */
#define XS1_DBG_TYPE_CAUSE(x) (((x) & XS1_DBG_TYPE_CAUSE_MASK) >> XS1_DBG_TYPE_CAUSE_SHIFT)
/**
 * Pack the value (v) of the DBG_TYPE_CAUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_TYPE_CAUSE_SET(x, v) (((x) & ~XS1_DBG_TYPE_CAUSE_MASK) | (((v) << XS1_DBG_TYPE_CAUSE_SHIFT) & XS1_DBG_TYPE_CAUSE_MASK))
///@}
/**
 * \name DBG_TYPE_T_NUM
 * \anchor DBG_TYPE_T_NUM
 * Number of thread which caused the debug interrupt (always 0 in the case of =HOST=).
 */
///@{
#define XS1_DBG_TYPE_T_NUM_SHIFT 0x8
#define XS1_DBG_TYPE_T_NUM_SIZE 0x8
#define XS1_DBG_TYPE_T_NUM_MASK (((1 << XS1_DBG_TYPE_T_NUM_SIZE) - 1) << XS1_DBG_TYPE_T_NUM_SHIFT)
/**
 * Extract the DBG_TYPE_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_DBG_TYPE_T_NUM(x) (((x) & XS1_DBG_TYPE_T_NUM_MASK) >> XS1_DBG_TYPE_T_NUM_SHIFT)
/**
 * Pack the value (v) of the DBG_TYPE_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_TYPE_T_NUM_SET(x, v) (((x) & ~XS1_DBG_TYPE_T_NUM_MASK) | (((v) << XS1_DBG_TYPE_T_NUM_SHIFT) & XS1_DBG_TYPE_T_NUM_MASK))
///@}
/**
 * \name DBG_TYPE_HW_NUM
 * \anchor DBG_TYPE_HW_NUM
 * Number of the hardware breakpoint/watchpoint which caused the interrupt (always 0 for =HOST= and =DCALL=). If multiple breakpoints/watchpoints trigger at once, the lowest number is taken.
 */
///@{
#define XS1_DBG_TYPE_HW_NUM_SHIFT 0x10
#define XS1_DBG_TYPE_HW_NUM_SIZE 0x2
#define XS1_DBG_TYPE_HW_NUM_MASK (((1 << XS1_DBG_TYPE_HW_NUM_SIZE) - 1) << XS1_DBG_TYPE_HW_NUM_SHIFT)
/**
 * Extract the DBG_TYPE_HW_NUM bitfield from a packed word x and return it.
 */
#define XS1_DBG_TYPE_HW_NUM(x) (((x) & XS1_DBG_TYPE_HW_NUM_MASK) >> XS1_DBG_TYPE_HW_NUM_SHIFT)
/**
 * Pack the value (v) of the DBG_TYPE_HW_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_TYPE_HW_NUM_SET(x, v) (((x) & ~XS1_DBG_TYPE_HW_NUM_MASK) | (((v) << XS1_DBG_TYPE_HW_NUM_SHIFT) & XS1_DBG_TYPE_HW_NUM_MASK))
///@}
/**
 * \name DBG_RUN_CTRL_STOP
 * \anchor DBG_RUN_CTRL_STOP
 * 1-hot vector defining which threads are stopped when not in debug mode. Every bit which is set prevents the respective thread from running.
 */
///@{
#define XS1_DBG_RUN_CTRL_STOP_SHIFT 0x0
#define XS1_DBG_RUN_CTRL_STOP_SIZE 0x8
#define XS1_DBG_RUN_CTRL_STOP_MASK (((1 << XS1_DBG_RUN_CTRL_STOP_SIZE) - 1) << XS1_DBG_RUN_CTRL_STOP_SHIFT)
/**
 * Extract the DBG_RUN_CTRL_STOP bitfield from a packed word x and return it.
 */
#define XS1_DBG_RUN_CTRL_STOP(x) (((x) & XS1_DBG_RUN_CTRL_STOP_MASK) >> XS1_DBG_RUN_CTRL_STOP_SHIFT)
/**
 * Pack the value (v) of the DBG_RUN_CTRL_STOP bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_RUN_CTRL_STOP_SET(x, v) (((x) & ~XS1_DBG_RUN_CTRL_STOP_MASK) | (((v) << XS1_DBG_RUN_CTRL_STOP_SHIFT) & XS1_DBG_RUN_CTRL_STOP_MASK))
///@}
/**
 * \name XCORE_CTRL0_USB_ENABLE
 * \anchor XCORE_CTRL0_USB_ENABLE
 * Enable the ULPI Hardware support module
 */
///@{
#define XS1_XCORE_CTRL0_USB_ENABLE_SHIFT 0x1
#define XS1_XCORE_CTRL0_USB_ENABLE_SIZE 0x1
#define XS1_XCORE_CTRL0_USB_ENABLE_MASK (((1 << XS1_XCORE_CTRL0_USB_ENABLE_SIZE) - 1) << XS1_XCORE_CTRL0_USB_ENABLE_SHIFT)
/**
 * Extract the XCORE_CTRL0_USB_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_USB_ENABLE(x) (((x) & XS1_XCORE_CTRL0_USB_ENABLE_MASK) >> XS1_XCORE_CTRL0_USB_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_USB_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_USB_ENABLE_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_USB_ENABLE_MASK) | (((v) << XS1_XCORE_CTRL0_USB_ENABLE_SHIFT) & XS1_XCORE_CTRL0_USB_ENABLE_MASK))
///@}
/**
 * \name XCORE_CTRL0_USB_MODE
 * \anchor XCORE_CTRL0_USB_MODE
 * Select between UTMI (1) and ULPI (0) mode.
 */
///@{
#define XS1_XCORE_CTRL0_USB_MODE_SHIFT 0x2
#define XS1_XCORE_CTRL0_USB_MODE_SIZE 0x1
#define XS1_XCORE_CTRL0_USB_MODE_MASK (((1 << XS1_XCORE_CTRL0_USB_MODE_SIZE) - 1) << XS1_XCORE_CTRL0_USB_MODE_SHIFT)
/**
 * Extract the XCORE_CTRL0_USB_MODE bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_USB_MODE(x) (((x) & XS1_XCORE_CTRL0_USB_MODE_MASK) >> XS1_XCORE_CTRL0_USB_MODE_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_USB_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_USB_MODE_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_USB_MODE_MASK) | (((v) << XS1_XCORE_CTRL0_USB_MODE_SHIFT) & XS1_XCORE_CTRL0_USB_MODE_MASK))
///@}
/**
 * \name XCORE_CTRL0_CLK_DIVIDER_EN
 * \anchor XCORE_CTRL0_CLK_DIVIDER_EN
 * Enable the clock divider.  This divides the output of the PLL to facilitate one of the low power modes.
 */
///@{
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SHIFT 0x4
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SIZE 0x1
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN_MASK (((1 << XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SIZE) - 1) << XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SHIFT)
/**
 * Extract the XCORE_CTRL0_CLK_DIVIDER_EN bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN(x) (((x) & XS1_XCORE_CTRL0_CLK_DIVIDER_EN_MASK) >> XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_CLK_DIVIDER_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_CLK_DIVIDER_EN_MASK) | (((v) << XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SHIFT) & XS1_XCORE_CTRL0_CLK_DIVIDER_EN_MASK))
///@}
/**
 * \name XCORE_CTRL0_CLK_DIVIDER_DYN
 * \anchor XCORE_CTRL0_CLK_DIVIDER_DYN
 * Select the dynamic mode (1) for the clock divider when the clock divider is enabled.  In dynamic mode the clock divider is only activated when all active threads are paused.  In static mode the clock divider is always enabled.
 */
///@{
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SHIFT 0x5
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SIZE 0x1
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_MASK (((1 << XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SIZE) - 1) << XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SHIFT)
/**
 * Extract the XCORE_CTRL0_CLK_DIVIDER_DYN bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN(x) (((x) & XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_MASK) >> XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_CLK_DIVIDER_DYN bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_MASK) | (((v) << XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SHIFT) & XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_MASK))
///@}
/**
 * \name XCORE_CTRL0_RGMII_ENABLE
 * \anchor XCORE_CTRL0_RGMII_ENABLE
 * Enable RGMII interface periph ports
 */
///@{
#define XS1_XCORE_CTRL0_RGMII_ENABLE_SHIFT 0x8
#define XS1_XCORE_CTRL0_RGMII_ENABLE_SIZE 0x1
#define XS1_XCORE_CTRL0_RGMII_ENABLE_MASK (((1 << XS1_XCORE_CTRL0_RGMII_ENABLE_SIZE) - 1) << XS1_XCORE_CTRL0_RGMII_ENABLE_SHIFT)
/**
 * Extract the XCORE_CTRL0_RGMII_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_RGMII_ENABLE(x) (((x) & XS1_XCORE_CTRL0_RGMII_ENABLE_MASK) >> XS1_XCORE_CTRL0_RGMII_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_RGMII_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_RGMII_ENABLE_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_RGMII_ENABLE_MASK) | (((v) << XS1_XCORE_CTRL0_RGMII_ENABLE_SHIFT) & XS1_XCORE_CTRL0_RGMII_ENABLE_MASK))
///@}
/**
 * \name XCORE_CTRL0_RGMII_DIVIDE
 * \anchor XCORE_CTRL0_RGMII_DIVIDE
 * RGMII TX clock divider value. TX clk rises when counter (clocked by PLL output) reaches this value and falls when counter reaches (value>>1). Value programmed into this field should be actual divide value required minus 1
 */
///@{
#define XS1_XCORE_CTRL0_RGMII_DIVIDE_SHIFT 0x9
#define XS1_XCORE_CTRL0_RGMII_DIVIDE_SIZE 0x9
#define XS1_XCORE_CTRL0_RGMII_DIVIDE_MASK (((1 << XS1_XCORE_CTRL0_RGMII_DIVIDE_SIZE) - 1) << XS1_XCORE_CTRL0_RGMII_DIVIDE_SHIFT)
/**
 * Extract the XCORE_CTRL0_RGMII_DIVIDE bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_RGMII_DIVIDE(x) (((x) & XS1_XCORE_CTRL0_RGMII_DIVIDE_MASK) >> XS1_XCORE_CTRL0_RGMII_DIVIDE_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_RGMII_DIVIDE bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_RGMII_DIVIDE_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_RGMII_DIVIDE_MASK) | (((v) << XS1_XCORE_CTRL0_RGMII_DIVIDE_SHIFT) & XS1_XCORE_CTRL0_RGMII_DIVIDE_MASK))
///@}
/**
 * \name XCORE_CTRL0_RGMII_DELAY
 * \anchor XCORE_CTRL0_RGMII_DELAY
 * RGMII TX data delay value (in PLL output cycle increments)   
 */
///@{
#define XS1_XCORE_CTRL0_RGMII_DELAY_SHIFT 0x12
#define XS1_XCORE_CTRL0_RGMII_DELAY_SIZE 0x8
#define XS1_XCORE_CTRL0_RGMII_DELAY_MASK (((1 << XS1_XCORE_CTRL0_RGMII_DELAY_SIZE) - 1) << XS1_XCORE_CTRL0_RGMII_DELAY_SHIFT)
/**
 * Extract the XCORE_CTRL0_RGMII_DELAY bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_RGMII_DELAY(x) (((x) & XS1_XCORE_CTRL0_RGMII_DELAY_MASK) >> XS1_XCORE_CTRL0_RGMII_DELAY_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_RGMII_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_RGMII_DELAY_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_RGMII_DELAY_MASK) | (((v) << XS1_XCORE_CTRL0_RGMII_DELAY_SHIFT) & XS1_XCORE_CTRL0_RGMII_DELAY_MASK))
///@}
/**
 * \name BOOT_CONFIG_PLL_MODE_PINS
 * \anchor BOOT_CONFIG_PLL_MODE_PINS
 * The boot PLL mode pin value.
 */
///@{
#define XS1_BOOT_CONFIG_PLL_MODE_PINS_SHIFT 0x0
#define XS1_BOOT_CONFIG_PLL_MODE_PINS_SIZE 0x2
#define XS1_BOOT_CONFIG_PLL_MODE_PINS_MASK (((1 << XS1_BOOT_CONFIG_PLL_MODE_PINS_SIZE) - 1) << XS1_BOOT_CONFIG_PLL_MODE_PINS_SHIFT)
/**
 * Extract the BOOT_CONFIG_PLL_MODE_PINS bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_PLL_MODE_PINS(x) (((x) & XS1_BOOT_CONFIG_PLL_MODE_PINS_MASK) >> XS1_BOOT_CONFIG_PLL_MODE_PINS_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_PLL_MODE_PINS bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_PLL_MODE_PINS_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_PLL_MODE_PINS_MASK) | (((v) << XS1_BOOT_CONFIG_PLL_MODE_PINS_SHIFT) & XS1_BOOT_CONFIG_PLL_MODE_PINS_MASK))
///@}
/**
 * \name BOOT_CONFIG_BOOT_FROM_JTAG
 * \anchor BOOT_CONFIG_BOOT_FROM_JTAG
 * Boot ROM boots from JTAG 
 */
///@{
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SHIFT 0x2
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SIZE 0x1
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG_MASK (((1 << XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SIZE) - 1) << XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SHIFT)
/**
 * Extract the BOOT_CONFIG_BOOT_FROM_JTAG bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG(x) (((x) & XS1_BOOT_CONFIG_BOOT_FROM_JTAG_MASK) >> XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_BOOT_FROM_JTAG bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_BOOT_FROM_JTAG_MASK) | (((v) << XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SHIFT) & XS1_BOOT_CONFIG_BOOT_FROM_JTAG_MASK))
///@}
/**
 * \name BOOT_CONFIG_BOOT_FROM_RAM
 * \anchor BOOT_CONFIG_BOOT_FROM_RAM
 * Boot ROM boots from RAM 
 */
///@{
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM_SHIFT 0x3
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM_SIZE 0x1
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM_MASK (((1 << XS1_BOOT_CONFIG_BOOT_FROM_RAM_SIZE) - 1) << XS1_BOOT_CONFIG_BOOT_FROM_RAM_SHIFT)
/**
 * Extract the BOOT_CONFIG_BOOT_FROM_RAM bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM(x) (((x) & XS1_BOOT_CONFIG_BOOT_FROM_RAM_MASK) >> XS1_BOOT_CONFIG_BOOT_FROM_RAM_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_BOOT_FROM_RAM bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_BOOT_FROM_RAM_MASK) | (((v) << XS1_BOOT_CONFIG_BOOT_FROM_RAM_SHIFT) & XS1_BOOT_CONFIG_BOOT_FROM_RAM_MASK))
///@}
/**
 * \name BOOT_CONFIG_DISABLE_OTP_POLL
 * \anchor BOOT_CONFIG_DISABLE_OTP_POLL
 * Cause the ROM to not poll the OTP for correct read levels
 */
///@{
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SHIFT 0x4
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SIZE 0x1
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL_MASK (((1 << XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SIZE) - 1) << XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SHIFT)
/**
 * Extract the BOOT_CONFIG_DISABLE_OTP_POLL bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL(x) (((x) & XS1_BOOT_CONFIG_DISABLE_OTP_POLL_MASK) >> XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_DISABLE_OTP_POLL bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_DISABLE_OTP_POLL_MASK) | (((v) << XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SHIFT) & XS1_BOOT_CONFIG_DISABLE_OTP_POLL_MASK))
///@}
/**
 * \name BOOT_CONFIG_CORE1_POWER_DOWN_N
 * \anchor BOOT_CONFIG_CORE1_POWER_DOWN_N
 * Indicates if core1 has been powered off 
 */
///@{
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SHIFT 0x5
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SIZE 0x1
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_MASK (((1 << XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SIZE) - 1) << XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SHIFT)
/**
 * Extract the BOOT_CONFIG_CORE1_POWER_DOWN_N bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N(x) (((x) & XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_MASK) >> XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_CORE1_POWER_DOWN_N bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_MASK) | (((v) << XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SHIFT) & XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_MASK))
///@}
/**
 * \name BOOT_CONFIG_SECURE_BOOT
 * \anchor BOOT_CONFIG_SECURE_BOOT
 * Overwrite BOOT_MODE.
 */
///@{
#define XS1_BOOT_CONFIG_SECURE_BOOT_SHIFT 0x8
#define XS1_BOOT_CONFIG_SECURE_BOOT_SIZE 0x1
#define XS1_BOOT_CONFIG_SECURE_BOOT_MASK (((1 << XS1_BOOT_CONFIG_SECURE_BOOT_SIZE) - 1) << XS1_BOOT_CONFIG_SECURE_BOOT_SHIFT)
/**
 * Extract the BOOT_CONFIG_SECURE_BOOT bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_SECURE_BOOT(x) (((x) & XS1_BOOT_CONFIG_SECURE_BOOT_MASK) >> XS1_BOOT_CONFIG_SECURE_BOOT_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_SECURE_BOOT bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_SECURE_BOOT_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_SECURE_BOOT_MASK) | (((v) << XS1_BOOT_CONFIG_SECURE_BOOT_SHIFT) & XS1_BOOT_CONFIG_SECURE_BOOT_MASK))
///@}
/**
 * \name BOOT_CONFIG_PROCESSOR
 * \anchor BOOT_CONFIG_PROCESSOR
 * Processor number.
 */
///@{
#define XS1_BOOT_CONFIG_PROCESSOR_SHIFT 0x10
#define XS1_BOOT_CONFIG_PROCESSOR_SIZE 0x8
#define XS1_BOOT_CONFIG_PROCESSOR_MASK (((1 << XS1_BOOT_CONFIG_PROCESSOR_SIZE) - 1) << XS1_BOOT_CONFIG_PROCESSOR_SHIFT)
/**
 * Extract the BOOT_CONFIG_PROCESSOR bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_PROCESSOR(x) (((x) & XS1_BOOT_CONFIG_PROCESSOR_MASK) >> XS1_BOOT_CONFIG_PROCESSOR_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_PROCESSOR bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_PROCESSOR_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_PROCESSOR_MASK) | (((v) << XS1_BOOT_CONFIG_PROCESSOR_SHIFT) & XS1_BOOT_CONFIG_PROCESSOR_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_XCORE_JTAG
 * \anchor SECUR_CFG_DISABLE_XCORE_JTAG
 * Disable access to XCore's JTAG debug TAP 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SHIFT 0x0
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG_MASK (((1 << XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_XCORE_JTAG bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG(x) (((x) & XS1_SECUR_CFG_DISABLE_XCORE_JTAG_MASK) >> XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_XCORE_JTAG bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_XCORE_JTAG_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SHIFT) & XS1_SECUR_CFG_DISABLE_XCORE_JTAG_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_XCORE_PLINK
 * \anchor SECUR_CFG_DISABLE_XCORE_PLINK
 * Disable PLinks 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SHIFT 0x1
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK_MASK (((1 << XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_XCORE_PLINK bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK(x) (((x) & XS1_SECUR_CFG_DISABLE_XCORE_PLINK_MASK) >> XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_XCORE_PLINK bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_XCORE_PLINK_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SHIFT) & XS1_SECUR_CFG_DISABLE_XCORE_PLINK_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_PLL_JTAG
 * \anchor SECUR_CFG_DISABLE_PLL_JTAG
 * Disable JTAG access to the PLL/BOOT configuration registers 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG_SHIFT 0x4
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG_MASK (((1 << XS1_SECUR_CFG_DISABLE_PLL_JTAG_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_PLL_JTAG_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_PLL_JTAG bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG(x) (((x) & XS1_SECUR_CFG_DISABLE_PLL_JTAG_MASK) >> XS1_SECUR_CFG_DISABLE_PLL_JTAG_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_PLL_JTAG bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_PLL_JTAG_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_PLL_JTAG_SHIFT) & XS1_SECUR_CFG_DISABLE_PLL_JTAG_MASK))
///@}
/**
 * \name SECUR_CFG_SECURE_BOOT
 * \anchor SECUR_CFG_SECURE_BOOT
 * Override boot mode and read boot image from OTP 
 */
///@{
#define XS1_SECUR_CFG_SECURE_BOOT_SHIFT 0x5
#define XS1_SECUR_CFG_SECURE_BOOT_SIZE 0x1
#define XS1_SECUR_CFG_SECURE_BOOT_MASK (((1 << XS1_SECUR_CFG_SECURE_BOOT_SIZE) - 1) << XS1_SECUR_CFG_SECURE_BOOT_SHIFT)
/**
 * Extract the SECUR_CFG_SECURE_BOOT bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_SECURE_BOOT(x) (((x) & XS1_SECUR_CFG_SECURE_BOOT_MASK) >> XS1_SECUR_CFG_SECURE_BOOT_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_SECURE_BOOT bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_SECURE_BOOT_SET(x, v) (((x) & ~XS1_SECUR_CFG_SECURE_BOOT_MASK) | (((v) << XS1_SECUR_CFG_SECURE_BOOT_SHIFT) & XS1_SECUR_CFG_SECURE_BOOT_MASK))
///@}
/**
 * \name SECUR_CFG_OTP_REDUANACY_ENABLE
 * \anchor SECUR_CFG_OTP_REDUANACY_ENABLE
 * Enable OTP reduanacy 
 */
///@{
#define XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_SHIFT 0x7
#define XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_SIZE 0x1
#define XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_MASK (((1 << XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_SIZE) - 1) << XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_SHIFT)
/**
 * Extract the SECUR_CFG_OTP_REDUANACY_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_OTP_REDUANACY_ENABLE(x) (((x) & XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_MASK) >> XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_OTP_REDUANACY_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_SET(x, v) (((x) & ~XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_MASK) | (((v) << XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_SHIFT) & XS1_SECUR_CFG_OTP_REDUANACY_ENABLE_MASK))
///@}
/**
 * \name SECUR_CFG_OTP_SECTOR_LOCK
 * \anchor SECUR_CFG_OTP_SECTOR_LOCK
 * lock bit for each OTP sector 
 */
///@{
#define XS1_SECUR_CFG_OTP_SECTOR_LOCK_SHIFT 0x8
#define XS1_SECUR_CFG_OTP_SECTOR_LOCK_SIZE 0x4
#define XS1_SECUR_CFG_OTP_SECTOR_LOCK_MASK (((1 << XS1_SECUR_CFG_OTP_SECTOR_LOCK_SIZE) - 1) << XS1_SECUR_CFG_OTP_SECTOR_LOCK_SHIFT)
/**
 * Extract the SECUR_CFG_OTP_SECTOR_LOCK bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_OTP_SECTOR_LOCK(x) (((x) & XS1_SECUR_CFG_OTP_SECTOR_LOCK_MASK) >> XS1_SECUR_CFG_OTP_SECTOR_LOCK_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_OTP_SECTOR_LOCK bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_OTP_SECTOR_LOCK_SET(x, v) (((x) & ~XS1_SECUR_CFG_OTP_SECTOR_LOCK_MASK) | (((v) << XS1_SECUR_CFG_OTP_SECTOR_LOCK_SHIFT) & XS1_SECUR_CFG_OTP_SECTOR_LOCK_MASK))
///@}
/**
 * \name SECUR_CFG_OTP_MASTER_LOCK
 * \anchor SECUR_CFG_OTP_MASTER_LOCK
 * lock all OTP sectors 
 */
///@{
#define XS1_SECUR_CFG_OTP_MASTER_LOCK_SHIFT 0xc
#define XS1_SECUR_CFG_OTP_MASTER_LOCK_SIZE 0x1
#define XS1_SECUR_CFG_OTP_MASTER_LOCK_MASK (((1 << XS1_SECUR_CFG_OTP_MASTER_LOCK_SIZE) - 1) << XS1_SECUR_CFG_OTP_MASTER_LOCK_SHIFT)
/**
 * Extract the SECUR_CFG_OTP_MASTER_LOCK bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_OTP_MASTER_LOCK(x) (((x) & XS1_SECUR_CFG_OTP_MASTER_LOCK_MASK) >> XS1_SECUR_CFG_OTP_MASTER_LOCK_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_OTP_MASTER_LOCK bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_OTP_MASTER_LOCK_SET(x, v) (((x) & ~XS1_SECUR_CFG_OTP_MASTER_LOCK_MASK) | (((v) << XS1_SECUR_CFG_OTP_MASTER_LOCK_SHIFT) & XS1_SECUR_CFG_OTP_MASTER_LOCK_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_GLOBAL_DEBUG
 * \anchor SECUR_CFG_DISABLE_GLOBAL_DEBUG
 * Disable access to XCore's global debug 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SHIFT 0xe
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_MASK (((1 << XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_GLOBAL_DEBUG bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG(x) (((x) & XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_MASK) >> XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_GLOBAL_DEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SHIFT) & XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_ACCESS
 * \anchor SECUR_CFG_DISABLE_ACCESS
 * Disables write permission on this register 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_ACCESS_SHIFT 0x1f
#define XS1_SECUR_CFG_DISABLE_ACCESS_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_ACCESS_MASK (((1 << XS1_SECUR_CFG_DISABLE_ACCESS_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_ACCESS_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_ACCESS bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_ACCESS(x) (((x) & XS1_SECUR_CFG_DISABLE_ACCESS_MASK) >> XS1_SECUR_CFG_DISABLE_ACCESS_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_ACCESS bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_ACCESS_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_ACCESS_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_ACCESS_SHIFT) & XS1_SECUR_CFG_DISABLE_ACCESS_MASK))
///@}
/**
 * \name BOOT_STATUS_LEDS
 * \anchor BOOT_STATUS_LEDS
 * Boot status LED value.
 */
///@{
#define XS1_BOOT_STATUS_LEDS_SHIFT 0x0
#define XS1_BOOT_STATUS_LEDS_SIZE 0x4
#define XS1_BOOT_STATUS_LEDS_MASK (((1 << XS1_BOOT_STATUS_LEDS_SIZE) - 1) << XS1_BOOT_STATUS_LEDS_SHIFT)
/**
 * Extract the BOOT_STATUS_LEDS bitfield from a packed word x and return it.
 */
#define XS1_BOOT_STATUS_LEDS(x) (((x) & XS1_BOOT_STATUS_LEDS_MASK) >> XS1_BOOT_STATUS_LEDS_SHIFT)
/**
 * Pack the value (v) of the BOOT_STATUS_LEDS bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_STATUS_LEDS_SET(x, v) (((x) & ~XS1_BOOT_STATUS_LEDS_MASK) | (((v) << XS1_BOOT_STATUS_LEDS_SHIFT) & XS1_BOOT_STATUS_LEDS_MASK))
///@}
/**
 * \name BOOT_STATUS_BITS
 * \anchor BOOT_STATUS_BITS
 * Other boot status LED bits.
 */
///@{
#define XS1_BOOT_STATUS_BITS_SHIFT 0x4
#define XS1_BOOT_STATUS_BITS_SIZE 0x1c
#define XS1_BOOT_STATUS_BITS_MASK (((1 << XS1_BOOT_STATUS_BITS_SIZE) - 1) << XS1_BOOT_STATUS_BITS_SHIFT)
/**
 * Extract the BOOT_STATUS_BITS bitfield from a packed word x and return it.
 */
#define XS1_BOOT_STATUS_BITS(x) (((x) & XS1_BOOT_STATUS_BITS_MASK) >> XS1_BOOT_STATUS_BITS_SHIFT)
/**
 * Pack the value (v) of the BOOT_STATUS_BITS bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_STATUS_BITS_SET(x, v) (((x) & ~XS1_BOOT_STATUS_BITS_MASK) | (((v) << XS1_BOOT_STATUS_BITS_SHIFT) & XS1_BOOT_STATUS_BITS_MASK))
///@}
/**
 * \name RING_OSC_PERPH_ENABLE
 * \anchor RING_OSC_PERPH_ENABLE
 * Peripheral ring oscillator enable.
 */
///@{
#define XS1_RING_OSC_PERPH_ENABLE_SHIFT 0x0
#define XS1_RING_OSC_PERPH_ENABLE_SIZE 0x1
#define XS1_RING_OSC_PERPH_ENABLE_MASK (((1 << XS1_RING_OSC_PERPH_ENABLE_SIZE) - 1) << XS1_RING_OSC_PERPH_ENABLE_SHIFT)
/**
 * Extract the RING_OSC_PERPH_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_RING_OSC_PERPH_ENABLE(x) (((x) & XS1_RING_OSC_PERPH_ENABLE_MASK) >> XS1_RING_OSC_PERPH_ENABLE_SHIFT)
/**
 * Pack the value (v) of the RING_OSC_PERPH_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_RING_OSC_PERPH_ENABLE_SET(x, v) (((x) & ~XS1_RING_OSC_PERPH_ENABLE_MASK) | (((v) << XS1_RING_OSC_PERPH_ENABLE_SHIFT) & XS1_RING_OSC_PERPH_ENABLE_MASK))
///@}
/**
 * \name RING_OSC_CORE_ENABLE
 * \anchor RING_OSC_CORE_ENABLE
 * Core ring oscillator enable.
 */
///@{
#define XS1_RING_OSC_CORE_ENABLE_SHIFT 0x1
#define XS1_RING_OSC_CORE_ENABLE_SIZE 0x1
#define XS1_RING_OSC_CORE_ENABLE_MASK (((1 << XS1_RING_OSC_CORE_ENABLE_SIZE) - 1) << XS1_RING_OSC_CORE_ENABLE_SHIFT)
/**
 * Extract the RING_OSC_CORE_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_RING_OSC_CORE_ENABLE(x) (((x) & XS1_RING_OSC_CORE_ENABLE_MASK) >> XS1_RING_OSC_CORE_ENABLE_SHIFT)
/**
 * Pack the value (v) of the RING_OSC_CORE_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_RING_OSC_CORE_ENABLE_SET(x, v) (((x) & ~XS1_RING_OSC_CORE_ENABLE_MASK) | (((v) << XS1_RING_OSC_CORE_ENABLE_SHIFT) & XS1_RING_OSC_CORE_ENABLE_MASK))
///@}
/**
 * \name RING_OSC_DATA
 * \anchor RING_OSC_DATA
 * Ring oscillator Counter data.
 */
///@{
#define XS1_RING_OSC_DATA_SHIFT 0x0
#define XS1_RING_OSC_DATA_SIZE 0x10
#define XS1_RING_OSC_DATA_MASK (((1 << XS1_RING_OSC_DATA_SIZE) - 1) << XS1_RING_OSC_DATA_SHIFT)
/**
 * Extract the RING_OSC_DATA bitfield from a packed word x and return it.
 */
#define XS1_RING_OSC_DATA(x) (((x) & XS1_RING_OSC_DATA_MASK) >> XS1_RING_OSC_DATA_SHIFT)
/**
 * Pack the value (v) of the RING_OSC_DATA bitfield into a packed word x and return the packed field.
 */
#define XS1_RING_OSC_DATA_SET(x, v) (((x) & ~XS1_RING_OSC_DATA_MASK) | (((v) << XS1_RING_OSC_DATA_SHIFT) & XS1_RING_OSC_DATA_MASK))
///@}
/**
 * \name PLL_CLK_DIVIDER
 * \anchor PLL_CLK_DIVIDER
 * Clock divider.
 */
///@{
#define XS1_PLL_CLK_DIVIDER_SHIFT 0x0
#define XS1_PLL_CLK_DIVIDER_SIZE 0x10
#define XS1_PLL_CLK_DIVIDER_MASK (((1 << XS1_PLL_CLK_DIVIDER_SIZE) - 1) << XS1_PLL_CLK_DIVIDER_SHIFT)
/**
 * Extract the PLL_CLK_DIVIDER bitfield from a packed word x and return it.
 */
#define XS1_PLL_CLK_DIVIDER(x) (((x) & XS1_PLL_CLK_DIVIDER_MASK) >> XS1_PLL_CLK_DIVIDER_SHIFT)
/**
 * Pack the value (v) of the PLL_CLK_DIVIDER bitfield into a packed word x and return the packed field.
 */
#define XS1_PLL_CLK_DIVIDER_SET(x, v) (((x) & ~XS1_PLL_CLK_DIVIDER_MASK) | (((v) << XS1_PLL_CLK_DIVIDER_SHIFT) & XS1_PLL_CLK_DIVIDER_MASK))
///@}
/**
 * \name PLL_CLK_DISABLE
 * \anchor PLL_CLK_DISABLE
 * Clock disable. Writing '1' will remove the clock to the tile.
 */
///@{
#define XS1_PLL_CLK_DISABLE_SHIFT 0x1f
#define XS1_PLL_CLK_DISABLE_SIZE 0x1
#define XS1_PLL_CLK_DISABLE_MASK (((1 << XS1_PLL_CLK_DISABLE_SIZE) - 1) << XS1_PLL_CLK_DISABLE_SHIFT)
/**
 * Extract the PLL_CLK_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_PLL_CLK_DISABLE(x) (((x) & XS1_PLL_CLK_DISABLE_MASK) >> XS1_PLL_CLK_DISABLE_SHIFT)
/**
 * Pack the value (v) of the PLL_CLK_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_PLL_CLK_DISABLE_SET(x, v) (((x) & ~XS1_PLL_CLK_DISABLE_MASK) | (((v) << XS1_PLL_CLK_DISABLE_SHIFT) & XS1_PLL_CLK_DISABLE_MASK))
///@}
/**
 * \name RMA0
 * \anchor RMA0
 * Read margin adjust.
 */
///@{
#define XS1_RMA0_SHIFT 0x0
#define XS1_RMA0_SIZE 0x4
#define XS1_RMA0_MASK (((1 << XS1_RMA0_SIZE) - 1) << XS1_RMA0_SHIFT)
/**
 * Extract the RMA0 bitfield from a packed word x and return it.
 */
#define XS1_RMA0(x) (((x) & XS1_RMA0_MASK) >> XS1_RMA0_SHIFT)
/**
 * Pack the value (v) of the RMA0 bitfield into a packed word x and return the packed field.
 */
#define XS1_RMA0_SET(x, v) (((x) & ~XS1_RMA0_MASK) | (((v) << XS1_RMA0_SHIFT) & XS1_RMA0_MASK))
///@}
/**
 * \name RMA1
 * \anchor RMA1
 * Read margin adjust.
 */
///@{
#define XS1_RMA1_SHIFT 0x4
#define XS1_RMA1_SIZE 0x4
#define XS1_RMA1_MASK (((1 << XS1_RMA1_SIZE) - 1) << XS1_RMA1_SHIFT)
/**
 * Extract the RMA1 bitfield from a packed word x and return it.
 */
#define XS1_RMA1(x) (((x) & XS1_RMA1_MASK) >> XS1_RMA1_SHIFT)
/**
 * Pack the value (v) of the RMA1 bitfield into a packed word x and return the packed field.
 */
#define XS1_RMA1_SET(x, v) (((x) & ~XS1_RMA1_MASK) | (((v) << XS1_RMA1_SHIFT) & XS1_RMA1_MASK))
///@}
/**
 * \name RMA2
 * \anchor RMA2
 * Read margin adjust.
 */
///@{
#define XS1_RMA2_SHIFT 0x8
#define XS1_RMA2_SIZE 0x4
#define XS1_RMA2_MASK (((1 << XS1_RMA2_SIZE) - 1) << XS1_RMA2_SHIFT)
/**
 * Extract the RMA2 bitfield from a packed word x and return it.
 */
#define XS1_RMA2(x) (((x) & XS1_RMA2_MASK) >> XS1_RMA2_SHIFT)
/**
 * Pack the value (v) of the RMA2 bitfield into a packed word x and return the packed field.
 */
#define XS1_RMA2_SET(x, v) (((x) & ~XS1_RMA2_MASK) | (((v) << XS1_RMA2_SHIFT) & XS1_RMA2_MASK))
///@}
/**
 * \name RMA3
 * \anchor RMA3
 * Read margin adjust.
 */
///@{
#define XS1_RMA3_SHIFT 0xc
#define XS1_RMA3_SIZE 0x4
#define XS1_RMA3_MASK (((1 << XS1_RMA3_SIZE) - 1) << XS1_RMA3_SHIFT)
/**
 * Extract the RMA3 bitfield from a packed word x and return it.
 */
#define XS1_RMA3(x) (((x) & XS1_RMA3_MASK) >> XS1_RMA3_SHIFT)
/**
 * Pack the value (v) of the RMA3 bitfield into a packed word x and return the packed field.
 */
#define XS1_RMA3_SET(x, v) (((x) & ~XS1_RMA3_MASK) | (((v) << XS1_RMA3_SHIFT) & XS1_RMA3_MASK))
///@}
/**
 * \name RAM_MASK
 * \anchor RAM_MASK
 * Blocks of 64k rams unavailable
 */
///@{
#define XS1_RAM_MASK_SHIFT 0x0
#define XS1_RAM_MASK_SIZE 0x2
#define XS1_RAM_MASK_MASK (((1 << XS1_RAM_MASK_SIZE) - 1) << XS1_RAM_MASK_SHIFT)
/**
 * Extract the RAM_MASK bitfield from a packed word x and return it.
 */
#define XS1_RAM_MASK(x) (((x) & XS1_RAM_MASK_MASK) >> XS1_RAM_MASK_SHIFT)
/**
 * Pack the value (v) of the RAM_MASK bitfield into a packed word x and return the packed field.
 */
#define XS1_RAM_MASK_SET(x, v) (((x) & ~XS1_RAM_MASK_MASK) | (((v) << XS1_RAM_MASK_SHIFT) & XS1_RAM_MASK_MASK))
///@}
/**
 * \name CORE_DISABLE
 * \anchor CORE_DISABLE
 * Core's clock is gated off 
 */
///@{
#define XS1_CORE_DISABLE_SHIFT 0x8
#define XS1_CORE_DISABLE_SIZE 0x1
#define XS1_CORE_DISABLE_MASK (((1 << XS1_CORE_DISABLE_SIZE) - 1) << XS1_CORE_DISABLE_SHIFT)
/**
 * Extract the CORE_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_CORE_DISABLE(x) (((x) & XS1_CORE_DISABLE_MASK) >> XS1_CORE_DISABLE_SHIFT)
/**
 * Pack the value (v) of the CORE_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_CORE_DISABLE_SET(x, v) (((x) & ~XS1_CORE_DISABLE_MASK) | (((v) << XS1_CORE_DISABLE_SHIFT) & XS1_CORE_DISABLE_MASK))
///@}
/**
 * \name THREAD_MASK
 * \anchor THREAD_MASK
 * Threads unavailable
 */
///@{
#define XS1_THREAD_MASK_SHIFT 0x9
#define XS1_THREAD_MASK_SIZE 0x7
#define XS1_THREAD_MASK_MASK (((1 << XS1_THREAD_MASK_SIZE) - 1) << XS1_THREAD_MASK_SHIFT)
/**
 * Extract the THREAD_MASK bitfield from a packed word x and return it.
 */
#define XS1_THREAD_MASK(x) (((x) & XS1_THREAD_MASK_MASK) >> XS1_THREAD_MASK_SHIFT)
/**
 * Pack the value (v) of the THREAD_MASK bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_MASK_SET(x, v) (((x) & ~XS1_THREAD_MASK_MASK) | (((v) << XS1_THREAD_MASK_SHIFT) & XS1_THREAD_MASK_MASK))
///@}
/**
 * \name RGMII_DISABLE
 * \anchor RGMII_DISABLE
 * RGMII accelerator disable 
 */
///@{
#define XS1_RGMII_DISABLE_SHIFT 0x18
#define XS1_RGMII_DISABLE_SIZE 0x1
#define XS1_RGMII_DISABLE_MASK (((1 << XS1_RGMII_DISABLE_SIZE) - 1) << XS1_RGMII_DISABLE_SHIFT)
/**
 * Extract the RGMII_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_RGMII_DISABLE(x) (((x) & XS1_RGMII_DISABLE_MASK) >> XS1_RGMII_DISABLE_SHIFT)
/**
 * Pack the value (v) of the RGMII_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_RGMII_DISABLE_SET(x, v) (((x) & ~XS1_RGMII_DISABLE_MASK) | (((v) << XS1_RGMII_DISABLE_SHIFT) & XS1_RGMII_DISABLE_MASK))
///@}
/**
 * \name THREAD_CTRL0_INUSE
 * \anchor THREAD_CTRL0_INUSE
 * Returns 1 when the thread is in use, 0 otherwise.
 */
///@{
#define XS1_THREAD_CTRL0_INUSE_SHIFT 0x0
#define XS1_THREAD_CTRL0_INUSE_SIZE 0x1
#define XS1_THREAD_CTRL0_INUSE_MASK (((1 << XS1_THREAD_CTRL0_INUSE_SIZE) - 1) << XS1_THREAD_CTRL0_INUSE_SHIFT)
/**
 * Extract the THREAD_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_THREAD_CTRL0_INUSE(x) (((x) & XS1_THREAD_CTRL0_INUSE_MASK) >> XS1_THREAD_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the THREAD_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_THREAD_CTRL0_INUSE_MASK) | (((v) << XS1_THREAD_CTRL0_INUSE_SHIFT) & XS1_THREAD_CTRL0_INUSE_MASK))
///@}
/**
 * \name THREAD_CTRL0_MSYNC
 * \anchor THREAD_CTRL0_MSYNC
 * 1 when the thread is msyncing, 0 otherwise.
 */
///@{
#define XS1_THREAD_CTRL0_MSYNC_SHIFT 0x1
#define XS1_THREAD_CTRL0_MSYNC_SIZE 0x1
#define XS1_THREAD_CTRL0_MSYNC_MASK (((1 << XS1_THREAD_CTRL0_MSYNC_SIZE) - 1) << XS1_THREAD_CTRL0_MSYNC_SHIFT)
/**
 * Extract the THREAD_CTRL0_MSYNC bitfield from a packed word x and return it.
 */
#define XS1_THREAD_CTRL0_MSYNC(x) (((x) & XS1_THREAD_CTRL0_MSYNC_MASK) >> XS1_THREAD_CTRL0_MSYNC_SHIFT)
/**
 * Pack the value (v) of the THREAD_CTRL0_MSYNC bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_CTRL0_MSYNC_SET(x, v) (((x) & ~XS1_THREAD_CTRL0_MSYNC_MASK) | (((v) << XS1_THREAD_CTRL0_MSYNC_SHIFT) & XS1_THREAD_CTRL0_MSYNC_MASK))
///@}
/**
 * \name THREAD_CTRL0_SSYNC
 * \anchor THREAD_CTRL0_SSYNC
 * 1 when the thread is ssyncing, 0 otherwise.
 */
///@{
#define XS1_THREAD_CTRL0_SSYNC_SHIFT 0x2
#define XS1_THREAD_CTRL0_SSYNC_SIZE 0x1
#define XS1_THREAD_CTRL0_SSYNC_MASK (((1 << XS1_THREAD_CTRL0_SSYNC_SIZE) - 1) << XS1_THREAD_CTRL0_SSYNC_SHIFT)
/**
 * Extract the THREAD_CTRL0_SSYNC bitfield from a packed word x and return it.
 */
#define XS1_THREAD_CTRL0_SSYNC(x) (((x) & XS1_THREAD_CTRL0_SSYNC_MASK) >> XS1_THREAD_CTRL0_SSYNC_SHIFT)
/**
 * Pack the value (v) of the THREAD_CTRL0_SSYNC bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_CTRL0_SSYNC_SET(x, v) (((x) & ~XS1_THREAD_CTRL0_SSYNC_MASK) | (((v) << XS1_THREAD_CTRL0_SSYNC_SHIFT) & XS1_THREAD_CTRL0_SSYNC_MASK))
///@}
/**
 * \name THREAD_CTRL0_MASTER
 * \anchor THREAD_CTRL0_MASTER
 * Returns the ID of this thread's master.
 */
///@{
#define XS1_THREAD_CTRL0_MASTER_SHIFT 0x8
#define XS1_THREAD_CTRL0_MASTER_SIZE 0x8
#define XS1_THREAD_CTRL0_MASTER_MASK (((1 << XS1_THREAD_CTRL0_MASTER_SIZE) - 1) << XS1_THREAD_CTRL0_MASTER_SHIFT)
/**
 * Extract the THREAD_CTRL0_MASTER bitfield from a packed word x and return it.
 */
#define XS1_THREAD_CTRL0_MASTER(x) (((x) & XS1_THREAD_CTRL0_MASTER_MASK) >> XS1_THREAD_CTRL0_MASTER_SHIFT)
/**
 * Pack the value (v) of the THREAD_CTRL0_MASTER bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_CTRL0_MASTER_SET(x, v) (((x) & ~XS1_THREAD_CTRL0_MASTER_MASK) | (((v) << XS1_THREAD_CTRL0_MASTER_SHIFT) & XS1_THREAD_CTRL0_MASTER_MASK))
///@}
/**
 * \name PORT_CTRL0_INUSE
 * \anchor PORT_CTRL0_INUSE
 * Returns 1 when the port is in use, 0 otherwise.
 */
///@{
#define XS1_PORT_CTRL0_INUSE_SHIFT 0x0
#define XS1_PORT_CTRL0_INUSE_SIZE 0x1
#define XS1_PORT_CTRL0_INUSE_MASK (((1 << XS1_PORT_CTRL0_INUSE_SIZE) - 1) << XS1_PORT_CTRL0_INUSE_SHIFT)
/**
 * Extract the PORT_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_INUSE(x) (((x) & XS1_PORT_CTRL0_INUSE_MASK) >> XS1_PORT_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_INUSE_MASK) | (((v) << XS1_PORT_CTRL0_INUSE_SHIFT) & XS1_PORT_CTRL0_INUSE_MASK))
///@}
/**
 * \name PORT_CTRL0_IE_MODE
 * \anchor PORT_CTRL0_IE_MODE
 * 0 when this port will cause events, 1 when it will raise interrupts. It is controlled using the ``SETC`` instruction.
 */
///@{
#define XS1_PORT_CTRL0_IE_MODE_SHIFT 0x1
#define XS1_PORT_CTRL0_IE_MODE_SIZE 0x1
#define XS1_PORT_CTRL0_IE_MODE_MASK (((1 << XS1_PORT_CTRL0_IE_MODE_SIZE) - 1) << XS1_PORT_CTRL0_IE_MODE_SHIFT)
/**
 * Extract the PORT_CTRL0_IE_MODE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_IE_MODE(x) (((x) & XS1_PORT_CTRL0_IE_MODE_MASK) >> XS1_PORT_CTRL0_IE_MODE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_IE_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_IE_MODE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_IE_MODE_MASK) | (((v) << XS1_PORT_CTRL0_IE_MODE_SHIFT) & XS1_PORT_CTRL0_IE_MODE_MASK))
///@}
/**
 * \name PORT_CTRL0_IE_ENABLED
 * \anchor PORT_CTRL0_IE_ENABLED
 * 1 when events or interrupts on this port are active. It is set when an  ``EEU`` is executed. It is cleared when a ``EDU`` or ``CLRE`` is executed. The ``EET`` and ``EEF`` will either set or clear the bit depending on the contents of the condition register.
 */
///@{
#define XS1_PORT_CTRL0_IE_ENABLED_SHIFT 0x2
#define XS1_PORT_CTRL0_IE_ENABLED_SIZE 0x1
#define XS1_PORT_CTRL0_IE_ENABLED_MASK (((1 << XS1_PORT_CTRL0_IE_ENABLED_SIZE) - 1) << XS1_PORT_CTRL0_IE_ENABLED_SHIFT)
/**
 * Extract the PORT_CTRL0_IE_ENABLED bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_IE_ENABLED(x) (((x) & XS1_PORT_CTRL0_IE_ENABLED_MASK) >> XS1_PORT_CTRL0_IE_ENABLED_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_IE_ENABLED bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_IE_ENABLED_SET(x, v) (((x) & ~XS1_PORT_CTRL0_IE_ENABLED_MASK) | (((v) << XS1_PORT_CTRL0_IE_ENABLED_SHIFT) & XS1_PORT_CTRL0_IE_ENABLED_MASK))
///@}
/**
 * \name PORT_CTRL0_DIRECTION
 * \anchor PORT_CTRL0_DIRECTION
 * 0 when it is in input mode, 1 when this port is in output mode.
 */
///@{
#define XS1_PORT_CTRL0_DIRECTION_SHIFT 0x3
#define XS1_PORT_CTRL0_DIRECTION_SIZE 0x1
#define XS1_PORT_CTRL0_DIRECTION_MASK (((1 << XS1_PORT_CTRL0_DIRECTION_SIZE) - 1) << XS1_PORT_CTRL0_DIRECTION_SHIFT)
/**
 * Extract the PORT_CTRL0_DIRECTION bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_DIRECTION(x) (((x) & XS1_PORT_CTRL0_DIRECTION_MASK) >> XS1_PORT_CTRL0_DIRECTION_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_DIRECTION bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_DIRECTION_SET(x, v) (((x) & ~XS1_PORT_CTRL0_DIRECTION_MASK) | (((v) << XS1_PORT_CTRL0_DIRECTION_SHIFT) & XS1_PORT_CTRL0_DIRECTION_MASK))
///@}
/**
 * \name PORT_CTRL0_COND
 * \anchor PORT_CTRL0_COND
 * Shows the current condition of the port. The condition is set using the ``SETC`` instruction.
 */
///@{
#define XS1_PORT_CTRL0_COND_SHIFT 0x4
#define XS1_PORT_CTRL0_COND_SIZE 0x4
#define XS1_PORT_CTRL0_COND_MASK (((1 << XS1_PORT_CTRL0_COND_SIZE) - 1) << XS1_PORT_CTRL0_COND_SHIFT)
/**
 * Extract the PORT_CTRL0_COND bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_COND(x) (((x) & XS1_PORT_CTRL0_COND_MASK) >> XS1_PORT_CTRL0_COND_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_COND bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_COND_SET(x, v) (((x) & ~XS1_PORT_CTRL0_COND_MASK) | (((v) << XS1_PORT_CTRL0_COND_SHIFT) & XS1_PORT_CTRL0_COND_MASK))
///@}
/**
 * \name PORT_CTRL0_MASTER_SLAVE
 * \anchor PORT_CTRL0_MASTER_SLAVE
 * 0 when the port is a master, 1 when it is a slave.
 */
///@{
#define XS1_PORT_CTRL0_MASTER_SLAVE_SHIFT 0x8
#define XS1_PORT_CTRL0_MASTER_SLAVE_SIZE 0x1
#define XS1_PORT_CTRL0_MASTER_SLAVE_MASK (((1 << XS1_PORT_CTRL0_MASTER_SLAVE_SIZE) - 1) << XS1_PORT_CTRL0_MASTER_SLAVE_SHIFT)
/**
 * Extract the PORT_CTRL0_MASTER_SLAVE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_MASTER_SLAVE(x) (((x) & XS1_PORT_CTRL0_MASTER_SLAVE_MASK) >> XS1_PORT_CTRL0_MASTER_SLAVE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_MASTER_SLAVE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_MASTER_SLAVE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_MASTER_SLAVE_MASK) | (((v) << XS1_PORT_CTRL0_MASTER_SLAVE_SHIFT) & XS1_PORT_CTRL0_MASTER_SLAVE_MASK))
///@}
/**
 * \name PORT_CTRL0_BUFFERS
 * \anchor PORT_CTRL0_BUFFERS
 * When 0 there is no buffering between the port and pins. When 1 there is buffering between the port and instructions.
 */
///@{
#define XS1_PORT_CTRL0_BUFFERS_SHIFT 0x9
#define XS1_PORT_CTRL0_BUFFERS_SIZE 0x1
#define XS1_PORT_CTRL0_BUFFERS_MASK (((1 << XS1_PORT_CTRL0_BUFFERS_SIZE) - 1) << XS1_PORT_CTRL0_BUFFERS_SHIFT)
/**
 * Extract the PORT_CTRL0_BUFFERS bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_BUFFERS(x) (((x) & XS1_PORT_CTRL0_BUFFERS_MASK) >> XS1_PORT_CTRL0_BUFFERS_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_BUFFERS bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_BUFFERS_SET(x, v) (((x) & ~XS1_PORT_CTRL0_BUFFERS_MASK) | (((v) << XS1_PORT_CTRL0_BUFFERS_SHIFT) & XS1_PORT_CTRL0_BUFFERS_MASK))
///@}
/**
 * \name PORT_CTRL0_READY_MODE
 * \anchor PORT_CTRL0_READY_MODE
 * 0 - no ready signals used, 1 - strobed port, 2 - handshaken port
 */
///@{
#define XS1_PORT_CTRL0_READY_MODE_SHIFT 0xa
#define XS1_PORT_CTRL0_READY_MODE_SIZE 0x2
#define XS1_PORT_CTRL0_READY_MODE_MASK (((1 << XS1_PORT_CTRL0_READY_MODE_SIZE) - 1) << XS1_PORT_CTRL0_READY_MODE_SHIFT)
/**
 * Extract the PORT_CTRL0_READY_MODE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_READY_MODE(x) (((x) & XS1_PORT_CTRL0_READY_MODE_MASK) >> XS1_PORT_CTRL0_READY_MODE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_READY_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_READY_MODE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_READY_MODE_MASK) | (((v) << XS1_PORT_CTRL0_READY_MODE_SHIFT) & XS1_PORT_CTRL0_READY_MODE_MASK))
///@}
/**
 * \name PORT_CTRL0_PORT_TYPE
 * \anchor PORT_CTRL0_PORT_TYPE
 * 0 - data port, 1 - clock port (1-bit ports only), 2 - ready port (1-bit ports only)
 */
///@{
#define XS1_PORT_CTRL0_PORT_TYPE_SHIFT 0xc
#define XS1_PORT_CTRL0_PORT_TYPE_SIZE 0x2
#define XS1_PORT_CTRL0_PORT_TYPE_MASK (((1 << XS1_PORT_CTRL0_PORT_TYPE_SIZE) - 1) << XS1_PORT_CTRL0_PORT_TYPE_SHIFT)
/**
 * Extract the PORT_CTRL0_PORT_TYPE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_PORT_TYPE(x) (((x) & XS1_PORT_CTRL0_PORT_TYPE_MASK) >> XS1_PORT_CTRL0_PORT_TYPE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_PORT_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_PORT_TYPE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_PORT_TYPE_MASK) | (((v) << XS1_PORT_CTRL0_PORT_TYPE_SHIFT) & XS1_PORT_CTRL0_PORT_TYPE_MASK))
///@}
/**
 * \name PORT_CTRL0_INVERT
 * \anchor PORT_CTRL0_INVERT
 * When 1 the port is inverted, otherwise it is not inverted. Only possible on 1-bit ports.
 */
///@{
#define XS1_PORT_CTRL0_INVERT_SHIFT 0xe
#define XS1_PORT_CTRL0_INVERT_SIZE 0x1
#define XS1_PORT_CTRL0_INVERT_MASK (((1 << XS1_PORT_CTRL0_INVERT_SIZE) - 1) << XS1_PORT_CTRL0_INVERT_SHIFT)
/**
 * Extract the PORT_CTRL0_INVERT bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_INVERT(x) (((x) & XS1_PORT_CTRL0_INVERT_MASK) >> XS1_PORT_CTRL0_INVERT_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_INVERT bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_INVERT_SET(x, v) (((x) & ~XS1_PORT_CTRL0_INVERT_MASK) | (((v) << XS1_PORT_CTRL0_INVERT_SHIFT) & XS1_PORT_CTRL0_INVERT_MASK))
///@}
/**
 * \name PORT_CTRL0_SDELAY
 * \anchor PORT_CTRL0_SDELAY
 * 0 when the input uses the rising edge, 1 when it uses the falling edge of the clock.
 */
///@{
#define XS1_PORT_CTRL0_SDELAY_SHIFT 0xf
#define XS1_PORT_CTRL0_SDELAY_SIZE 0x1
#define XS1_PORT_CTRL0_SDELAY_MASK (((1 << XS1_PORT_CTRL0_SDELAY_SIZE) - 1) << XS1_PORT_CTRL0_SDELAY_SHIFT)
/**
 * Extract the PORT_CTRL0_SDELAY bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_SDELAY(x) (((x) & XS1_PORT_CTRL0_SDELAY_MASK) >> XS1_PORT_CTRL0_SDELAY_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_SDELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_SDELAY_SET(x, v) (((x) & ~XS1_PORT_CTRL0_SDELAY_MASK) | (((v) << XS1_PORT_CTRL0_SDELAY_SHIFT) & XS1_PORT_CTRL0_SDELAY_MASK))
///@}
/**
 * \name PORT_CTRL0_EV_VALID
 * \anchor PORT_CTRL0_EV_VALID
 * 1 when the Environment Vector is valid. When invalid, the resourceId is used as the environment vector. The environment vector is set using the ``SETEV`` instruction.
 */
///@{
#define XS1_PORT_CTRL0_EV_VALID_SHIFT 0x16
#define XS1_PORT_CTRL0_EV_VALID_SIZE 0x1
#define XS1_PORT_CTRL0_EV_VALID_MASK (((1 << XS1_PORT_CTRL0_EV_VALID_SIZE) - 1) << XS1_PORT_CTRL0_EV_VALID_SHIFT)
/**
 * Extract the PORT_CTRL0_EV_VALID bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_EV_VALID(x) (((x) & XS1_PORT_CTRL0_EV_VALID_MASK) >> XS1_PORT_CTRL0_EV_VALID_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_EV_VALID bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_EV_VALID_SET(x, v) (((x) & ~XS1_PORT_CTRL0_EV_VALID_MASK) | (((v) << XS1_PORT_CTRL0_EV_VALID_SHIFT) & XS1_PORT_CTRL0_EV_VALID_MASK))
///@}
/**
 * \name PORT_CTRL0_T_WAITING
 * \anchor PORT_CTRL0_T_WAITING
 * 1 when there is a thread waiting to be unblocked by this port.
 */
///@{
#define XS1_PORT_CTRL0_T_WAITING_SHIFT 0x17
#define XS1_PORT_CTRL0_T_WAITING_SIZE 0x1
#define XS1_PORT_CTRL0_T_WAITING_MASK (((1 << XS1_PORT_CTRL0_T_WAITING_SIZE) - 1) << XS1_PORT_CTRL0_T_WAITING_SHIFT)
/**
 * Extract the PORT_CTRL0_T_WAITING bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_T_WAITING(x) (((x) & XS1_PORT_CTRL0_T_WAITING_MASK) >> XS1_PORT_CTRL0_T_WAITING_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_T_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_T_WAITING_SET(x, v) (((x) & ~XS1_PORT_CTRL0_T_WAITING_MASK) | (((v) << XS1_PORT_CTRL0_T_WAITING_SHIFT) & XS1_PORT_CTRL0_T_WAITING_MASK))
///@}
/**
 * \name PORT_CTRL0_T_NUM
 * \anchor PORT_CTRL0_T_NUM
 * Number of the thread waiting for events or to be unblocked by this port.
 */
///@{
#define XS1_PORT_CTRL0_T_NUM_SHIFT 0x18
#define XS1_PORT_CTRL0_T_NUM_SIZE 0x8
#define XS1_PORT_CTRL0_T_NUM_MASK (((1 << XS1_PORT_CTRL0_T_NUM_SIZE) - 1) << XS1_PORT_CTRL0_T_NUM_SHIFT)
/**
 * Extract the PORT_CTRL0_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_T_NUM(x) (((x) & XS1_PORT_CTRL0_T_NUM_MASK) >> XS1_PORT_CTRL0_T_NUM_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_T_NUM_SET(x, v) (((x) & ~XS1_PORT_CTRL0_T_NUM_MASK) | (((v) << XS1_PORT_CTRL0_T_NUM_SHIFT) & XS1_PORT_CTRL0_T_NUM_MASK))
///@}
/**
 * \name PORT_CTRL1_DRIVE
 * \anchor PORT_CTRL1_DRIVE
 * Determines whether the output is driving, open drain or pull down.
 */
///@{
#define XS1_PORT_CTRL1_DRIVE_SHIFT 0x0
#define XS1_PORT_CTRL1_DRIVE_SIZE 0x8
#define XS1_PORT_CTRL1_DRIVE_MASK (((1 << XS1_PORT_CTRL1_DRIVE_SIZE) - 1) << XS1_PORT_CTRL1_DRIVE_SHIFT)
/**
 * Extract the PORT_CTRL1_DRIVE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_DRIVE(x) (((x) & XS1_PORT_CTRL1_DRIVE_MASK) >> XS1_PORT_CTRL1_DRIVE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_DRIVE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_DRIVE_SET(x, v) (((x) & ~XS1_PORT_CTRL1_DRIVE_MASK) | (((v) << XS1_PORT_CTRL1_DRIVE_SHIFT) & XS1_PORT_CTRL1_DRIVE_MASK))
///@}
/**
 * \name PORT_CTRL1_TWIDTH
 * \anchor PORT_CTRL1_TWIDTH
 * The transfer width of the port in bits
 */
///@{
#define XS1_PORT_CTRL1_TWIDTH_SHIFT 0x8
#define XS1_PORT_CTRL1_TWIDTH_SIZE 0x8
#define XS1_PORT_CTRL1_TWIDTH_MASK (((1 << XS1_PORT_CTRL1_TWIDTH_SIZE) - 1) << XS1_PORT_CTRL1_TWIDTH_SHIFT)
/**
 * Extract the PORT_CTRL1_TWIDTH bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_TWIDTH(x) (((x) & XS1_PORT_CTRL1_TWIDTH_MASK) >> XS1_PORT_CTRL1_TWIDTH_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_TWIDTH bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_TWIDTH_SET(x, v) (((x) & ~XS1_PORT_CTRL1_TWIDTH_MASK) | (((v) << XS1_PORT_CTRL1_TWIDTH_SHIFT) & XS1_PORT_CTRL1_TWIDTH_MASK))
///@}
/**
 * \name PORT_CTRL1_SREG_COUNT
 * \anchor PORT_CTRL1_SREG_COUNT
 * The shift register count in port widths.
 */
///@{
#define XS1_PORT_CTRL1_SREG_COUNT_SHIFT 0x10
#define XS1_PORT_CTRL1_SREG_COUNT_SIZE 0x8
#define XS1_PORT_CTRL1_SREG_COUNT_MASK (((1 << XS1_PORT_CTRL1_SREG_COUNT_SIZE) - 1) << XS1_PORT_CTRL1_SREG_COUNT_SHIFT)
/**
 * Extract the PORT_CTRL1_SREG_COUNT bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_SREG_COUNT(x) (((x) & XS1_PORT_CTRL1_SREG_COUNT_MASK) >> XS1_PORT_CTRL1_SREG_COUNT_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_SREG_COUNT bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_SREG_COUNT_SET(x, v) (((x) & ~XS1_PORT_CTRL1_SREG_COUNT_MASK) | (((v) << XS1_PORT_CTRL1_SREG_COUNT_SHIFT) & XS1_PORT_CTRL1_SREG_COUNT_MASK))
///@}
/**
 * \name PORT_CTRL1_TREG_FULL
 * \anchor PORT_CTRL1_TREG_FULL
 * 1 when the transfer register is full.
 */
///@{
#define XS1_PORT_CTRL1_TREG_FULL_SHIFT 0x18
#define XS1_PORT_CTRL1_TREG_FULL_SIZE 0x1
#define XS1_PORT_CTRL1_TREG_FULL_MASK (((1 << XS1_PORT_CTRL1_TREG_FULL_SIZE) - 1) << XS1_PORT_CTRL1_TREG_FULL_SHIFT)
/**
 * Extract the PORT_CTRL1_TREG_FULL bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_TREG_FULL(x) (((x) & XS1_PORT_CTRL1_TREG_FULL_MASK) >> XS1_PORT_CTRL1_TREG_FULL_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_TREG_FULL bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_TREG_FULL_SET(x, v) (((x) & ~XS1_PORT_CTRL1_TREG_FULL_MASK) | (((v) << XS1_PORT_CTRL1_TREG_FULL_SHIFT) & XS1_PORT_CTRL1_TREG_FULL_MASK))
///@}
/**
 * \name PORT_CTRL1_CHANGE_DIR
 * \anchor PORT_CTRL1_CHANGE_DIR
 * 0 when the direction is fixed, 1 when it is going to change.
 */
///@{
#define XS1_PORT_CTRL1_CHANGE_DIR_SHIFT 0x19
#define XS1_PORT_CTRL1_CHANGE_DIR_SIZE 0x1
#define XS1_PORT_CTRL1_CHANGE_DIR_MASK (((1 << XS1_PORT_CTRL1_CHANGE_DIR_SIZE) - 1) << XS1_PORT_CTRL1_CHANGE_DIR_SHIFT)
/**
 * Extract the PORT_CTRL1_CHANGE_DIR bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_CHANGE_DIR(x) (((x) & XS1_PORT_CTRL1_CHANGE_DIR_MASK) >> XS1_PORT_CTRL1_CHANGE_DIR_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_CHANGE_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_CHANGE_DIR_SET(x, v) (((x) & ~XS1_PORT_CTRL1_CHANGE_DIR_MASK) | (((v) << XS1_PORT_CTRL1_CHANGE_DIR_SHIFT) & XS1_PORT_CTRL1_CHANGE_DIR_MASK))
///@}
/**
 * \name PORT_CTRL1_SYNCR
 * \anchor PORT_CTRL1_SYNCR
 * 1 when a SYNCR instruction is pending completion.
 */
///@{
#define XS1_PORT_CTRL1_SYNCR_SHIFT 0x1a
#define XS1_PORT_CTRL1_SYNCR_SIZE 0x1
#define XS1_PORT_CTRL1_SYNCR_MASK (((1 << XS1_PORT_CTRL1_SYNCR_SIZE) - 1) << XS1_PORT_CTRL1_SYNCR_SHIFT)
/**
 * Extract the PORT_CTRL1_SYNCR bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_SYNCR(x) (((x) & XS1_PORT_CTRL1_SYNCR_MASK) >> XS1_PORT_CTRL1_SYNCR_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_SYNCR bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_SYNCR_SET(x, v) (((x) & ~XS1_PORT_CTRL1_SYNCR_MASK) | (((v) << XS1_PORT_CTRL1_SYNCR_SHIFT) & XS1_PORT_CTRL1_SYNCR_MASK))
///@}
/**
 * \name PORT_CTRL1_INST_COMMITTED
 * \anchor PORT_CTRL1_INST_COMMITTED
 * 1 when an instruction has committed to operating on the port.
 */
///@{
#define XS1_PORT_CTRL1_INST_COMMITTED_SHIFT 0x1b
#define XS1_PORT_CTRL1_INST_COMMITTED_SIZE 0x1
#define XS1_PORT_CTRL1_INST_COMMITTED_MASK (((1 << XS1_PORT_CTRL1_INST_COMMITTED_SIZE) - 1) << XS1_PORT_CTRL1_INST_COMMITTED_SHIFT)
/**
 * Extract the PORT_CTRL1_INST_COMMITTED bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_INST_COMMITTED(x) (((x) & XS1_PORT_CTRL1_INST_COMMITTED_MASK) >> XS1_PORT_CTRL1_INST_COMMITTED_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_INST_COMMITTED bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_INST_COMMITTED_SET(x, v) (((x) & ~XS1_PORT_CTRL1_INST_COMMITTED_MASK) | (((v) << XS1_PORT_CTRL1_INST_COMMITTED_SHIFT) & XS1_PORT_CTRL1_INST_COMMITTED_MASK))
///@}
/**
 * \name PORT_CTRL1_HOLD_DATA
 * \anchor PORT_CTRL1_HOLD_DATA
 * 1 data has been captured for a condition and is being held.
 */
///@{
#define XS1_PORT_CTRL1_HOLD_DATA_SHIFT 0x1c
#define XS1_PORT_CTRL1_HOLD_DATA_SIZE 0x1
#define XS1_PORT_CTRL1_HOLD_DATA_MASK (((1 << XS1_PORT_CTRL1_HOLD_DATA_SIZE) - 1) << XS1_PORT_CTRL1_HOLD_DATA_SHIFT)
/**
 * Extract the PORT_CTRL1_HOLD_DATA bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_HOLD_DATA(x) (((x) & XS1_PORT_CTRL1_HOLD_DATA_MASK) >> XS1_PORT_CTRL1_HOLD_DATA_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_HOLD_DATA bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_HOLD_DATA_SET(x, v) (((x) & ~XS1_PORT_CTRL1_HOLD_DATA_MASK) | (((v) << XS1_PORT_CTRL1_HOLD_DATA_SHIFT) & XS1_PORT_CTRL1_HOLD_DATA_MASK))
///@}
/**
 * \name PORT_CTRL1_WAIT_FOR_TIME
 * \anchor PORT_CTRL1_WAIT_FOR_TIME
 * 1 when waiting for the port time to be met.
 */
///@{
#define XS1_PORT_CTRL1_WAIT_FOR_TIME_SHIFT 0x1d
#define XS1_PORT_CTRL1_WAIT_FOR_TIME_SIZE 0x1
#define XS1_PORT_CTRL1_WAIT_FOR_TIME_MASK (((1 << XS1_PORT_CTRL1_WAIT_FOR_TIME_SIZE) - 1) << XS1_PORT_CTRL1_WAIT_FOR_TIME_SHIFT)
/**
 * Extract the PORT_CTRL1_WAIT_FOR_TIME bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_WAIT_FOR_TIME(x) (((x) & XS1_PORT_CTRL1_WAIT_FOR_TIME_MASK) >> XS1_PORT_CTRL1_WAIT_FOR_TIME_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_WAIT_FOR_TIME bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_WAIT_FOR_TIME_SET(x, v) (((x) & ~XS1_PORT_CTRL1_WAIT_FOR_TIME_MASK) | (((v) << XS1_PORT_CTRL1_WAIT_FOR_TIME_SHIFT) & XS1_PORT_CTRL1_WAIT_FOR_TIME_MASK))
///@}
/**
 * \name PORT_CTRL1_TIMEMET
 * \anchor PORT_CTRL1_TIMEMET
 * 1 when a SETPT is used.
 */
///@{
#define XS1_PORT_CTRL1_TIMEMET_SHIFT 0x1e
#define XS1_PORT_CTRL1_TIMEMET_SIZE 0x1
#define XS1_PORT_CTRL1_TIMEMET_MASK (((1 << XS1_PORT_CTRL1_TIMEMET_SIZE) - 1) << XS1_PORT_CTRL1_TIMEMET_SHIFT)
/**
 * Extract the PORT_CTRL1_TIMEMET bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_TIMEMET(x) (((x) & XS1_PORT_CTRL1_TIMEMET_MASK) >> XS1_PORT_CTRL1_TIMEMET_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_TIMEMET bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_TIMEMET_SET(x, v) (((x) & ~XS1_PORT_CTRL1_TIMEMET_MASK) | (((v) << XS1_PORT_CTRL1_TIMEMET_SHIFT) & XS1_PORT_CTRL1_TIMEMET_MASK))
///@}
/**
 * \name PORT_CTRL1_ENDIN
 * \anchor PORT_CTRL1_ENDIN
 * 1 when an ENDIN is used on a BUFFERS port and the tReg was full.
 */
///@{
#define XS1_PORT_CTRL1_ENDIN_SHIFT 0x1f
#define XS1_PORT_CTRL1_ENDIN_SIZE 0x1
#define XS1_PORT_CTRL1_ENDIN_MASK (((1 << XS1_PORT_CTRL1_ENDIN_SIZE) - 1) << XS1_PORT_CTRL1_ENDIN_SHIFT)
/**
 * Extract the PORT_CTRL1_ENDIN bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_ENDIN(x) (((x) & XS1_PORT_CTRL1_ENDIN_MASK) >> XS1_PORT_CTRL1_ENDIN_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_ENDIN bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_ENDIN_SET(x, v) (((x) & ~XS1_PORT_CTRL1_ENDIN_MASK) | (((v) << XS1_PORT_CTRL1_ENDIN_SHIFT) & XS1_PORT_CTRL1_ENDIN_MASK))
///@}
/**
 * \name PORT_CTRL2_TIME
 * \anchor PORT_CTRL2_TIME
 * The port time value.
 */
///@{
#define XS1_PORT_CTRL2_TIME_SHIFT 0x0
#define XS1_PORT_CTRL2_TIME_SIZE 0x10
#define XS1_PORT_CTRL2_TIME_MASK (((1 << XS1_PORT_CTRL2_TIME_SIZE) - 1) << XS1_PORT_CTRL2_TIME_SHIFT)
/**
 * Extract the PORT_CTRL2_TIME bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL2_TIME(x) (((x) & XS1_PORT_CTRL2_TIME_MASK) >> XS1_PORT_CTRL2_TIME_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL2_TIME bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL2_TIME_SET(x, v) (((x) & ~XS1_PORT_CTRL2_TIME_MASK) | (((v) << XS1_PORT_CTRL2_TIME_SHIFT) & XS1_PORT_CTRL2_TIME_MASK))
///@}
/**
 * \name PORT_CTRL2_PIN_DELAY
 * \anchor PORT_CTRL2_PIN_DELAY
 * The port pin delay.
 */
///@{
#define XS1_PORT_CTRL2_PIN_DELAY_SHIFT 0x10
#define XS1_PORT_CTRL2_PIN_DELAY_SIZE 0x3
#define XS1_PORT_CTRL2_PIN_DELAY_MASK (((1 << XS1_PORT_CTRL2_PIN_DELAY_SIZE) - 1) << XS1_PORT_CTRL2_PIN_DELAY_SHIFT)
/**
 * Extract the PORT_CTRL2_PIN_DELAY bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL2_PIN_DELAY(x) (((x) & XS1_PORT_CTRL2_PIN_DELAY_MASK) >> XS1_PORT_CTRL2_PIN_DELAY_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL2_PIN_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL2_PIN_DELAY_SET(x, v) (((x) & ~XS1_PORT_CTRL2_PIN_DELAY_MASK) | (((v) << XS1_PORT_CTRL2_PIN_DELAY_SHIFT) & XS1_PORT_CTRL2_PIN_DELAY_MASK))
///@}
/**
 * \name TIMER_CTRL0_INUSE
 * \anchor TIMER_CTRL0_INUSE
 * Returns 1 when it in use, 0 otherwise.
 */
///@{
#define XS1_TIMER_CTRL0_INUSE_SHIFT 0x0
#define XS1_TIMER_CTRL0_INUSE_SIZE 0x1
#define XS1_TIMER_CTRL0_INUSE_MASK (((1 << XS1_TIMER_CTRL0_INUSE_SIZE) - 1) << XS1_TIMER_CTRL0_INUSE_SHIFT)
/**
 * Extract the TIMER_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_INUSE(x) (((x) & XS1_TIMER_CTRL0_INUSE_MASK) >> XS1_TIMER_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_INUSE_MASK) | (((v) << XS1_TIMER_CTRL0_INUSE_SHIFT) & XS1_TIMER_CTRL0_INUSE_MASK))
///@}
/**
 * \name TIMER_CTRL0_IE_MODE
 * \anchor TIMER_CTRL0_IE_MODE
 * 0 when this timer will cause events, 1 when it will raise interrupts. It is controlled using the ``SETC`` instruction.
 */
///@{
#define XS1_TIMER_CTRL0_IE_MODE_SHIFT 0x1
#define XS1_TIMER_CTRL0_IE_MODE_SIZE 0x1
#define XS1_TIMER_CTRL0_IE_MODE_MASK (((1 << XS1_TIMER_CTRL0_IE_MODE_SIZE) - 1) << XS1_TIMER_CTRL0_IE_MODE_SHIFT)
/**
 * Extract the TIMER_CTRL0_IE_MODE bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_IE_MODE(x) (((x) & XS1_TIMER_CTRL0_IE_MODE_MASK) >> XS1_TIMER_CTRL0_IE_MODE_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_IE_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_IE_MODE_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_IE_MODE_MASK) | (((v) << XS1_TIMER_CTRL0_IE_MODE_SHIFT) & XS1_TIMER_CTRL0_IE_MODE_MASK))
///@}
/**
 * \name TIMER_CTRL0_IE_ENABLED
 * \anchor TIMER_CTRL0_IE_ENABLED
 * 1 when events or interrupts on this timer are active. It is set when an ``EEU`` is executed. It is cleared when a ``EDU`` or ``CLRE`` is executed. The ``EET`` and ``EEF`` will either set or clear the bit depending on the contents of the condition register.
 */
///@{
#define XS1_TIMER_CTRL0_IE_ENABLED_SHIFT 0x2
#define XS1_TIMER_CTRL0_IE_ENABLED_SIZE 0x1
#define XS1_TIMER_CTRL0_IE_ENABLED_MASK (((1 << XS1_TIMER_CTRL0_IE_ENABLED_SIZE) - 1) << XS1_TIMER_CTRL0_IE_ENABLED_SHIFT)
/**
 * Extract the TIMER_CTRL0_IE_ENABLED bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_IE_ENABLED(x) (((x) & XS1_TIMER_CTRL0_IE_ENABLED_MASK) >> XS1_TIMER_CTRL0_IE_ENABLED_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_IE_ENABLED bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_IE_ENABLED_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_IE_ENABLED_MASK) | (((v) << XS1_TIMER_CTRL0_IE_ENABLED_SHIFT) & XS1_TIMER_CTRL0_IE_ENABLED_MASK))
///@}
/**
 * \name TIMER_CTRL0_READY
 * \anchor TIMER_CTRL0_READY
 * 1 when the condition has been met. It is cleared when a ``SETC``, ``SETD``, ``SETV``, ``SETC`` or ``IN`` instruction is executed on the timer. 0 when the timer is not in use.
 */
///@{
#define XS1_TIMER_CTRL0_READY_SHIFT 0x3
#define XS1_TIMER_CTRL0_READY_SIZE 0x1
#define XS1_TIMER_CTRL0_READY_MASK (((1 << XS1_TIMER_CTRL0_READY_SIZE) - 1) << XS1_TIMER_CTRL0_READY_SHIFT)
/**
 * Extract the TIMER_CTRL0_READY bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_READY(x) (((x) & XS1_TIMER_CTRL0_READY_MASK) >> XS1_TIMER_CTRL0_READY_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_READY bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_READY_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_READY_MASK) | (((v) << XS1_TIMER_CTRL0_READY_SHIFT) & XS1_TIMER_CTRL0_READY_MASK))
///@}
/**
 * \name TIMER_CTRL0_COND
 * \anchor TIMER_CTRL0_COND
 * Shows the current condition of the timer. The condition is set using the ``SETC`` instruction.
 */
///@{
#define XS1_TIMER_CTRL0_COND_SHIFT 0x4
#define XS1_TIMER_CTRL0_COND_SIZE 0x1
#define XS1_TIMER_CTRL0_COND_MASK (((1 << XS1_TIMER_CTRL0_COND_SIZE) - 1) << XS1_TIMER_CTRL0_COND_SHIFT)
/**
 * Extract the TIMER_CTRL0_COND bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_COND(x) (((x) & XS1_TIMER_CTRL0_COND_MASK) >> XS1_TIMER_CTRL0_COND_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_COND bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_COND_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_COND_MASK) | (((v) << XS1_TIMER_CTRL0_COND_SHIFT) & XS1_TIMER_CTRL0_COND_MASK))
///@}
/**
 * \name TIMER_CTRL0_EV_VALID
 * \anchor TIMER_CTRL0_EV_VALID
 * 1 when the Environment Vector is valid. When invalid, the resourceId is used as the environment vector. The environment vector is set using the ``SETEV`` instruction.
 */
///@{
#define XS1_TIMER_CTRL0_EV_VALID_SHIFT 0x8
#define XS1_TIMER_CTRL0_EV_VALID_SIZE 0x1
#define XS1_TIMER_CTRL0_EV_VALID_MASK (((1 << XS1_TIMER_CTRL0_EV_VALID_SIZE) - 1) << XS1_TIMER_CTRL0_EV_VALID_SHIFT)
/**
 * Extract the TIMER_CTRL0_EV_VALID bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_EV_VALID(x) (((x) & XS1_TIMER_CTRL0_EV_VALID_MASK) >> XS1_TIMER_CTRL0_EV_VALID_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_EV_VALID bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_EV_VALID_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_EV_VALID_MASK) | (((v) << XS1_TIMER_CTRL0_EV_VALID_SHIFT) & XS1_TIMER_CTRL0_EV_VALID_MASK))
///@}
/**
 * \name TIMER_CTRL0_T_WAITING
 * \anchor TIMER_CTRL0_T_WAITING
 * 1 when there is a thread waiting to be unblocked by this timer.
 */
///@{
#define XS1_TIMER_CTRL0_T_WAITING_SHIFT 0x17
#define XS1_TIMER_CTRL0_T_WAITING_SIZE 0x1
#define XS1_TIMER_CTRL0_T_WAITING_MASK (((1 << XS1_TIMER_CTRL0_T_WAITING_SIZE) - 1) << XS1_TIMER_CTRL0_T_WAITING_SHIFT)
/**
 * Extract the TIMER_CTRL0_T_WAITING bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_T_WAITING(x) (((x) & XS1_TIMER_CTRL0_T_WAITING_MASK) >> XS1_TIMER_CTRL0_T_WAITING_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_T_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_T_WAITING_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_T_WAITING_MASK) | (((v) << XS1_TIMER_CTRL0_T_WAITING_SHIFT) & XS1_TIMER_CTRL0_T_WAITING_MASK))
///@}
/**
 * \name TIMER_CTRL0_T_NUM
 * \anchor TIMER_CTRL0_T_NUM
 * Number of the thread waiting for events or to be unblocked by this timer.
 */
///@{
#define XS1_TIMER_CTRL0_T_NUM_SHIFT 0x18
#define XS1_TIMER_CTRL0_T_NUM_SIZE 0x8
#define XS1_TIMER_CTRL0_T_NUM_MASK (((1 << XS1_TIMER_CTRL0_T_NUM_SIZE) - 1) << XS1_TIMER_CTRL0_T_NUM_SHIFT)
/**
 * Extract the TIMER_CTRL0_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_T_NUM(x) (((x) & XS1_TIMER_CTRL0_T_NUM_MASK) >> XS1_TIMER_CTRL0_T_NUM_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_T_NUM_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_T_NUM_MASK) | (((v) << XS1_TIMER_CTRL0_T_NUM_SHIFT) & XS1_TIMER_CTRL0_T_NUM_MASK))
///@}
/**
 * \name SYNC_CTRL0_INUSE
 * \anchor SYNC_CTRL0_INUSE
 * 1 when the synchroniser is in use.
 */
///@{
#define XS1_SYNC_CTRL0_INUSE_SHIFT 0x0
#define XS1_SYNC_CTRL0_INUSE_SIZE 0x1
#define XS1_SYNC_CTRL0_INUSE_MASK (((1 << XS1_SYNC_CTRL0_INUSE_SIZE) - 1) << XS1_SYNC_CTRL0_INUSE_SHIFT)
/**
 * Extract the SYNC_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_SYNC_CTRL0_INUSE(x) (((x) & XS1_SYNC_CTRL0_INUSE_MASK) >> XS1_SYNC_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the SYNC_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_SYNC_CTRL0_INUSE_MASK) | (((v) << XS1_SYNC_CTRL0_INUSE_SHIFT) & XS1_SYNC_CTRL0_INUSE_MASK))
///@}
/**
 * \name SYNC_CTRL0_MSYNCED
 * \anchor SYNC_CTRL0_MSYNCED
 * 1 when the master of this synchroniser has msynced on it.
 */
///@{
#define XS1_SYNC_CTRL0_MSYNCED_SHIFT 0x1
#define XS1_SYNC_CTRL0_MSYNCED_SIZE 0x1
#define XS1_SYNC_CTRL0_MSYNCED_MASK (((1 << XS1_SYNC_CTRL0_MSYNCED_SIZE) - 1) << XS1_SYNC_CTRL0_MSYNCED_SHIFT)
/**
 * Extract the SYNC_CTRL0_MSYNCED bitfield from a packed word x and return it.
 */
#define XS1_SYNC_CTRL0_MSYNCED(x) (((x) & XS1_SYNC_CTRL0_MSYNCED_MASK) >> XS1_SYNC_CTRL0_MSYNCED_SHIFT)
/**
 * Pack the value (v) of the SYNC_CTRL0_MSYNCED bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_CTRL0_MSYNCED_SET(x, v) (((x) & ~XS1_SYNC_CTRL0_MSYNCED_MASK) | (((v) << XS1_SYNC_CTRL0_MSYNCED_SHIFT) & XS1_SYNC_CTRL0_MSYNCED_MASK))
///@}
/**
 * \name SYNC_CTRL0_JOIN
 * \anchor SYNC_CTRL0_JOIN
 * 1 when the synchroniser will free the threads after synchronisation. 0 otherwise.
 */
///@{
#define XS1_SYNC_CTRL0_JOIN_SHIFT 0x2
#define XS1_SYNC_CTRL0_JOIN_SIZE 0x1
#define XS1_SYNC_CTRL0_JOIN_MASK (((1 << XS1_SYNC_CTRL0_JOIN_SIZE) - 1) << XS1_SYNC_CTRL0_JOIN_SHIFT)
/**
 * Extract the SYNC_CTRL0_JOIN bitfield from a packed word x and return it.
 */
#define XS1_SYNC_CTRL0_JOIN(x) (((x) & XS1_SYNC_CTRL0_JOIN_MASK) >> XS1_SYNC_CTRL0_JOIN_SHIFT)
/**
 * Pack the value (v) of the SYNC_CTRL0_JOIN bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_CTRL0_JOIN_SET(x, v) (((x) & ~XS1_SYNC_CTRL0_JOIN_MASK) | (((v) << XS1_SYNC_CTRL0_JOIN_SHIFT) & XS1_SYNC_CTRL0_JOIN_MASK))
///@}
/**
 * \name SYNC_CTRL0_MASTER
 * \anchor SYNC_CTRL0_MASTER
 * When synchroniser is in use it is the ID of the master thread. 0 when not in use.
 */
///@{
#define XS1_SYNC_CTRL0_MASTER_SHIFT 0x8
#define XS1_SYNC_CTRL0_MASTER_SIZE 0x8
#define XS1_SYNC_CTRL0_MASTER_MASK (((1 << XS1_SYNC_CTRL0_MASTER_SIZE) - 1) << XS1_SYNC_CTRL0_MASTER_SHIFT)
/**
 * Extract the SYNC_CTRL0_MASTER bitfield from a packed word x and return it.
 */
#define XS1_SYNC_CTRL0_MASTER(x) (((x) & XS1_SYNC_CTRL0_MASTER_MASK) >> XS1_SYNC_CTRL0_MASTER_SHIFT)
/**
 * Pack the value (v) of the SYNC_CTRL0_MASTER bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_CTRL0_MASTER_SET(x, v) (((x) & ~XS1_SYNC_CTRL0_MASTER_MASK) | (((v) << XS1_SYNC_CTRL0_MASTER_SHIFT) & XS1_SYNC_CTRL0_MASTER_MASK))
///@}
/**
 * \name SYNC_TBV0_SLAVES
 * \anchor SYNC_TBV0_SLAVES
 * 1 bit for each of the threads. When 1 indicates that the corresponding thread is attached to the synchroniser.
 */
///@{
#define XS1_SYNC_TBV0_SLAVES_SHIFT 0x0
#define XS1_SYNC_TBV0_SLAVES_SIZE 0x8
#define XS1_SYNC_TBV0_SLAVES_MASK (((1 << XS1_SYNC_TBV0_SLAVES_SIZE) - 1) << XS1_SYNC_TBV0_SLAVES_SHIFT)
/**
 * Extract the SYNC_TBV0_SLAVES bitfield from a packed word x and return it.
 */
#define XS1_SYNC_TBV0_SLAVES(x) (((x) & XS1_SYNC_TBV0_SLAVES_MASK) >> XS1_SYNC_TBV0_SLAVES_SHIFT)
/**
 * Pack the value (v) of the SYNC_TBV0_SLAVES bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_TBV0_SLAVES_SET(x, v) (((x) & ~XS1_SYNC_TBV0_SLAVES_MASK) | (((v) << XS1_SYNC_TBV0_SLAVES_SHIFT) & XS1_SYNC_TBV0_SLAVES_MASK))
///@}
/**
 * \name LOCK_CTRL0_INUSE
 * \anchor LOCK_CTRL0_INUSE
 * 1 when the lock is in use.
 */
///@{
#define XS1_LOCK_CTRL0_INUSE_SHIFT 0x0
#define XS1_LOCK_CTRL0_INUSE_SIZE 0x1
#define XS1_LOCK_CTRL0_INUSE_MASK (((1 << XS1_LOCK_CTRL0_INUSE_SIZE) - 1) << XS1_LOCK_CTRL0_INUSE_SHIFT)
/**
 * Extract the LOCK_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_LOCK_CTRL0_INUSE(x) (((x) & XS1_LOCK_CTRL0_INUSE_MASK) >> XS1_LOCK_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the LOCK_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_LOCK_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_LOCK_CTRL0_INUSE_MASK) | (((v) << XS1_LOCK_CTRL0_INUSE_SHIFT) & XS1_LOCK_CTRL0_INUSE_MASK))
///@}
/**
 * \name LOCK_CTRL0_OWNT_V
 * \anchor LOCK_CTRL0_OWNT_V
 * Indicates that the lock's owner is known.
 */
///@{
#define XS1_LOCK_CTRL0_OWNT_V_SHIFT 0x1
#define XS1_LOCK_CTRL0_OWNT_V_SIZE 0x1
#define XS1_LOCK_CTRL0_OWNT_V_MASK (((1 << XS1_LOCK_CTRL0_OWNT_V_SIZE) - 1) << XS1_LOCK_CTRL0_OWNT_V_SHIFT)
/**
 * Extract the LOCK_CTRL0_OWNT_V bitfield from a packed word x and return it.
 */
#define XS1_LOCK_CTRL0_OWNT_V(x) (((x) & XS1_LOCK_CTRL0_OWNT_V_MASK) >> XS1_LOCK_CTRL0_OWNT_V_SHIFT)
/**
 * Pack the value (v) of the LOCK_CTRL0_OWNT_V bitfield into a packed word x and return the packed field.
 */
#define XS1_LOCK_CTRL0_OWNT_V_SET(x, v) (((x) & ~XS1_LOCK_CTRL0_OWNT_V_MASK) | (((v) << XS1_LOCK_CTRL0_OWNT_V_SHIFT) & XS1_LOCK_CTRL0_OWNT_V_MASK))
///@}
/**
 * \name LOCK_CTRL0_OWNT
 * \anchor LOCK_CTRL0_OWNT
 * When OWNT_V is true then this is the ID of the thread currently holding the lock.
 */
///@{
#define XS1_LOCK_CTRL0_OWNT_SHIFT 0x8
#define XS1_LOCK_CTRL0_OWNT_SIZE 0x8
#define XS1_LOCK_CTRL0_OWNT_MASK (((1 << XS1_LOCK_CTRL0_OWNT_SIZE) - 1) << XS1_LOCK_CTRL0_OWNT_SHIFT)
/**
 * Extract the LOCK_CTRL0_OWNT bitfield from a packed word x and return it.
 */
#define XS1_LOCK_CTRL0_OWNT(x) (((x) & XS1_LOCK_CTRL0_OWNT_MASK) >> XS1_LOCK_CTRL0_OWNT_SHIFT)
/**
 * Pack the value (v) of the LOCK_CTRL0_OWNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LOCK_CTRL0_OWNT_SET(x, v) (((x) & ~XS1_LOCK_CTRL0_OWNT_MASK) | (((v) << XS1_LOCK_CTRL0_OWNT_SHIFT) & XS1_LOCK_CTRL0_OWNT_MASK))
///@}
/**
 * \name LOCK_TBV0_WAITING
 * \anchor LOCK_TBV0_WAITING
 * 1 bit for each of the threads. When 1 indicates that the corresponding thread is waiting for the lock.
 */
///@{
#define XS1_LOCK_TBV0_WAITING_SHIFT 0x0
#define XS1_LOCK_TBV0_WAITING_SIZE 0x8
#define XS1_LOCK_TBV0_WAITING_MASK (((1 << XS1_LOCK_TBV0_WAITING_SIZE) - 1) << XS1_LOCK_TBV0_WAITING_SHIFT)
/**
 * Extract the LOCK_TBV0_WAITING bitfield from a packed word x and return it.
 */
#define XS1_LOCK_TBV0_WAITING(x) (((x) & XS1_LOCK_TBV0_WAITING_MASK) >> XS1_LOCK_TBV0_WAITING_SHIFT)
/**
 * Pack the value (v) of the LOCK_TBV0_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_LOCK_TBV0_WAITING_SET(x, v) (((x) & ~XS1_LOCK_TBV0_WAITING_MASK) | (((v) << XS1_LOCK_TBV0_WAITING_SHIFT) & XS1_LOCK_TBV0_WAITING_MASK))
///@}
/**
 * \name MMAP_CTRL0_INUSE
 * \anchor MMAP_CTRL0_INUSE
 * .
 */
///@{
#define XS1_MMAP_CTRL0_INUSE_SHIFT 0x0
#define XS1_MMAP_CTRL0_INUSE_SIZE 0x1
#define XS1_MMAP_CTRL0_INUSE_MASK (((1 << XS1_MMAP_CTRL0_INUSE_SIZE) - 1) << XS1_MMAP_CTRL0_INUSE_SHIFT)
/**
 * Extract the MMAP_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_INUSE(x) (((x) & XS1_MMAP_CTRL0_INUSE_MASK) >> XS1_MMAP_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_INUSE_MASK) | (((v) << XS1_MMAP_CTRL0_INUSE_SHIFT) & XS1_MMAP_CTRL0_INUSE_MASK))
///@}
/**
 * \name MMAP_CTRL0_RO
 * \anchor MMAP_CTRL0_RO
 * .
 */
///@{
#define XS1_MMAP_CTRL0_RO_SHIFT 0x1
#define XS1_MMAP_CTRL0_RO_SIZE 0x1
#define XS1_MMAP_CTRL0_RO_MASK (((1 << XS1_MMAP_CTRL0_RO_SIZE) - 1) << XS1_MMAP_CTRL0_RO_SHIFT)
/**
 * Extract the MMAP_CTRL0_RO bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_RO(x) (((x) & XS1_MMAP_CTRL0_RO_MASK) >> XS1_MMAP_CTRL0_RO_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_RO bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_RO_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_RO_MASK) | (((v) << XS1_MMAP_CTRL0_RO_SHIFT) & XS1_MMAP_CTRL0_RO_MASK))
///@}
/**
 * \name MMAP_CTRL0_LOCK
 * \anchor MMAP_CTRL0_LOCK
 * .
 */
///@{
#define XS1_MMAP_CTRL0_LOCK_SHIFT 0x2
#define XS1_MMAP_CTRL0_LOCK_SIZE 0x1
#define XS1_MMAP_CTRL0_LOCK_MASK (((1 << XS1_MMAP_CTRL0_LOCK_SIZE) - 1) << XS1_MMAP_CTRL0_LOCK_SHIFT)
/**
 * Extract the MMAP_CTRL0_LOCK bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_LOCK(x) (((x) & XS1_MMAP_CTRL0_LOCK_MASK) >> XS1_MMAP_CTRL0_LOCK_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_LOCK bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_LOCK_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_LOCK_MASK) | (((v) << XS1_MMAP_CTRL0_LOCK_SHIFT) & XS1_MMAP_CTRL0_LOCK_MASK))
///@}
/**
 * \name MMAP_CTRL0_GLOBAL
 * \anchor MMAP_CTRL0_GLOBAL
 * .
 */
///@{
#define XS1_MMAP_CTRL0_GLOBAL_SHIFT 0x3
#define XS1_MMAP_CTRL0_GLOBAL_SIZE 0x1
#define XS1_MMAP_CTRL0_GLOBAL_MASK (((1 << XS1_MMAP_CTRL0_GLOBAL_SIZE) - 1) << XS1_MMAP_CTRL0_GLOBAL_SHIFT)
/**
 * Extract the MMAP_CTRL0_GLOBAL bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_GLOBAL(x) (((x) & XS1_MMAP_CTRL0_GLOBAL_MASK) >> XS1_MMAP_CTRL0_GLOBAL_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_GLOBAL bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_GLOBAL_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_GLOBAL_MASK) | (((v) << XS1_MMAP_CTRL0_GLOBAL_SHIFT) & XS1_MMAP_CTRL0_GLOBAL_MASK))
///@}
/**
 * \name MMAP_CTRL0_ASID
 * \anchor MMAP_CTRL0_ASID
 * .
 */
///@{
#define XS1_MMAP_CTRL0_ASID_SHIFT 0x4
#define XS1_MMAP_CTRL0_ASID_SIZE 0x2
#define XS1_MMAP_CTRL0_ASID_MASK (((1 << XS1_MMAP_CTRL0_ASID_SIZE) - 1) << XS1_MMAP_CTRL0_ASID_SHIFT)
/**
 * Extract the MMAP_CTRL0_ASID bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_ASID(x) (((x) & XS1_MMAP_CTRL0_ASID_MASK) >> XS1_MMAP_CTRL0_ASID_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_ASID bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_ASID_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_ASID_MASK) | (((v) << XS1_MMAP_CTRL0_ASID_SHIFT) & XS1_MMAP_CTRL0_ASID_MASK))
///@}
/**
 * \name MMAP_CTRL0_LENGTH
 * \anchor MMAP_CTRL0_LENGTH
 * .
 */
///@{
#define XS1_MMAP_CTRL0_LENGTH_SHIFT 0x6
#define XS1_MMAP_CTRL0_LENGTH_SIZE 0x2
#define XS1_MMAP_CTRL0_LENGTH_MASK (((1 << XS1_MMAP_CTRL0_LENGTH_SIZE) - 1) << XS1_MMAP_CTRL0_LENGTH_SHIFT)
/**
 * Extract the MMAP_CTRL0_LENGTH bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_LENGTH(x) (((x) & XS1_MMAP_CTRL0_LENGTH_MASK) >> XS1_MMAP_CTRL0_LENGTH_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_LENGTH bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_LENGTH_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_LENGTH_MASK) | (((v) << XS1_MMAP_CTRL0_LENGTH_SHIFT) & XS1_MMAP_CTRL0_LENGTH_MASK))
///@}
/**
 * \name MMAP_CTRL0_PHY_ADDR
 * \anchor MMAP_CTRL0_PHY_ADDR
 * .
 */
///@{
#define XS1_MMAP_CTRL0_PHY_ADDR_SHIFT 0x8
#define XS1_MMAP_CTRL0_PHY_ADDR_SIZE 0x18
#define XS1_MMAP_CTRL0_PHY_ADDR_MASK (((1 << XS1_MMAP_CTRL0_PHY_ADDR_SIZE) - 1) << XS1_MMAP_CTRL0_PHY_ADDR_SHIFT)
/**
 * Extract the MMAP_CTRL0_PHY_ADDR bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_PHY_ADDR(x) (((x) & XS1_MMAP_CTRL0_PHY_ADDR_MASK) >> XS1_MMAP_CTRL0_PHY_ADDR_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_PHY_ADDR bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_PHY_ADDR_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_PHY_ADDR_MASK) | (((v) << XS1_MMAP_CTRL0_PHY_ADDR_SHIFT) & XS1_MMAP_CTRL0_PHY_ADDR_MASK))
///@}
/**
 * \name MMAP_CTRL1_THREADS_EN
 * \anchor MMAP_CTRL1_THREADS_EN
 * .
 */
///@{
#define XS1_MMAP_CTRL1_THREADS_EN_SHIFT 0x0
#define XS1_MMAP_CTRL1_THREADS_EN_SIZE 0x8
#define XS1_MMAP_CTRL1_THREADS_EN_MASK (((1 << XS1_MMAP_CTRL1_THREADS_EN_SIZE) - 1) << XS1_MMAP_CTRL1_THREADS_EN_SHIFT)
/**
 * Extract the MMAP_CTRL1_THREADS_EN bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL1_THREADS_EN(x) (((x) & XS1_MMAP_CTRL1_THREADS_EN_MASK) >> XS1_MMAP_CTRL1_THREADS_EN_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL1_THREADS_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL1_THREADS_EN_SET(x, v) (((x) & ~XS1_MMAP_CTRL1_THREADS_EN_MASK) | (((v) << XS1_MMAP_CTRL1_THREADS_EN_SHIFT) & XS1_MMAP_CTRL1_THREADS_EN_MASK))
///@}
/**
 * \name MMAP_CTRL1_VIRT_ADDR
 * \anchor MMAP_CTRL1_VIRT_ADDR
 * .
 */
///@{
#define XS1_MMAP_CTRL1_VIRT_ADDR_SHIFT 0x8
#define XS1_MMAP_CTRL1_VIRT_ADDR_SIZE 0x18
#define XS1_MMAP_CTRL1_VIRT_ADDR_MASK (((1 << XS1_MMAP_CTRL1_VIRT_ADDR_SIZE) - 1) << XS1_MMAP_CTRL1_VIRT_ADDR_SHIFT)
/**
 * Extract the MMAP_CTRL1_VIRT_ADDR bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL1_VIRT_ADDR(x) (((x) & XS1_MMAP_CTRL1_VIRT_ADDR_MASK) >> XS1_MMAP_CTRL1_VIRT_ADDR_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL1_VIRT_ADDR bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL1_VIRT_ADDR_SET(x, v) (((x) & ~XS1_MMAP_CTRL1_VIRT_ADDR_MASK) | (((v) << XS1_MMAP_CTRL1_VIRT_ADDR_SHIFT) & XS1_MMAP_CTRL1_VIRT_ADDR_MASK))
///@}
/**
 * \name MMAP_CTRL2_AGE
 * \anchor MMAP_CTRL2_AGE
 * .
 */
///@{
#define XS1_MMAP_CTRL2_AGE_SHIFT 0x0
#define XS1_MMAP_CTRL2_AGE_SIZE 0x6
#define XS1_MMAP_CTRL2_AGE_MASK (((1 << XS1_MMAP_CTRL2_AGE_SIZE) - 1) << XS1_MMAP_CTRL2_AGE_SHIFT)
/**
 * Extract the MMAP_CTRL2_AGE bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL2_AGE(x) (((x) & XS1_MMAP_CTRL2_AGE_MASK) >> XS1_MMAP_CTRL2_AGE_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL2_AGE bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL2_AGE_SET(x, v) (((x) & ~XS1_MMAP_CTRL2_AGE_MASK) | (((v) << XS1_MMAP_CTRL2_AGE_SHIFT) & XS1_MMAP_CTRL2_AGE_MASK))
///@}
/**
 * \name MMAP_CTRL2_OWNER
 * \anchor MMAP_CTRL2_OWNER
 * .
 */
///@{
#define XS1_MMAP_CTRL2_OWNER_SHIFT 0x6
#define XS1_MMAP_CTRL2_OWNER_SIZE 0x8
#define XS1_MMAP_CTRL2_OWNER_MASK (((1 << XS1_MMAP_CTRL2_OWNER_SIZE) - 1) << XS1_MMAP_CTRL2_OWNER_SHIFT)
/**
 * Extract the MMAP_CTRL2_OWNER bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL2_OWNER(x) (((x) & XS1_MMAP_CTRL2_OWNER_MASK) >> XS1_MMAP_CTRL2_OWNER_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL2_OWNER bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL2_OWNER_SET(x, v) (((x) & ~XS1_MMAP_CTRL2_OWNER_MASK) | (((v) << XS1_MMAP_CTRL2_OWNER_SHIFT) & XS1_MMAP_CTRL2_OWNER_MASK))
///@}
/**
 * \name CHANEND_CTRL0_INUSE
 * \anchor CHANEND_CTRL0_INUSE
 * 1 when the channel end is in use.
 */
///@{
#define XS1_CHANEND_CTRL0_INUSE_SHIFT 0x0
#define XS1_CHANEND_CTRL0_INUSE_SIZE 0x1
#define XS1_CHANEND_CTRL0_INUSE_MASK (((1 << XS1_CHANEND_CTRL0_INUSE_SIZE) - 1) << XS1_CHANEND_CTRL0_INUSE_SHIFT)
/**
 * Extract the CHANEND_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_INUSE(x) (((x) & XS1_CHANEND_CTRL0_INUSE_MASK) >> XS1_CHANEND_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_INUSE_MASK) | (((v) << XS1_CHANEND_CTRL0_INUSE_SHIFT) & XS1_CHANEND_CTRL0_INUSE_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IE_MODE
 * \anchor CHANEND_CTRL0_IE_MODE
 * 0 when the channel end will cause events, 1 when in use and it will raise interrupts.
 */
///@{
#define XS1_CHANEND_CTRL0_IE_MODE_SHIFT 0x1
#define XS1_CHANEND_CTRL0_IE_MODE_SIZE 0x1
#define XS1_CHANEND_CTRL0_IE_MODE_MASK (((1 << XS1_CHANEND_CTRL0_IE_MODE_SIZE) - 1) << XS1_CHANEND_CTRL0_IE_MODE_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IE_MODE bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IE_MODE(x) (((x) & XS1_CHANEND_CTRL0_IE_MODE_MASK) >> XS1_CHANEND_CTRL0_IE_MODE_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IE_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IE_MODE_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IE_MODE_MASK) | (((v) << XS1_CHANEND_CTRL0_IE_MODE_SHIFT) & XS1_CHANEND_CTRL0_IE_MODE_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IE_ENABLED
 * \anchor CHANEND_CTRL0_IE_ENABLED
 * 1 when events or interrupts are enabled on the channel end.
 */
///@{
#define XS1_CHANEND_CTRL0_IE_ENABLED_SHIFT 0x2
#define XS1_CHANEND_CTRL0_IE_ENABLED_SIZE 0x1
#define XS1_CHANEND_CTRL0_IE_ENABLED_MASK (((1 << XS1_CHANEND_CTRL0_IE_ENABLED_SIZE) - 1) << XS1_CHANEND_CTRL0_IE_ENABLED_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IE_ENABLED bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IE_ENABLED(x) (((x) & XS1_CHANEND_CTRL0_IE_ENABLED_MASK) >> XS1_CHANEND_CTRL0_IE_ENABLED_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IE_ENABLED bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IE_ENABLED_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IE_ENABLED_MASK) | (((v) << XS1_CHANEND_CTRL0_IE_ENABLED_SHIFT) & XS1_CHANEND_CTRL0_IE_ENABLED_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IN_READY
 * \anchor CHANEND_CTRL0_IN_READY
 * 1 when in use and there is sufficient data in the channel end for a token to be input by a thread.
 */
///@{
#define XS1_CHANEND_CTRL0_IN_READY_SHIFT 0x4
#define XS1_CHANEND_CTRL0_IN_READY_SIZE 0x1
#define XS1_CHANEND_CTRL0_IN_READY_MASK (((1 << XS1_CHANEND_CTRL0_IN_READY_SIZE) - 1) << XS1_CHANEND_CTRL0_IN_READY_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IN_READY bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IN_READY(x) (((x) & XS1_CHANEND_CTRL0_IN_READY_MASK) >> XS1_CHANEND_CTRL0_IN_READY_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IN_READY bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IN_READY_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IN_READY_MASK) | (((v) << XS1_CHANEND_CTRL0_IN_READY_SHIFT) & XS1_CHANEND_CTRL0_IN_READY_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IN_WAITING
 * \anchor CHANEND_CTRL0_IN_WAITING
 * 1 when the input thread is waiting either for data or for an event.
 */
///@{
#define XS1_CHANEND_CTRL0_IN_WAITING_SHIFT 0x5
#define XS1_CHANEND_CTRL0_IN_WAITING_SIZE 0x1
#define XS1_CHANEND_CTRL0_IN_WAITING_MASK (((1 << XS1_CHANEND_CTRL0_IN_WAITING_SIZE) - 1) << XS1_CHANEND_CTRL0_IN_WAITING_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IN_WAITING bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IN_WAITING(x) (((x) & XS1_CHANEND_CTRL0_IN_WAITING_MASK) >> XS1_CHANEND_CTRL0_IN_WAITING_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IN_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IN_WAITING_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IN_WAITING_MASK) | (((v) << XS1_CHANEND_CTRL0_IN_WAITING_SHIFT) & XS1_CHANEND_CTRL0_IN_WAITING_MASK))
///@}
/**
 * \name CHANEND_CTRL0_OUT_READY
 * \anchor CHANEND_CTRL0_OUT_READY
 * 1 when in use and either not connected or there is sufficient room in the target channel end for a token to be ouptut by a thread. Will be 0 when requesting a link but not yet connected.
 */
///@{
#define XS1_CHANEND_CTRL0_OUT_READY_SHIFT 0x6
#define XS1_CHANEND_CTRL0_OUT_READY_SIZE 0x1
#define XS1_CHANEND_CTRL0_OUT_READY_MASK (((1 << XS1_CHANEND_CTRL0_OUT_READY_SIZE) - 1) << XS1_CHANEND_CTRL0_OUT_READY_SHIFT)
/**
 * Extract the CHANEND_CTRL0_OUT_READY bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_OUT_READY(x) (((x) & XS1_CHANEND_CTRL0_OUT_READY_MASK) >> XS1_CHANEND_CTRL0_OUT_READY_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_OUT_READY bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_OUT_READY_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_OUT_READY_MASK) | (((v) << XS1_CHANEND_CTRL0_OUT_READY_SHIFT) & XS1_CHANEND_CTRL0_OUT_READY_MASK))
///@}
/**
 * \name CHANEND_CTRL0_OUT_WAITING
 * \anchor CHANEND_CTRL0_OUT_WAITING
 * 1 when there is a thread waiting to write data to the channel end.
 */
///@{
#define XS1_CHANEND_CTRL0_OUT_WAITING_SHIFT 0x7
#define XS1_CHANEND_CTRL0_OUT_WAITING_SIZE 0x1
#define XS1_CHANEND_CTRL0_OUT_WAITING_MASK (((1 << XS1_CHANEND_CTRL0_OUT_WAITING_SIZE) - 1) << XS1_CHANEND_CTRL0_OUT_WAITING_SHIFT)
/**
 * Extract the CHANEND_CTRL0_OUT_WAITING bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_OUT_WAITING(x) (((x) & XS1_CHANEND_CTRL0_OUT_WAITING_MASK) >> XS1_CHANEND_CTRL0_OUT_WAITING_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_OUT_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_OUT_WAITING_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_OUT_WAITING_MASK) | (((v) << XS1_CHANEND_CTRL0_OUT_WAITING_SHIFT) & XS1_CHANEND_CTRL0_OUT_WAITING_MASK))
///@}
/**
 * \name CHANEND_CTRL0_EV_VALID
 * \anchor CHANEND_CTRL0_EV_VALID
 * 1 when the Environment Vector is valid. When invalid, the resourceId is used as the environment vector. The environment vector is set using the ``SETEV`` instruction.
 */
///@{
#define XS1_CHANEND_CTRL0_EV_VALID_SHIFT 0x8
#define XS1_CHANEND_CTRL0_EV_VALID_SIZE 0x1
#define XS1_CHANEND_CTRL0_EV_VALID_MASK (((1 << XS1_CHANEND_CTRL0_EV_VALID_SIZE) - 1) << XS1_CHANEND_CTRL0_EV_VALID_SHIFT)
/**
 * Extract the CHANEND_CTRL0_EV_VALID bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_EV_VALID(x) (((x) & XS1_CHANEND_CTRL0_EV_VALID_MASK) >> XS1_CHANEND_CTRL0_EV_VALID_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_EV_VALID bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_EV_VALID_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_EV_VALID_MASK) | (((v) << XS1_CHANEND_CTRL0_EV_VALID_SHIFT) & XS1_CHANEND_CTRL0_EV_VALID_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IN_T_NUM
 * \anchor CHANEND_CTRL0_IN_T_NUM
 * Number of the input thread waiting for data or an event on this channel end.
 */
///@{
#define XS1_CHANEND_CTRL0_IN_T_NUM_SHIFT 0x10
#define XS1_CHANEND_CTRL0_IN_T_NUM_SIZE 0x8
#define XS1_CHANEND_CTRL0_IN_T_NUM_MASK (((1 << XS1_CHANEND_CTRL0_IN_T_NUM_SIZE) - 1) << XS1_CHANEND_CTRL0_IN_T_NUM_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IN_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IN_T_NUM(x) (((x) & XS1_CHANEND_CTRL0_IN_T_NUM_MASK) >> XS1_CHANEND_CTRL0_IN_T_NUM_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IN_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IN_T_NUM_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IN_T_NUM_MASK) | (((v) << XS1_CHANEND_CTRL0_IN_T_NUM_SHIFT) & XS1_CHANEND_CTRL0_IN_T_NUM_MASK))
///@}
/**
 * \name CHANEND_CTRL0_OUT_T_NUM
 * \anchor CHANEND_CTRL0_OUT_T_NUM
 * Number of the last thread to attempt to write data to this channel end.
 */
///@{
#define XS1_CHANEND_CTRL0_OUT_T_NUM_SHIFT 0x18
#define XS1_CHANEND_CTRL0_OUT_T_NUM_SIZE 0x8
#define XS1_CHANEND_CTRL0_OUT_T_NUM_MASK (((1 << XS1_CHANEND_CTRL0_OUT_T_NUM_SIZE) - 1) << XS1_CHANEND_CTRL0_OUT_T_NUM_SHIFT)
/**
 * Extract the CHANEND_CTRL0_OUT_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_OUT_T_NUM(x) (((x) & XS1_CHANEND_CTRL0_OUT_T_NUM_MASK) >> XS1_CHANEND_CTRL0_OUT_T_NUM_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_OUT_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_OUT_T_NUM_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_OUT_T_NUM_MASK) | (((v) << XS1_CHANEND_CTRL0_OUT_T_NUM_SHIFT) & XS1_CHANEND_CTRL0_OUT_T_NUM_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_INUSE
 * \anchor CLKBLK_CTRL0_INUSE
 * 1 when the clock source is in use.
 */
///@{
#define XS1_CLKBLK_CTRL0_INUSE_SHIFT 0x0
#define XS1_CLKBLK_CTRL0_INUSE_SIZE 0x1
#define XS1_CLKBLK_CTRL0_INUSE_MASK (((1 << XS1_CLKBLK_CTRL0_INUSE_SIZE) - 1) << XS1_CLKBLK_CTRL0_INUSE_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_INUSE(x) (((x) & XS1_CLKBLK_CTRL0_INUSE_MASK) >> XS1_CLKBLK_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_INUSE_MASK) | (((v) << XS1_CLKBLK_CTRL0_INUSE_SHIFT) & XS1_CLKBLK_CTRL0_INUSE_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_STARTED
 * \anchor CLKBLK_CTRL0_STARTED
 * 1 when the clock source has been started.
 */
///@{
#define XS1_CLKBLK_CTRL0_STARTED_SHIFT 0x1
#define XS1_CLKBLK_CTRL0_STARTED_SIZE 0x1
#define XS1_CLKBLK_CTRL0_STARTED_MASK (((1 << XS1_CLKBLK_CTRL0_STARTED_SIZE) - 1) << XS1_CLKBLK_CTRL0_STARTED_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_STARTED bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_STARTED(x) (((x) & XS1_CLKBLK_CTRL0_STARTED_MASK) >> XS1_CLKBLK_CTRL0_STARTED_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_STARTED bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_STARTED_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_STARTED_MASK) | (((v) << XS1_CLKBLK_CTRL0_STARTED_SHIFT) & XS1_CLKBLK_CTRL0_STARTED_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_STOPPING
 * \anchor CLKBLK_CTRL0_STOPPING
 * 1 when the clock source is in the process of stopping.
 */
///@{
#define XS1_CLKBLK_CTRL0_STOPPING_SHIFT 0x2
#define XS1_CLKBLK_CTRL0_STOPPING_SIZE 0x1
#define XS1_CLKBLK_CTRL0_STOPPING_MASK (((1 << XS1_CLKBLK_CTRL0_STOPPING_SIZE) - 1) << XS1_CLKBLK_CTRL0_STOPPING_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_STOPPING bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_STOPPING(x) (((x) & XS1_CLKBLK_CTRL0_STOPPING_MASK) >> XS1_CLKBLK_CTRL0_STOPPING_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_STOPPING bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_STOPPING_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_STOPPING_MASK) | (((v) << XS1_CLKBLK_CTRL0_STOPPING_SHIFT) & XS1_CLKBLK_CTRL0_STOPPING_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_T_WAITING
 * \anchor CLKBLK_CTRL0_T_WAITING
 * 1 when there is a thread waiting for synchronisation with the clock block.
 */
///@{
#define XS1_CLKBLK_CTRL0_T_WAITING_SHIFT 0x17
#define XS1_CLKBLK_CTRL0_T_WAITING_SIZE 0x1
#define XS1_CLKBLK_CTRL0_T_WAITING_MASK (((1 << XS1_CLKBLK_CTRL0_T_WAITING_SIZE) - 1) << XS1_CLKBLK_CTRL0_T_WAITING_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_T_WAITING bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_T_WAITING(x) (((x) & XS1_CLKBLK_CTRL0_T_WAITING_MASK) >> XS1_CLKBLK_CTRL0_T_WAITING_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_T_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_T_WAITING_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_T_WAITING_MASK) | (((v) << XS1_CLKBLK_CTRL0_T_WAITING_SHIFT) & XS1_CLKBLK_CTRL0_T_WAITING_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_T_NUM
 * \anchor CLKBLK_CTRL0_T_NUM
 * Number of the thread waiting for the clock block.
 */
///@{
#define XS1_CLKBLK_CTRL0_T_NUM_SHIFT 0x18
#define XS1_CLKBLK_CTRL0_T_NUM_SIZE 0x8
#define XS1_CLKBLK_CTRL0_T_NUM_MASK (((1 << XS1_CLKBLK_CTRL0_T_NUM_SIZE) - 1) << XS1_CLKBLK_CTRL0_T_NUM_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_T_NUM(x) (((x) & XS1_CLKBLK_CTRL0_T_NUM_MASK) >> XS1_CLKBLK_CTRL0_T_NUM_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_T_NUM_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_T_NUM_MASK) | (((v) << XS1_CLKBLK_CTRL0_T_NUM_SHIFT) & XS1_CLKBLK_CTRL0_T_NUM_MASK))
///@}
/**
 * \name CLKBLK_CTRL1_FALL_DELAY
 * \anchor CLKBLK_CTRL1_FALL_DELAY
 * Falling edge delay counter.
 */
///@{
#define XS1_CLKBLK_CTRL1_FALL_DELAY_SHIFT 0x0
#define XS1_CLKBLK_CTRL1_FALL_DELAY_SIZE 0x9
#define XS1_CLKBLK_CTRL1_FALL_DELAY_MASK (((1 << XS1_CLKBLK_CTRL1_FALL_DELAY_SIZE) - 1) << XS1_CLKBLK_CTRL1_FALL_DELAY_SHIFT)
/**
 * Extract the CLKBLK_CTRL1_FALL_DELAY bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL1_FALL_DELAY(x) (((x) & XS1_CLKBLK_CTRL1_FALL_DELAY_MASK) >> XS1_CLKBLK_CTRL1_FALL_DELAY_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL1_FALL_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL1_FALL_DELAY_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL1_FALL_DELAY_MASK) | (((v) << XS1_CLKBLK_CTRL1_FALL_DELAY_SHIFT) & XS1_CLKBLK_CTRL1_FALL_DELAY_MASK))
///@}
/**
 * \name CLKBLK_CTRL1_RISE_DELAY
 * \anchor CLKBLK_CTRL1_RISE_DELAY
 * Rising edge delay counter.
 */
///@{
#define XS1_CLKBLK_CTRL1_RISE_DELAY_SHIFT 0x10
#define XS1_CLKBLK_CTRL1_RISE_DELAY_SIZE 0x9
#define XS1_CLKBLK_CTRL1_RISE_DELAY_MASK (((1 << XS1_CLKBLK_CTRL1_RISE_DELAY_SIZE) - 1) << XS1_CLKBLK_CTRL1_RISE_DELAY_SHIFT)
/**
 * Extract the CLKBLK_CTRL1_RISE_DELAY bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL1_RISE_DELAY(x) (((x) & XS1_CLKBLK_CTRL1_RISE_DELAY_MASK) >> XS1_CLKBLK_CTRL1_RISE_DELAY_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL1_RISE_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL1_RISE_DELAY_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL1_RISE_DELAY_MASK) | (((v) << XS1_CLKBLK_CTRL1_RISE_DELAY_SHIFT) & XS1_CLKBLK_CTRL1_RISE_DELAY_MASK))
///@}
/**
 * \name COPROC_CTRL0_INUSE
 * \anchor COPROC_CTRL0_INUSE
 * 1 when the coprocessor is in use.
 */
///@{
#define XS1_COPROC_CTRL0_INUSE_SHIFT 0x0
#define XS1_COPROC_CTRL0_INUSE_SIZE 0x1
#define XS1_COPROC_CTRL0_INUSE_MASK (((1 << XS1_COPROC_CTRL0_INUSE_SIZE) - 1) << XS1_COPROC_CTRL0_INUSE_SHIFT)
/**
 * Extract the COPROC_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_COPROC_CTRL0_INUSE(x) (((x) & XS1_COPROC_CTRL0_INUSE_MASK) >> XS1_COPROC_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the COPROC_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_COPROC_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_COPROC_CTRL0_INUSE_MASK) | (((v) << XS1_COPROC_CTRL0_INUSE_SHIFT) & XS1_COPROC_CTRL0_INUSE_MASK))
///@}
/**
 * \name COPROC_CTRL0_OWNT_V
 * \anchor COPROC_CTRL0_OWNT_V
 * Indicates that the coprocessor's owner is known.
 */
///@{
#define XS1_COPROC_CTRL0_OWNT_V_SHIFT 0x1
#define XS1_COPROC_CTRL0_OWNT_V_SIZE 0x1
#define XS1_COPROC_CTRL0_OWNT_V_MASK (((1 << XS1_COPROC_CTRL0_OWNT_V_SIZE) - 1) << XS1_COPROC_CTRL0_OWNT_V_SHIFT)
/**
 * Extract the COPROC_CTRL0_OWNT_V bitfield from a packed word x and return it.
 */
#define XS1_COPROC_CTRL0_OWNT_V(x) (((x) & XS1_COPROC_CTRL0_OWNT_V_MASK) >> XS1_COPROC_CTRL0_OWNT_V_SHIFT)
/**
 * Pack the value (v) of the COPROC_CTRL0_OWNT_V bitfield into a packed word x and return the packed field.
 */
#define XS1_COPROC_CTRL0_OWNT_V_SET(x, v) (((x) & ~XS1_COPROC_CTRL0_OWNT_V_MASK) | (((v) << XS1_COPROC_CTRL0_OWNT_V_SHIFT) & XS1_COPROC_CTRL0_OWNT_V_MASK))
///@}
/**
 * \name COPROC_CTRL0_OWNT
 * \anchor COPROC_CTRL0_OWNT
 * When OWNT_V is true then this is the ID of the thread currently using the coprocessor.
 */
///@{
#define XS1_COPROC_CTRL0_OWNT_SHIFT 0x8
#define XS1_COPROC_CTRL0_OWNT_SIZE 0x8
#define XS1_COPROC_CTRL0_OWNT_MASK (((1 << XS1_COPROC_CTRL0_OWNT_SIZE) - 1) << XS1_COPROC_CTRL0_OWNT_SHIFT)
/**
 * Extract the COPROC_CTRL0_OWNT bitfield from a packed word x and return it.
 */
#define XS1_COPROC_CTRL0_OWNT(x) (((x) & XS1_COPROC_CTRL0_OWNT_MASK) >> XS1_COPROC_CTRL0_OWNT_SHIFT)
/**
 * Pack the value (v) of the COPROC_CTRL0_OWNT bitfield into a packed word x and return the packed field.
 */
#define XS1_COPROC_CTRL0_OWNT_SET(x, v) (((x) & ~XS1_COPROC_CTRL0_OWNT_MASK) | (((v) << XS1_COPROC_CTRL0_OWNT_SHIFT) & XS1_COPROC_CTRL0_OWNT_MASK))
///@}
/**
 * \name COPROC_TBV0_WAITING
 * \anchor COPROC_TBV0_WAITING
 * 1 bit for each of the threads. When 1 indicates that the corresponding thread is waiting for the coprocessor.
 */
///@{
#define XS1_COPROC_TBV0_WAITING_SHIFT 0x0
#define XS1_COPROC_TBV0_WAITING_SIZE 0x8
#define XS1_COPROC_TBV0_WAITING_MASK (((1 << XS1_COPROC_TBV0_WAITING_SIZE) - 1) << XS1_COPROC_TBV0_WAITING_SHIFT)
/**
 * Extract the COPROC_TBV0_WAITING bitfield from a packed word x and return it.
 */
#define XS1_COPROC_TBV0_WAITING(x) (((x) & XS1_COPROC_TBV0_WAITING_MASK) >> XS1_COPROC_TBV0_WAITING_SHIFT)
/**
 * Pack the value (v) of the COPROC_TBV0_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_COPROC_TBV0_WAITING_SET(x, v) (((x) & ~XS1_COPROC_TBV0_WAITING_MASK) | (((v) << XS1_COPROC_TBV0_WAITING_SHIFT) & XS1_COPROC_TBV0_WAITING_MASK))
///@}
/**
 * \name RES_ID_TYPE
 * \anchor RES_ID_TYPE
 * The type of a resource.
 */
///@{
#define XS1_RES_ID_TYPE_SHIFT 0x0
#define XS1_RES_ID_TYPE_SIZE 0x4
#define XS1_RES_ID_TYPE_MASK (((1 << XS1_RES_ID_TYPE_SIZE) - 1) << XS1_RES_ID_TYPE_SHIFT)
/**
 * Extract the RES_ID_TYPE bitfield from a packed word x and return it.
 */
#define XS1_RES_ID_TYPE(x) (((x) & XS1_RES_ID_TYPE_MASK) >> XS1_RES_ID_TYPE_SHIFT)
/**
 * Pack the value (v) of the RES_ID_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_RES_ID_TYPE_SET(x, v) (((x) & ~XS1_RES_ID_TYPE_MASK) | (((v) << XS1_RES_ID_TYPE_SHIFT) & XS1_RES_ID_TYPE_MASK))
///@}
/**
 * \name RES_ID_REGID
 * \anchor RES_ID_REGID
 * The register ID for resource ``GETPS`` / ``SETPS`` accesses. Must be 0 otherwise.
 */
///@{
#define XS1_RES_ID_REGID_SHIFT 0x4
#define XS1_RES_ID_REGID_SIZE 0x4
#define XS1_RES_ID_REGID_MASK (((1 << XS1_RES_ID_REGID_SIZE) - 1) << XS1_RES_ID_REGID_SHIFT)
/**
 * Extract the RES_ID_REGID bitfield from a packed word x and return it.
 */
#define XS1_RES_ID_REGID(x) (((x) & XS1_RES_ID_REGID_MASK) >> XS1_RES_ID_REGID_SHIFT)
/**
 * Pack the value (v) of the RES_ID_REGID bitfield into a packed word x and return the packed field.
 */
#define XS1_RES_ID_REGID_SET(x, v) (((x) & ~XS1_RES_ID_REGID_MASK) | (((v) << XS1_RES_ID_REGID_SHIFT) & XS1_RES_ID_REGID_MASK))
///@}
/**
 * \name RES_ID_RESNUM
 * \anchor RES_ID_RESNUM
 * The resource number of a resource.
 */
///@{
#define XS1_RES_ID_RESNUM_SHIFT 0x8
#define XS1_RES_ID_RESNUM_SIZE 0x8
#define XS1_RES_ID_RESNUM_MASK (((1 << XS1_RES_ID_RESNUM_SIZE) - 1) << XS1_RES_ID_RESNUM_SHIFT)
/**
 * Extract the RES_ID_RESNUM bitfield from a packed word x and return it.
 */
#define XS1_RES_ID_RESNUM(x) (((x) & XS1_RES_ID_RESNUM_MASK) >> XS1_RES_ID_RESNUM_SHIFT)
/**
 * Pack the value (v) of the RES_ID_RESNUM bitfield into a packed word x and return the packed field.
 */
#define XS1_RES_ID_RESNUM_SET(x, v) (((x) & ~XS1_RES_ID_RESNUM_MASK) | (((v) << XS1_RES_ID_RESNUM_SHIFT) & XS1_RES_ID_RESNUM_MASK))
///@}
/**
 * \name RES_ID_PORTWIDTH
 * \anchor RES_ID_PORTWIDTH
 * The size of a port - zero for all resources which are not ports.
 */
///@{
#define XS1_RES_ID_PORTWIDTH_SHIFT 0x10
#define XS1_RES_ID_PORTWIDTH_SIZE 0x6
#define XS1_RES_ID_PORTWIDTH_MASK (((1 << XS1_RES_ID_PORTWIDTH_SIZE) - 1) << XS1_RES_ID_PORTWIDTH_SHIFT)
/**
 * Extract the RES_ID_PORTWIDTH bitfield from a packed word x and return it.
 */
#define XS1_RES_ID_PORTWIDTH(x) (((x) & XS1_RES_ID_PORTWIDTH_MASK) >> XS1_RES_ID_PORTWIDTH_SHIFT)
/**
 * Pack the value (v) of the RES_ID_PORTWIDTH bitfield into a packed word x and return the packed field.
 */
#define XS1_RES_ID_PORTWIDTH_SET(x, v) (((x) & ~XS1_RES_ID_PORTWIDTH_MASK) | (((v) << XS1_RES_ID_PORTWIDTH_SHIFT) & XS1_RES_ID_PORTWIDTH_MASK))
///@}
/**
 * \name CHAN_ID_CHANNUM
 * \anchor CHAN_ID_CHANNUM
 * The channel end number.
 */
///@{
#define XS1_CHAN_ID_CHANNUM_SHIFT 0x8
#define XS1_CHAN_ID_CHANNUM_SIZE 0x8
#define XS1_CHAN_ID_CHANNUM_MASK (((1 << XS1_CHAN_ID_CHANNUM_SIZE) - 1) << XS1_CHAN_ID_CHANNUM_SHIFT)
/**
 * Extract the CHAN_ID_CHANNUM bitfield from a packed word x and return it.
 */
#define XS1_CHAN_ID_CHANNUM(x) (((x) & XS1_CHAN_ID_CHANNUM_MASK) >> XS1_CHAN_ID_CHANNUM_SHIFT)
/**
 * Pack the value (v) of the CHAN_ID_CHANNUM bitfield into a packed word x and return the packed field.
 */
#define XS1_CHAN_ID_CHANNUM_SET(x, v) (((x) & ~XS1_CHAN_ID_CHANNUM_MASK) | (((v) << XS1_CHAN_ID_CHANNUM_SHIFT) & XS1_CHAN_ID_CHANNUM_MASK))
///@}
/**
 * \name CHAN_ID_PROCESSOR
 * \anchor CHAN_ID_PROCESSOR
 * The processor to which this resource belongs.
 */
///@{
#define XS1_CHAN_ID_PROCESSOR_SHIFT 0x10
#define XS1_CHAN_ID_PROCESSOR_SIZE 0x8
#define XS1_CHAN_ID_PROCESSOR_MASK (((1 << XS1_CHAN_ID_PROCESSOR_SIZE) - 1) << XS1_CHAN_ID_PROCESSOR_SHIFT)
/**
 * Extract the CHAN_ID_PROCESSOR bitfield from a packed word x and return it.
 */
#define XS1_CHAN_ID_PROCESSOR(x) (((x) & XS1_CHAN_ID_PROCESSOR_MASK) >> XS1_CHAN_ID_PROCESSOR_SHIFT)
/**
 * Pack the value (v) of the CHAN_ID_PROCESSOR bitfield into a packed word x and return the packed field.
 */
#define XS1_CHAN_ID_PROCESSOR_SET(x, v) (((x) & ~XS1_CHAN_ID_PROCESSOR_MASK) | (((v) << XS1_CHAN_ID_PROCESSOR_SHIFT) & XS1_CHAN_ID_PROCESSOR_MASK))
///@}
/**
 * \name CHAN_ID_NODE
 * \anchor CHAN_ID_NODE
 * The node in which this resource is found.
 */
///@{
#define XS1_CHAN_ID_NODE_SHIFT 0x18
#define XS1_CHAN_ID_NODE_SIZE 0x8
#define XS1_CHAN_ID_NODE_MASK (((1 << XS1_CHAN_ID_NODE_SIZE) - 1) << XS1_CHAN_ID_NODE_SHIFT)
/**
 * Extract the CHAN_ID_NODE bitfield from a packed word x and return it.
 */
#define XS1_CHAN_ID_NODE(x) (((x) & XS1_CHAN_ID_NODE_MASK) >> XS1_CHAN_ID_NODE_SHIFT)
/**
 * Pack the value (v) of the CHAN_ID_NODE bitfield into a packed word x and return the packed field.
 */
#define XS1_CHAN_ID_NODE_SET(x, v) (((x) & ~XS1_CHAN_ID_NODE_MASK) | (((v) << XS1_CHAN_ID_NODE_SHIFT) & XS1_CHAN_ID_NODE_MASK))
///@}
/**
 * \name HEADER_1BYTE_CHANNUM
 * \anchor HEADER_1BYTE_CHANNUM
 * The channel end number.
 */
///@{
#define XS1_HEADER_1BYTE_CHANNUM_SHIFT 0x0
#define XS1_HEADER_1BYTE_CHANNUM_SIZE 0x5
#define XS1_HEADER_1BYTE_CHANNUM_MASK (((1 << XS1_HEADER_1BYTE_CHANNUM_SIZE) - 1) << XS1_HEADER_1BYTE_CHANNUM_SHIFT)
/**
 * Extract the HEADER_1BYTE_CHANNUM bitfield from a packed word x and return it.
 */
#define XS1_HEADER_1BYTE_CHANNUM(x) (((x) & XS1_HEADER_1BYTE_CHANNUM_MASK) >> XS1_HEADER_1BYTE_CHANNUM_SHIFT)
/**
 * Pack the value (v) of the HEADER_1BYTE_CHANNUM bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_1BYTE_CHANNUM_SET(x, v) (((x) & ~XS1_HEADER_1BYTE_CHANNUM_MASK) | (((v) << XS1_HEADER_1BYTE_CHANNUM_SHIFT) & XS1_HEADER_1BYTE_CHANNUM_MASK))
///@}
/**
 * \name HEADER_1BYTE_PROCESSOR
 * \anchor HEADER_1BYTE_PROCESSOR
 * The processor to which this resource belongs.
 */
///@{
#define XS1_HEADER_1BYTE_PROCESSOR_SHIFT 0x5
#define XS1_HEADER_1BYTE_PROCESSOR_SIZE 0x2
#define XS1_HEADER_1BYTE_PROCESSOR_MASK (((1 << XS1_HEADER_1BYTE_PROCESSOR_SIZE) - 1) << XS1_HEADER_1BYTE_PROCESSOR_SHIFT)
/**
 * Extract the HEADER_1BYTE_PROCESSOR bitfield from a packed word x and return it.
 */
#define XS1_HEADER_1BYTE_PROCESSOR(x) (((x) & XS1_HEADER_1BYTE_PROCESSOR_MASK) >> XS1_HEADER_1BYTE_PROCESSOR_SHIFT)
/**
 * Pack the value (v) of the HEADER_1BYTE_PROCESSOR bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_1BYTE_PROCESSOR_SET(x, v) (((x) & ~XS1_HEADER_1BYTE_PROCESSOR_MASK) | (((v) << XS1_HEADER_1BYTE_PROCESSOR_SHIFT) & XS1_HEADER_1BYTE_PROCESSOR_MASK))
///@}
/**
 * \name HEADER_1BYTE_NODE
 * \anchor HEADER_1BYTE_NODE
 * The node in which this resource is found.
 */
///@{
#define XS1_HEADER_1BYTE_NODE_SHIFT 0x7
#define XS1_HEADER_1BYTE_NODE_SIZE 0x1
#define XS1_HEADER_1BYTE_NODE_MASK (((1 << XS1_HEADER_1BYTE_NODE_SIZE) - 1) << XS1_HEADER_1BYTE_NODE_SHIFT)
/**
 * Extract the HEADER_1BYTE_NODE bitfield from a packed word x and return it.
 */
#define XS1_HEADER_1BYTE_NODE(x) (((x) & XS1_HEADER_1BYTE_NODE_MASK) >> XS1_HEADER_1BYTE_NODE_SHIFT)
/**
 * Pack the value (v) of the HEADER_1BYTE_NODE bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_1BYTE_NODE_SET(x, v) (((x) & ~XS1_HEADER_1BYTE_NODE_MASK) | (((v) << XS1_HEADER_1BYTE_NODE_SHIFT) & XS1_HEADER_1BYTE_NODE_MASK))
///@}
/**
 * \name HEADER_3BYTE_CHANNUM
 * \anchor HEADER_3BYTE_CHANNUM
 * The channel end number.
 */
///@{
#define XS1_HEADER_3BYTE_CHANNUM_SHIFT 0x0
#define XS1_HEADER_3BYTE_CHANNUM_SIZE 0x8
#define XS1_HEADER_3BYTE_CHANNUM_MASK (((1 << XS1_HEADER_3BYTE_CHANNUM_SIZE) - 1) << XS1_HEADER_3BYTE_CHANNUM_SHIFT)
/**
 * Extract the HEADER_3BYTE_CHANNUM bitfield from a packed word x and return it.
 */
#define XS1_HEADER_3BYTE_CHANNUM(x) (((x) & XS1_HEADER_3BYTE_CHANNUM_MASK) >> XS1_HEADER_3BYTE_CHANNUM_SHIFT)
/**
 * Pack the value (v) of the HEADER_3BYTE_CHANNUM bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_3BYTE_CHANNUM_SET(x, v) (((x) & ~XS1_HEADER_3BYTE_CHANNUM_MASK) | (((v) << XS1_HEADER_3BYTE_CHANNUM_SHIFT) & XS1_HEADER_3BYTE_CHANNUM_MASK))
///@}
/**
 * \name HEADER_3BYTE_PROCESSOR
 * \anchor HEADER_3BYTE_PROCESSOR
 * The processor to which this resource belongs.
 */
///@{
#define XS1_HEADER_3BYTE_PROCESSOR_SHIFT 0x8
#define XS1_HEADER_3BYTE_PROCESSOR_SIZE 0x8
#define XS1_HEADER_3BYTE_PROCESSOR_MASK (((1 << XS1_HEADER_3BYTE_PROCESSOR_SIZE) - 1) << XS1_HEADER_3BYTE_PROCESSOR_SHIFT)
/**
 * Extract the HEADER_3BYTE_PROCESSOR bitfield from a packed word x and return it.
 */
#define XS1_HEADER_3BYTE_PROCESSOR(x) (((x) & XS1_HEADER_3BYTE_PROCESSOR_MASK) >> XS1_HEADER_3BYTE_PROCESSOR_SHIFT)
/**
 * Pack the value (v) of the HEADER_3BYTE_PROCESSOR bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_3BYTE_PROCESSOR_SET(x, v) (((x) & ~XS1_HEADER_3BYTE_PROCESSOR_MASK) | (((v) << XS1_HEADER_3BYTE_PROCESSOR_SHIFT) & XS1_HEADER_3BYTE_PROCESSOR_MASK))
///@}
/**
 * \name HEADER_3BYTE_NODE
 * \anchor HEADER_3BYTE_NODE
 * The node in which this resource is found.
 */
///@{
#define XS1_HEADER_3BYTE_NODE_SHIFT 0x10
#define XS1_HEADER_3BYTE_NODE_SIZE 0x8
#define XS1_HEADER_3BYTE_NODE_MASK (((1 << XS1_HEADER_3BYTE_NODE_SIZE) - 1) << XS1_HEADER_3BYTE_NODE_SHIFT)
/**
 * Extract the HEADER_3BYTE_NODE bitfield from a packed word x and return it.
 */
#define XS1_HEADER_3BYTE_NODE(x) (((x) & XS1_HEADER_3BYTE_NODE_MASK) >> XS1_HEADER_3BYTE_NODE_SHIFT)
/**
 * Pack the value (v) of the HEADER_3BYTE_NODE bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_3BYTE_NODE_SET(x, v) (((x) & ~XS1_HEADER_3BYTE_NODE_MASK) | (((v) << XS1_HEADER_3BYTE_NODE_SHIFT) & XS1_HEADER_3BYTE_NODE_MASK))
///@}
/**
 * \name SETCTRL_MODE
 * \anchor SETCTRL_MODE
 * Select mode to change.
 */
///@{
#define XS1_SETC_MODE_SHIFT 0x0
#define XS1_SETC_MODE_SIZE 0x3
#define XS1_SETC_MODE_MASK (((1 << XS1_SETC_MODE_SIZE) - 1) << XS1_SETC_MODE_SHIFT)
/**
 * Extract the SETCTRL_MODE bitfield from a packed word x and return it.
 */
#define XS1_SETC_MODE(x) (((x) & XS1_SETC_MODE_MASK) >> XS1_SETC_MODE_SHIFT)
/**
 * Pack the value (v) of the SETCTRL_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_MODE_SET(x, v) (((x) & ~XS1_SETC_MODE_MASK) | (((v) << XS1_SETC_MODE_SHIFT) & XS1_SETC_MODE_MASK))
///@}
/**
 * \name SETCTRL_VALUE
 * \anchor SETCTRL_VALUE
 * Value for mode change.
 */
///@{
#define XS1_SETC_VALUE_SHIFT 0x3
#define XS1_SETC_VALUE_SIZE 0x9
#define XS1_SETC_VALUE_MASK (((1 << XS1_SETC_VALUE_SIZE) - 1) << XS1_SETC_VALUE_SHIFT)
/**
 * Extract the SETCTRL_VALUE bitfield from a packed word x and return it.
 */
#define XS1_SETC_VALUE(x) (((x) & XS1_SETC_VALUE_MASK) >> XS1_SETC_VALUE_SHIFT)
/**
 * Pack the value (v) of the SETCTRL_VALUE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_VALUE_SET(x, v) (((x) & ~XS1_SETC_VALUE_MASK) | (((v) << XS1_SETC_VALUE_SHIFT) & XS1_SETC_VALUE_MASK))
///@}
/**
 * \name SETCTRL_LMODE
 * \anchor SETCTRL_LMODE
 * Long mode bits.
 */
///@{
#define XS1_SETC_LMODE_SHIFT 0xc
#define XS1_SETC_LMODE_SIZE 0x4
#define XS1_SETC_LMODE_MASK (((1 << XS1_SETC_LMODE_SIZE) - 1) << XS1_SETC_LMODE_SHIFT)
/**
 * Extract the SETCTRL_LMODE bitfield from a packed word x and return it.
 */
#define XS1_SETC_LMODE(x) (((x) & XS1_SETC_LMODE_MASK) >> XS1_SETC_LMODE_SHIFT)
/**
 * Pack the value (v) of the SETCTRL_LMODE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_LMODE_SET(x, v) (((x) & ~XS1_SETC_LMODE_MASK) | (((v) << XS1_SETC_LMODE_SHIFT) & XS1_SETC_LMODE_MASK))
///@}
/**
 * \name MMAPCTRL_MODE
 * \anchor MMAPCTRL_MODE
 * Select mode to change.
 */
///@{
#define XS1_SETC_MMAP_MODE_SHIFT 0x0
#define XS1_SETC_MMAP_MODE_SIZE 0x8
#define XS1_SETC_MMAP_MODE_MASK (((1 << XS1_SETC_MMAP_MODE_SIZE) - 1) << XS1_SETC_MMAP_MODE_SHIFT)
/**
 * Extract the MMAPCTRL_MODE bitfield from a packed word x and return it.
 */
#define XS1_SETC_MMAP_MODE(x) (((x) & XS1_SETC_MMAP_MODE_MASK) >> XS1_SETC_MMAP_MODE_SHIFT)
/**
 * Pack the value (v) of the MMAPCTRL_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_MMAP_MODE_SET(x, v) (((x) & ~XS1_SETC_MMAP_MODE_MASK) | (((v) << XS1_SETC_MMAP_MODE_SHIFT) & XS1_SETC_MMAP_MODE_MASK))
///@}
/**
 * \name MMAPCTRL_VALUE
 * \anchor MMAPCTRL_VALUE
 * Value for mode change.
 */
///@{
#define XS1_SETC_MMAP_VALUE_SHIFT 0x8
#define XS1_SETC_MMAP_VALUE_SIZE 0x18
#define XS1_SETC_MMAP_VALUE_MASK (((1 << XS1_SETC_MMAP_VALUE_SIZE) - 1) << XS1_SETC_MMAP_VALUE_SHIFT)
/**
 * Extract the MMAPCTRL_VALUE bitfield from a packed word x and return it.
 */
#define XS1_SETC_MMAP_VALUE(x) (((x) & XS1_SETC_MMAP_VALUE_MASK) >> XS1_SETC_MMAP_VALUE_SHIFT)
/**
 * Pack the value (v) of the MMAPCTRL_VALUE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_MMAP_VALUE_SET(x, v) (((x) & ~XS1_SETC_MMAP_VALUE_MASK) | (((v) << XS1_SETC_MMAP_VALUE_SHIFT) & XS1_SETC_MMAP_VALUE_MASK))
///@}
/**
 * \name DBG_INT_REQ_DBG
 * \anchor DBG_INT_REQ_DBG
 * Request a debug interrupt on the processor.
 */
///@{
#define XS1_DBG_INT_REQ_DBG_SHIFT 0x0
#define XS1_DBG_INT_REQ_DBG_SIZE 0x1
#define XS1_DBG_INT_REQ_DBG_MASK (((1 << XS1_DBG_INT_REQ_DBG_SIZE) - 1) << XS1_DBG_INT_REQ_DBG_SHIFT)
/**
 * Extract the DBG_INT_REQ_DBG bitfield from a packed word x and return it.
 */
#define XS1_DBG_INT_REQ_DBG(x) (((x) & XS1_DBG_INT_REQ_DBG_MASK) >> XS1_DBG_INT_REQ_DBG_SHIFT)
/**
 * Pack the value (v) of the DBG_INT_REQ_DBG bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_INT_REQ_DBG_SET(x, v) (((x) & ~XS1_DBG_INT_REQ_DBG_MASK) | (((v) << XS1_DBG_INT_REQ_DBG_SHIFT) & XS1_DBG_INT_REQ_DBG_MASK))
///@}
/**
 * \name DBG_INT_IN_DBG
 * \anchor DBG_INT_IN_DBG
 * 1 when the processor is in debug mode.
 */
///@{
#define XS1_DBG_INT_IN_DBG_SHIFT 0x1
#define XS1_DBG_INT_IN_DBG_SIZE 0x1
#define XS1_DBG_INT_IN_DBG_MASK (((1 << XS1_DBG_INT_IN_DBG_SIZE) - 1) << XS1_DBG_INT_IN_DBG_SHIFT)
/**
 * Extract the DBG_INT_IN_DBG bitfield from a packed word x and return it.
 */
#define XS1_DBG_INT_IN_DBG(x) (((x) & XS1_DBG_INT_IN_DBG_MASK) >> XS1_DBG_INT_IN_DBG_SHIFT)
/**
 * Pack the value (v) of the DBG_INT_IN_DBG bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_INT_IN_DBG_SET(x, v) (((x) & ~XS1_DBG_INT_IN_DBG_MASK) | (((v) << XS1_DBG_INT_IN_DBG_SHIFT) & XS1_DBG_INT_IN_DBG_MASK))
///@}
/**
 * \name DBG_CTRL_PSWITCH_RO_EXT
 * \anchor DBG_CTRL_PSWITCH_RO_EXT
 * When 1 the PSwitch is restricted to RO access to all CRW registers from SSwitch 
 */
///@{
#define XS1_DBG_CTRL_PSWITCH_RO_EXT_SHIFT 0x0
#define XS1_DBG_CTRL_PSWITCH_RO_EXT_SIZE 0x1
#define XS1_DBG_CTRL_PSWITCH_RO_EXT_MASK (((1 << XS1_DBG_CTRL_PSWITCH_RO_EXT_SIZE) - 1) << XS1_DBG_CTRL_PSWITCH_RO_EXT_SHIFT)
/**
 * Extract the DBG_CTRL_PSWITCH_RO_EXT bitfield from a packed word x and return it.
 */
#define XS1_DBG_CTRL_PSWITCH_RO_EXT(x) (((x) & XS1_DBG_CTRL_PSWITCH_RO_EXT_MASK) >> XS1_DBG_CTRL_PSWITCH_RO_EXT_SHIFT)
/**
 * Pack the value (v) of the DBG_CTRL_PSWITCH_RO_EXT bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_CTRL_PSWITCH_RO_EXT_SET(x, v) (((x) & ~XS1_DBG_CTRL_PSWITCH_RO_EXT_MASK) | (((v) << XS1_DBG_CTRL_PSWITCH_RO_EXT_SHIFT) & XS1_DBG_CTRL_PSWITCH_RO_EXT_MASK))
///@}
/**
 * \name DBG_CTRL_PSWITCH_RO
 * \anchor DBG_CTRL_PSWITCH_RO
 * When 1 the PSwitch is restricted to RO access to all CRW registers from SSwitch, XCore(PS_DBG_Scratch) and JTAG 
 */
///@{
#define XS1_DBG_CTRL_PSWITCH_RO_SHIFT 0x1f
#define XS1_DBG_CTRL_PSWITCH_RO_SIZE 0x1
#define XS1_DBG_CTRL_PSWITCH_RO_MASK (((1 << XS1_DBG_CTRL_PSWITCH_RO_SIZE) - 1) << XS1_DBG_CTRL_PSWITCH_RO_SHIFT)
/**
 * Extract the DBG_CTRL_PSWITCH_RO bitfield from a packed word x and return it.
 */
#define XS1_DBG_CTRL_PSWITCH_RO(x) (((x) & XS1_DBG_CTRL_PSWITCH_RO_MASK) >> XS1_DBG_CTRL_PSWITCH_RO_SHIFT)
/**
 * Pack the value (v) of the DBG_CTRL_PSWITCH_RO bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_CTRL_PSWITCH_RO_SET(x, v) (((x) & ~XS1_DBG_CTRL_PSWITCH_RO_MASK) | (((v) << XS1_DBG_CTRL_PSWITCH_RO_SHIFT) & XS1_DBG_CTRL_PSWITCH_RO_MASK))
///@}
/**
 * \name DEVICE_ID0_VERSION
 * \anchor DEVICE_ID0_VERSION
 * XCore version.
 */
///@{
#define XS1_DEVICE_ID0_VERSION_SHIFT 0x0
#define XS1_DEVICE_ID0_VERSION_SIZE 0x8
#define XS1_DEVICE_ID0_VERSION_MASK (((1 << XS1_DEVICE_ID0_VERSION_SIZE) - 1) << XS1_DEVICE_ID0_VERSION_SHIFT)
/**
 * Extract the DEVICE_ID0_VERSION bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID0_VERSION(x) (((x) & XS1_DEVICE_ID0_VERSION_MASK) >> XS1_DEVICE_ID0_VERSION_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID0_VERSION bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID0_VERSION_SET(x, v) (((x) & ~XS1_DEVICE_ID0_VERSION_MASK) | (((v) << XS1_DEVICE_ID0_VERSION_SHIFT) & XS1_DEVICE_ID0_VERSION_MASK))
///@}
/**
 * \name DEVICE_ID0_REVISION
 * \anchor DEVICE_ID0_REVISION
 * XCore revision.
 */
///@{
#define XS1_DEVICE_ID0_REVISION_SHIFT 0x8
#define XS1_DEVICE_ID0_REVISION_SIZE 0x8
#define XS1_DEVICE_ID0_REVISION_MASK (((1 << XS1_DEVICE_ID0_REVISION_SIZE) - 1) << XS1_DEVICE_ID0_REVISION_SHIFT)
/**
 * Extract the DEVICE_ID0_REVISION bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID0_REVISION(x) (((x) & XS1_DEVICE_ID0_REVISION_MASK) >> XS1_DEVICE_ID0_REVISION_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID0_REVISION bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID0_REVISION_SET(x, v) (((x) & ~XS1_DEVICE_ID0_REVISION_MASK) | (((v) << XS1_DEVICE_ID0_REVISION_SHIFT) & XS1_DEVICE_ID0_REVISION_MASK))
///@}
/**
 * \name DEVICE_ID0_NODE
 * \anchor DEVICE_ID0_NODE
 * Number of the node in which this XCore is located.
 */
///@{
#define XS1_DEVICE_ID0_NODE_SHIFT 0x10
#define XS1_DEVICE_ID0_NODE_SIZE 0x8
#define XS1_DEVICE_ID0_NODE_MASK (((1 << XS1_DEVICE_ID0_NODE_SIZE) - 1) << XS1_DEVICE_ID0_NODE_SHIFT)
/**
 * Extract the DEVICE_ID0_NODE bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID0_NODE(x) (((x) & XS1_DEVICE_ID0_NODE_MASK) >> XS1_DEVICE_ID0_NODE_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID0_NODE bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID0_NODE_SET(x, v) (((x) & ~XS1_DEVICE_ID0_NODE_MASK) | (((v) << XS1_DEVICE_ID0_NODE_SHIFT) & XS1_DEVICE_ID0_NODE_MASK))
///@}
/**
 * \name DEVICE_ID0_PID
 * \anchor DEVICE_ID0_PID
 * Processor ID of this XCore.
 */
///@{
#define XS1_DEVICE_ID0_PID_SHIFT 0x18
#define XS1_DEVICE_ID0_PID_SIZE 0x8
#define XS1_DEVICE_ID0_PID_MASK (((1 << XS1_DEVICE_ID0_PID_SIZE) - 1) << XS1_DEVICE_ID0_PID_SHIFT)
/**
 * Extract the DEVICE_ID0_PID bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID0_PID(x) (((x) & XS1_DEVICE_ID0_PID_MASK) >> XS1_DEVICE_ID0_PID_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID0_PID bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID0_PID_SET(x, v) (((x) & ~XS1_DEVICE_ID0_PID_MASK) | (((v) << XS1_DEVICE_ID0_PID_SHIFT) & XS1_DEVICE_ID0_PID_MASK))
///@}
/**
 * \name DEVICE_ID1_NUM_THREADS
 * \anchor DEVICE_ID1_NUM_THREADS
 * Number of threads.
 */
///@{
#define XS1_DEVICE_ID1_NUM_THREADS_SHIFT 0x0
#define XS1_DEVICE_ID1_NUM_THREADS_SIZE 0x8
#define XS1_DEVICE_ID1_NUM_THREADS_MASK (((1 << XS1_DEVICE_ID1_NUM_THREADS_SIZE) - 1) << XS1_DEVICE_ID1_NUM_THREADS_SHIFT)
/**
 * Extract the DEVICE_ID1_NUM_THREADS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID1_NUM_THREADS(x) (((x) & XS1_DEVICE_ID1_NUM_THREADS_MASK) >> XS1_DEVICE_ID1_NUM_THREADS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID1_NUM_THREADS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID1_NUM_THREADS_SET(x, v) (((x) & ~XS1_DEVICE_ID1_NUM_THREADS_MASK) | (((v) << XS1_DEVICE_ID1_NUM_THREADS_SHIFT) & XS1_DEVICE_ID1_NUM_THREADS_MASK))
///@}
/**
 * \name DEVICE_ID1_NUM_SYNCS
 * \anchor DEVICE_ID1_NUM_SYNCS
 * Number of synchronisers.
 */
///@{
#define XS1_DEVICE_ID1_NUM_SYNCS_SHIFT 0x8
#define XS1_DEVICE_ID1_NUM_SYNCS_SIZE 0x8
#define XS1_DEVICE_ID1_NUM_SYNCS_MASK (((1 << XS1_DEVICE_ID1_NUM_SYNCS_SIZE) - 1) << XS1_DEVICE_ID1_NUM_SYNCS_SHIFT)
/**
 * Extract the DEVICE_ID1_NUM_SYNCS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID1_NUM_SYNCS(x) (((x) & XS1_DEVICE_ID1_NUM_SYNCS_MASK) >> XS1_DEVICE_ID1_NUM_SYNCS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID1_NUM_SYNCS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID1_NUM_SYNCS_SET(x, v) (((x) & ~XS1_DEVICE_ID1_NUM_SYNCS_MASK) | (((v) << XS1_DEVICE_ID1_NUM_SYNCS_SHIFT) & XS1_DEVICE_ID1_NUM_SYNCS_MASK))
///@}
/**
 * \name DEVICE_ID1_NUM_LOCKS
 * \anchor DEVICE_ID1_NUM_LOCKS
 * Number of the locks.
 */
///@{
#define XS1_DEVICE_ID1_NUM_LOCKS_SHIFT 0x10
#define XS1_DEVICE_ID1_NUM_LOCKS_SIZE 0x8
#define XS1_DEVICE_ID1_NUM_LOCKS_MASK (((1 << XS1_DEVICE_ID1_NUM_LOCKS_SIZE) - 1) << XS1_DEVICE_ID1_NUM_LOCKS_SHIFT)
/**
 * Extract the DEVICE_ID1_NUM_LOCKS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID1_NUM_LOCKS(x) (((x) & XS1_DEVICE_ID1_NUM_LOCKS_MASK) >> XS1_DEVICE_ID1_NUM_LOCKS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID1_NUM_LOCKS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID1_NUM_LOCKS_SET(x, v) (((x) & ~XS1_DEVICE_ID1_NUM_LOCKS_MASK) | (((v) << XS1_DEVICE_ID1_NUM_LOCKS_SHIFT) & XS1_DEVICE_ID1_NUM_LOCKS_MASK))
///@}
/**
 * \name DEVICE_ID1_NUM_CHANENDS
 * \anchor DEVICE_ID1_NUM_CHANENDS
 * Number of channel ends.
 */
///@{
#define XS1_DEVICE_ID1_NUM_CHANENDS_SHIFT 0x18
#define XS1_DEVICE_ID1_NUM_CHANENDS_SIZE 0x8
#define XS1_DEVICE_ID1_NUM_CHANENDS_MASK (((1 << XS1_DEVICE_ID1_NUM_CHANENDS_SIZE) - 1) << XS1_DEVICE_ID1_NUM_CHANENDS_SHIFT)
/**
 * Extract the DEVICE_ID1_NUM_CHANENDS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID1_NUM_CHANENDS(x) (((x) & XS1_DEVICE_ID1_NUM_CHANENDS_MASK) >> XS1_DEVICE_ID1_NUM_CHANENDS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID1_NUM_CHANENDS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID1_NUM_CHANENDS_SET(x, v) (((x) & ~XS1_DEVICE_ID1_NUM_CHANENDS_MASK) | (((v) << XS1_DEVICE_ID1_NUM_CHANENDS_SHIFT) & XS1_DEVICE_ID1_NUM_CHANENDS_MASK))
///@}
/**
 * \name DEVICE_ID2_NUM_TIMERS
 * \anchor DEVICE_ID2_NUM_TIMERS
 * Number of timers.
 */
///@{
#define XS1_DEVICE_ID2_NUM_TIMERS_SHIFT 0x0
#define XS1_DEVICE_ID2_NUM_TIMERS_SIZE 0x8
#define XS1_DEVICE_ID2_NUM_TIMERS_MASK (((1 << XS1_DEVICE_ID2_NUM_TIMERS_SIZE) - 1) << XS1_DEVICE_ID2_NUM_TIMERS_SHIFT)
/**
 * Extract the DEVICE_ID2_NUM_TIMERS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID2_NUM_TIMERS(x) (((x) & XS1_DEVICE_ID2_NUM_TIMERS_MASK) >> XS1_DEVICE_ID2_NUM_TIMERS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID2_NUM_TIMERS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID2_NUM_TIMERS_SET(x, v) (((x) & ~XS1_DEVICE_ID2_NUM_TIMERS_MASK) | (((v) << XS1_DEVICE_ID2_NUM_TIMERS_SHIFT) & XS1_DEVICE_ID2_NUM_TIMERS_MASK))
///@}
/**
 * \name DEVICE_ID2_NUM_CLKBLKS
 * \anchor DEVICE_ID2_NUM_CLKBLKS
 * Number of clock blocks.
 */
///@{
#define XS1_DEVICE_ID2_NUM_CLKBLKS_SHIFT 0x8
#define XS1_DEVICE_ID2_NUM_CLKBLKS_SIZE 0x8
#define XS1_DEVICE_ID2_NUM_CLKBLKS_MASK (((1 << XS1_DEVICE_ID2_NUM_CLKBLKS_SIZE) - 1) << XS1_DEVICE_ID2_NUM_CLKBLKS_SHIFT)
/**
 * Extract the DEVICE_ID2_NUM_CLKBLKS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID2_NUM_CLKBLKS(x) (((x) & XS1_DEVICE_ID2_NUM_CLKBLKS_MASK) >> XS1_DEVICE_ID2_NUM_CLKBLKS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID2_NUM_CLKBLKS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID2_NUM_CLKBLKS_SET(x, v) (((x) & ~XS1_DEVICE_ID2_NUM_CLKBLKS_MASK) | (((v) << XS1_DEVICE_ID2_NUM_CLKBLKS_SHIFT) & XS1_DEVICE_ID2_NUM_CLKBLKS_MASK))
///@}
/**
 * \name JUNK
 * \anchor JUNK
 * 1 when the current packet is considered junk and will be thrown away.
 */
///@{
#define XS1_JUNK_SHIFT 0x2
#define XS1_JUNK_SIZE 0x1
#define XS1_JUNK_MASK (((1 << XS1_JUNK_SIZE) - 1) << XS1_JUNK_SHIFT)
/**
 * Extract the JUNK bitfield from a packed word x and return it.
 */
#define XS1_JUNK(x) (((x) & XS1_JUNK_MASK) >> XS1_JUNK_SHIFT)
/**
 * Pack the value (v) of the JUNK bitfield into a packed word x and return the packed field.
 */
#define XS1_JUNK_SET(x, v) (((x) & ~XS1_JUNK_MASK) | (((v) << XS1_JUNK_SHIFT) & XS1_JUNK_MASK))
///@}
/**
 * \name NETWORK
 * \anchor NETWORK
 * Network ID for the PLink.
 */
///@{
#define XS1_NETWORK_SHIFT 0x4
#define XS1_NETWORK_SIZE 0x2
#define XS1_NETWORK_MASK (((1 << XS1_NETWORK_SIZE) - 1) << XS1_NETWORK_SHIFT)
/**
 * Extract the NETWORK bitfield from a packed word x and return it.
 */
#define XS1_NETWORK(x) (((x) & XS1_NETWORK_MASK) >> XS1_NETWORK_SHIFT)
/**
 * Pack the value (v) of the NETWORK bitfield into a packed word x and return the packed field.
 */
#define XS1_NETWORK_SET(x, v) (((x) & ~XS1_NETWORK_MASK) | (((v) << XS1_NETWORK_SHIFT) & XS1_NETWORK_MASK))
///@}
/**
 * \name SRC_TARGET_ID
 * \anchor SRC_TARGET_ID
 * Based on SRC_TARGET_TYPE value, it represents channelEnd ID or Idle status.
 */
///@{
#define XS1_SRC_TARGET_ID_SHIFT 0x10
#define XS1_SRC_TARGET_ID_SIZE 0x8
#define XS1_SRC_TARGET_ID_MASK (((1 << XS1_SRC_TARGET_ID_SIZE) - 1) << XS1_SRC_TARGET_ID_SHIFT)
/**
 * Extract the SRC_TARGET_ID bitfield from a packed word x and return it.
 */
#define XS1_SRC_TARGET_ID(x) (((x) & XS1_SRC_TARGET_ID_MASK) >> XS1_SRC_TARGET_ID_SHIFT)
/**
 * Pack the value (v) of the SRC_TARGET_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_SRC_TARGET_ID_SET(x, v) (((x) & ~XS1_SRC_TARGET_ID_MASK) | (((v) << XS1_SRC_TARGET_ID_SHIFT) & XS1_SRC_TARGET_ID_MASK))
///@}
/**
 * \name SRC_TARGET_TYPE
 * \anchor SRC_TARGET_TYPE
 * 00 - ChannelEnd, 01 - ERROR, 10 - PSCTL, 11 - Idle.
 */
///@{
#define XS1_SRC_TARGET_TYPE_SHIFT 0x18
#define XS1_SRC_TARGET_TYPE_SIZE 0x2
#define XS1_SRC_TARGET_TYPE_MASK (((1 << XS1_SRC_TARGET_TYPE_SIZE) - 1) << XS1_SRC_TARGET_TYPE_SHIFT)
/**
 * Extract the SRC_TARGET_TYPE bitfield from a packed word x and return it.
 */
#define XS1_SRC_TARGET_TYPE(x) (((x) & XS1_SRC_TARGET_TYPE_MASK) >> XS1_SRC_TARGET_TYPE_SHIFT)
/**
 * Pack the value (v) of the SRC_TARGET_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_SRC_TARGET_TYPE_SET(x, v) (((x) & ~XS1_SRC_TARGET_TYPE_MASK) | (((v) << XS1_SRC_TARGET_TYPE_SHIFT) & XS1_SRC_TARGET_TYPE_MASK))
///@}
/**
 * \name SS_DEVICE_ID0_VERSION
 * \anchor SS_DEVICE_ID0_VERSION
 * SSwitch version.
 */
///@{
#define XS1_SS_DEVICE_ID0_VERSION_SHIFT 0x0
#define XS1_SS_DEVICE_ID0_VERSION_SIZE 0x8
#define XS1_SS_DEVICE_ID0_VERSION_MASK (((1 << XS1_SS_DEVICE_ID0_VERSION_SIZE) - 1) << XS1_SS_DEVICE_ID0_VERSION_SHIFT)
/**
 * Extract the SS_DEVICE_ID0_VERSION bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID0_VERSION(x) (((x) & XS1_SS_DEVICE_ID0_VERSION_MASK) >> XS1_SS_DEVICE_ID0_VERSION_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID0_VERSION bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID0_VERSION_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID0_VERSION_MASK) | (((v) << XS1_SS_DEVICE_ID0_VERSION_SHIFT) & XS1_SS_DEVICE_ID0_VERSION_MASK))
///@}
/**
 * \name SS_DEVICE_ID0_REVISION
 * \anchor SS_DEVICE_ID0_REVISION
 * SSwitch revision.
 */
///@{
#define XS1_SS_DEVICE_ID0_REVISION_SHIFT 0x8
#define XS1_SS_DEVICE_ID0_REVISION_SIZE 0x8
#define XS1_SS_DEVICE_ID0_REVISION_MASK (((1 << XS1_SS_DEVICE_ID0_REVISION_SIZE) - 1) << XS1_SS_DEVICE_ID0_REVISION_SHIFT)
/**
 * Extract the SS_DEVICE_ID0_REVISION bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID0_REVISION(x) (((x) & XS1_SS_DEVICE_ID0_REVISION_MASK) >> XS1_SS_DEVICE_ID0_REVISION_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID0_REVISION bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID0_REVISION_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID0_REVISION_MASK) | (((v) << XS1_SS_DEVICE_ID0_REVISION_SHIFT) & XS1_SS_DEVICE_ID0_REVISION_MASK))
///@}
/**
 * \name SS_DEVICE_ID0_BOOT_CTRL
 * \anchor SS_DEVICE_ID0_BOOT_CTRL
 * Sampled values of BootCtl pins on Power On Reset.
 */
///@{
#define XS1_SS_DEVICE_ID0_BOOT_CTRL_SHIFT 0x10
#define XS1_SS_DEVICE_ID0_BOOT_CTRL_SIZE 0x8
#define XS1_SS_DEVICE_ID0_BOOT_CTRL_MASK (((1 << XS1_SS_DEVICE_ID0_BOOT_CTRL_SIZE) - 1) << XS1_SS_DEVICE_ID0_BOOT_CTRL_SHIFT)
/**
 * Extract the SS_DEVICE_ID0_BOOT_CTRL bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID0_BOOT_CTRL(x) (((x) & XS1_SS_DEVICE_ID0_BOOT_CTRL_MASK) >> XS1_SS_DEVICE_ID0_BOOT_CTRL_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID0_BOOT_CTRL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID0_BOOT_CTRL_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID0_BOOT_CTRL_MASK) | (((v) << XS1_SS_DEVICE_ID0_BOOT_CTRL_SHIFT) & XS1_SS_DEVICE_ID0_BOOT_CTRL_MASK))
///@}
/**
 * \name SS_DEVICE_ID1_NUM_PLINKS_PER_PROC
 * \anchor SS_DEVICE_ID1_NUM_PLINKS_PER_PROC
 * Number of processors on the device.
 */
///@{
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SHIFT 0x0
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SIZE 0x8
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_MASK (((1 << XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SIZE) - 1) << XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SHIFT)
/**
 * Extract the SS_DEVICE_ID1_NUM_PLINKS_PER_PROC bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC(x) (((x) & XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_MASK) >> XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID1_NUM_PLINKS_PER_PROC bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_MASK) | (((v) << XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SHIFT) & XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_MASK))
///@}
/**
 * \name SS_DEVICE_ID1_NUM_PROCESSORS
 * \anchor SS_DEVICE_ID1_NUM_PROCESSORS
 * Number of processors on the SSwitch.
 */
///@{
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SHIFT 0x8
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SIZE 0x8
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS_MASK (((1 << XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SIZE) - 1) << XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SHIFT)
/**
 * Extract the SS_DEVICE_ID1_NUM_PROCESSORS bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS(x) (((x) & XS1_SS_DEVICE_ID1_NUM_PROCESSORS_MASK) >> XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID1_NUM_PROCESSORS bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID1_NUM_PROCESSORS_MASK) | (((v) << XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SHIFT) & XS1_SS_DEVICE_ID1_NUM_PROCESSORS_MASK))
///@}
/**
 * \name SS_DEVICE_ID1_NUM_SLINKS
 * \anchor SS_DEVICE_ID1_NUM_SLINKS
 * Number of SLinks on the SSwitch.
 */
///@{
#define XS1_SS_DEVICE_ID1_NUM_SLINKS_SHIFT 0x10
#define XS1_SS_DEVICE_ID1_NUM_SLINKS_SIZE 0x8
#define XS1_SS_DEVICE_ID1_NUM_SLINKS_MASK (((1 << XS1_SS_DEVICE_ID1_NUM_SLINKS_SIZE) - 1) << XS1_SS_DEVICE_ID1_NUM_SLINKS_SHIFT)
/**
 * Extract the SS_DEVICE_ID1_NUM_SLINKS bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID1_NUM_SLINKS(x) (((x) & XS1_SS_DEVICE_ID1_NUM_SLINKS_MASK) >> XS1_SS_DEVICE_ID1_NUM_SLINKS_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID1_NUM_SLINKS bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID1_NUM_SLINKS_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID1_NUM_SLINKS_MASK) | (((v) << XS1_SS_DEVICE_ID1_NUM_SLINKS_SHIFT) & XS1_SS_DEVICE_ID1_NUM_SLINKS_MASK))
///@}
/**
 * \name SS_NODE_CONFIG_HEADERS
 * \anchor SS_NODE_CONFIG_HEADERS
 * 0 = 2-byte headers, 1 = 1-byte headers (reset as 0).
 */
///@{
#define XS1_SS_NODE_CONFIG_HEADERS_SHIFT 0x0
#define XS1_SS_NODE_CONFIG_HEADERS_SIZE 0x1
#define XS1_SS_NODE_CONFIG_HEADERS_MASK (((1 << XS1_SS_NODE_CONFIG_HEADERS_SIZE) - 1) << XS1_SS_NODE_CONFIG_HEADERS_SHIFT)
/**
 * Extract the SS_NODE_CONFIG_HEADERS bitfield from a packed word x and return it.
 */
#define XS1_SS_NODE_CONFIG_HEADERS(x) (((x) & XS1_SS_NODE_CONFIG_HEADERS_MASK) >> XS1_SS_NODE_CONFIG_HEADERS_SHIFT)
/**
 * Pack the value (v) of the SS_NODE_CONFIG_HEADERS bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_NODE_CONFIG_HEADERS_SET(x, v) (((x) & ~XS1_SS_NODE_CONFIG_HEADERS_MASK) | (((v) << XS1_SS_NODE_CONFIG_HEADERS_SHIFT) & XS1_SS_NODE_CONFIG_HEADERS_MASK))
///@}
/**
 * \name SS_NODE_CONFIG_DISABLE_PLL_CTL_REG
 * \anchor SS_NODE_CONFIG_DISABLE_PLL_CTL_REG
 * 0 = PLL_CTL_REG has write access. 1 = PLL_CTL_REG can not be written to.
 */
///@{
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SHIFT 0x8
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SIZE 0x1
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_MASK (((1 << XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SIZE) - 1) << XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SHIFT)
/**
 * Extract the SS_NODE_CONFIG_DISABLE_PLL_CTL_REG bitfield from a packed word x and return it.
 */
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG(x) (((x) & XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_MASK) >> XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SHIFT)
/**
 * Pack the value (v) of the SS_NODE_CONFIG_DISABLE_PLL_CTL_REG bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SET(x, v) (((x) & ~XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_MASK) | (((v) << XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SHIFT) & XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_MASK))
///@}
/**
 * \name SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE
 * \anchor SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE
 * 0 = SSCTL registers have write access. 1 = SSCTL registers can not be written to.
 */
///@{
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SHIFT 0x1f
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SIZE 0x1
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_MASK (((1 << XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SIZE) - 1) << XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SHIFT)
/**
 * Extract the SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE bitfield from a packed word x and return it.
 */
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE(x) (((x) & XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_MASK) >> XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SHIFT)
/**
 * Pack the value (v) of the SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SET(x, v) (((x) & ~XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_MASK) | (((v) << XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SHIFT) & XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_MASK))
///@}
/**
 * \name SS_NODE_ID_ID
 * \anchor SS_NODE_ID_ID
 * The unique ID of this node.
 */
///@{
#define XS1_SS_NODE_ID_ID_SHIFT 0x0
#define XS1_SS_NODE_ID_ID_SIZE 0x10
#define XS1_SS_NODE_ID_ID_MASK (((1 << XS1_SS_NODE_ID_ID_SIZE) - 1) << XS1_SS_NODE_ID_ID_SHIFT)
/**
 * Extract the SS_NODE_ID_ID bitfield from a packed word x and return it.
 */
#define XS1_SS_NODE_ID_ID(x) (((x) & XS1_SS_NODE_ID_ID_MASK) >> XS1_SS_NODE_ID_ID_SHIFT)
/**
 * Pack the value (v) of the SS_NODE_ID_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_NODE_ID_ID_SET(x, v) (((x) & ~XS1_SS_NODE_ID_ID_MASK) | (((v) << XS1_SS_NODE_ID_ID_SHIFT) & XS1_SS_NODE_ID_ID_MASK))
///@}
/**
 * \name SS_PLL_CTL_INPUT_DIVISOR
 * \anchor SS_PLL_CTL_INPUT_DIVISOR
 * Oscilator input divider value range from 0 (8'h0) to 63 (8'h3F). R value.
 */
///@{
#define XS1_SS_PLL_CTL_INPUT_DIVISOR_SHIFT 0x0
#define XS1_SS_PLL_CTL_INPUT_DIVISOR_SIZE 0x7
#define XS1_SS_PLL_CTL_INPUT_DIVISOR_MASK (((1 << XS1_SS_PLL_CTL_INPUT_DIVISOR_SIZE) - 1) << XS1_SS_PLL_CTL_INPUT_DIVISOR_SHIFT)
/**
 * Extract the SS_PLL_CTL_INPUT_DIVISOR bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_INPUT_DIVISOR(x) (((x) & XS1_SS_PLL_CTL_INPUT_DIVISOR_MASK) >> XS1_SS_PLL_CTL_INPUT_DIVISOR_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_INPUT_DIVISOR bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_INPUT_DIVISOR_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_INPUT_DIVISOR_MASK) | (((v) << XS1_SS_PLL_CTL_INPUT_DIVISOR_SHIFT) & XS1_SS_PLL_CTL_INPUT_DIVISOR_MASK))
///@}
/**
 * \name SS_PLL_CTL_FEEDBACK_MUL
 * \anchor SS_PLL_CTL_FEEDBACK_MUL
 * Feedback multiplication ratio, range from 0 (8'h0) to 4095 (8'h3FF). F value.
 */
///@{
#define XS1_SS_PLL_CTL_FEEDBACK_MUL_SHIFT 0x8
#define XS1_SS_PLL_CTL_FEEDBACK_MUL_SIZE 0xd
#define XS1_SS_PLL_CTL_FEEDBACK_MUL_MASK (((1 << XS1_SS_PLL_CTL_FEEDBACK_MUL_SIZE) - 1) << XS1_SS_PLL_CTL_FEEDBACK_MUL_SHIFT)
/**
 * Extract the SS_PLL_CTL_FEEDBACK_MUL bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_FEEDBACK_MUL(x) (((x) & XS1_SS_PLL_CTL_FEEDBACK_MUL_MASK) >> XS1_SS_PLL_CTL_FEEDBACK_MUL_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_FEEDBACK_MUL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_FEEDBACK_MUL_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_FEEDBACK_MUL_MASK) | (((v) << XS1_SS_PLL_CTL_FEEDBACK_MUL_SHIFT) & XS1_SS_PLL_CTL_FEEDBACK_MUL_MASK))
///@}
/**
 * \name SS_PLL_CTL_POST_DIVISOR
 * \anchor SS_PLL_CTL_POST_DIVISOR
 * Output divider value range from 0 (8'h0) to 7 (8'h7). OD value.
 */
///@{
#define XS1_SS_PLL_CTL_POST_DIVISOR_SHIFT 0x17
#define XS1_SS_PLL_CTL_POST_DIVISOR_SIZE 0x3
#define XS1_SS_PLL_CTL_POST_DIVISOR_MASK (((1 << XS1_SS_PLL_CTL_POST_DIVISOR_SIZE) - 1) << XS1_SS_PLL_CTL_POST_DIVISOR_SHIFT)
/**
 * Extract the SS_PLL_CTL_POST_DIVISOR bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_POST_DIVISOR(x) (((x) & XS1_SS_PLL_CTL_POST_DIVISOR_MASK) >> XS1_SS_PLL_CTL_POST_DIVISOR_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_POST_DIVISOR bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_POST_DIVISOR_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_POST_DIVISOR_MASK) | (((v) << XS1_SS_PLL_CTL_POST_DIVISOR_SHIFT) & XS1_SS_PLL_CTL_POST_DIVISOR_MASK))
///@}
/**
 * \name SS_TEST_MODE_BOOT_RAM
 * \anchor SS_TEST_MODE_BOOT_RAM
 * If set to 1, set the boot mode to jump to RAM
 */
///@{
#define XS1_SS_TEST_MODE_BOOT_RAM_SHIFT 0x1b
#define XS1_SS_TEST_MODE_BOOT_RAM_SIZE 0x1
#define XS1_SS_TEST_MODE_BOOT_RAM_MASK (((1 << XS1_SS_TEST_MODE_BOOT_RAM_SIZE) - 1) << XS1_SS_TEST_MODE_BOOT_RAM_SHIFT)
/**
 * Extract the SS_TEST_MODE_BOOT_RAM bitfield from a packed word x and return it.
 */
#define XS1_SS_TEST_MODE_BOOT_RAM(x) (((x) & XS1_SS_TEST_MODE_BOOT_RAM_MASK) >> XS1_SS_TEST_MODE_BOOT_RAM_SHIFT)
/**
 * Pack the value (v) of the SS_TEST_MODE_BOOT_RAM bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_TEST_MODE_BOOT_RAM_SET(x, v) (((x) & ~XS1_SS_TEST_MODE_BOOT_RAM_MASK) | (((v) << XS1_SS_TEST_MODE_BOOT_RAM_SHIFT) & XS1_SS_TEST_MODE_BOOT_RAM_MASK))
///@}
/**
 * \name SS_TEST_MODE_BOOT_JTAG
 * \anchor SS_TEST_MODE_BOOT_JTAG
 * If set to 1, set the boot mode to boot from JTAG
 */
///@{
#define XS1_SS_TEST_MODE_BOOT_JTAG_SHIFT 0x1c
#define XS1_SS_TEST_MODE_BOOT_JTAG_SIZE 0x1
#define XS1_SS_TEST_MODE_BOOT_JTAG_MASK (((1 << XS1_SS_TEST_MODE_BOOT_JTAG_SIZE) - 1) << XS1_SS_TEST_MODE_BOOT_JTAG_SHIFT)
/**
 * Extract the SS_TEST_MODE_BOOT_JTAG bitfield from a packed word x and return it.
 */
#define XS1_SS_TEST_MODE_BOOT_JTAG(x) (((x) & XS1_SS_TEST_MODE_BOOT_JTAG_MASK) >> XS1_SS_TEST_MODE_BOOT_JTAG_SHIFT)
/**
 * Pack the value (v) of the SS_TEST_MODE_BOOT_JTAG bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_TEST_MODE_BOOT_JTAG_SET(x, v) (((x) & ~XS1_SS_TEST_MODE_BOOT_JTAG_MASK) | (((v) << XS1_SS_TEST_MODE_BOOT_JTAG_SHIFT) & XS1_SS_TEST_MODE_BOOT_JTAG_MASK))
///@}
/**
 * \name SS_TEST_MODE_PLL_BYPASS
 * \anchor SS_TEST_MODE_PLL_BYPASS
 * If set to 1, set the PLL to be bypassed
 */
///@{
#define XS1_SS_TEST_MODE_PLL_BYPASS_SHIFT 0x1d
#define XS1_SS_TEST_MODE_PLL_BYPASS_SIZE 0x1
#define XS1_SS_TEST_MODE_PLL_BYPASS_MASK (((1 << XS1_SS_TEST_MODE_PLL_BYPASS_SIZE) - 1) << XS1_SS_TEST_MODE_PLL_BYPASS_SHIFT)
/**
 * Extract the SS_TEST_MODE_PLL_BYPASS bitfield from a packed word x and return it.
 */
#define XS1_SS_TEST_MODE_PLL_BYPASS(x) (((x) & XS1_SS_TEST_MODE_PLL_BYPASS_MASK) >> XS1_SS_TEST_MODE_PLL_BYPASS_SHIFT)
/**
 * Pack the value (v) of the SS_TEST_MODE_PLL_BYPASS bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_TEST_MODE_PLL_BYPASS_SET(x, v) (((x) & ~XS1_SS_TEST_MODE_PLL_BYPASS_MASK) | (((v) << XS1_SS_TEST_MODE_PLL_BYPASS_SHIFT) & XS1_SS_TEST_MODE_PLL_BYPASS_MASK))
///@}
/**
 * \name SS_PLL_CTL_NLOCK
 * \anchor SS_PLL_CTL_NLOCK
 * If set to 1, the chip will not wait for the PLL to re-lock. Only use this
 *       if a gradual change is made to the PLL
 */
///@{
#define XS1_SS_PLL_CTL_NLOCK_SHIFT 0x1e
#define XS1_SS_PLL_CTL_NLOCK_SIZE 0x1
#define XS1_SS_PLL_CTL_NLOCK_MASK (((1 << XS1_SS_PLL_CTL_NLOCK_SIZE) - 1) << XS1_SS_PLL_CTL_NLOCK_SHIFT)
/**
 * Extract the SS_PLL_CTL_NLOCK bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_NLOCK(x) (((x) & XS1_SS_PLL_CTL_NLOCK_MASK) >> XS1_SS_PLL_CTL_NLOCK_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_NLOCK bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_NLOCK_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_NLOCK_MASK) | (((v) << XS1_SS_PLL_CTL_NLOCK_SHIFT) & XS1_SS_PLL_CTL_NLOCK_MASK))
///@}
/**
 * \name SS_PLL_CTL_NRESET
 * \anchor SS_PLL_CTL_NRESET
 * If set to 1, the chip will not be reset
 */
///@{
#define XS1_SS_PLL_CTL_NRESET_SHIFT 0x1f
#define XS1_SS_PLL_CTL_NRESET_SIZE 0x1
#define XS1_SS_PLL_CTL_NRESET_MASK (((1 << XS1_SS_PLL_CTL_NRESET_SIZE) - 1) << XS1_SS_PLL_CTL_NRESET_SHIFT)
/**
 * Extract the SS_PLL_CTL_NRESET bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_NRESET(x) (((x) & XS1_SS_PLL_CTL_NRESET_MASK) >> XS1_SS_PLL_CTL_NRESET_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_NRESET bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_NRESET_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_NRESET_MASK) | (((v) << XS1_SS_PLL_CTL_NRESET_SHIFT) & XS1_SS_PLL_CTL_NRESET_MASK))
///@}
/**
 * \name SS_CLK_DIVIDER_CLK_DIV
 * \anchor SS_CLK_DIVIDER_CLK_DIV
 * SSwitch clock generation
 */
///@{
#define XS1_SS_CLK_DIVIDER_CLK_DIV_SHIFT 0x0
#define XS1_SS_CLK_DIVIDER_CLK_DIV_SIZE 0x10
#define XS1_SS_CLK_DIVIDER_CLK_DIV_MASK (((1 << XS1_SS_CLK_DIVIDER_CLK_DIV_SIZE) - 1) << XS1_SS_CLK_DIVIDER_CLK_DIV_SHIFT)
/**
 * Extract the SS_CLK_DIVIDER_CLK_DIV bitfield from a packed word x and return it.
 */
#define XS1_SS_CLK_DIVIDER_CLK_DIV(x) (((x) & XS1_SS_CLK_DIVIDER_CLK_DIV_MASK) >> XS1_SS_CLK_DIVIDER_CLK_DIV_SHIFT)
/**
 * Pack the value (v) of the SS_CLK_DIVIDER_CLK_DIV bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_CLK_DIVIDER_CLK_DIV_SET(x, v) (((x) & ~XS1_SS_CLK_DIVIDER_CLK_DIV_MASK) | (((v) << XS1_SS_CLK_DIVIDER_CLK_DIV_SHIFT) & XS1_SS_CLK_DIVIDER_CLK_DIV_MASK))
///@}
/**
 * \name SS_SSWITCH_REF_CLK_DIV
 * \anchor SS_SSWITCH_REF_CLK_DIV
 * Software ref. clock divider
 */
///@{
#define XS1_SS_SSWITCH_REF_CLK_DIV_SHIFT 0x0
#define XS1_SS_SSWITCH_REF_CLK_DIV_SIZE 0x10
#define XS1_SS_SSWITCH_REF_CLK_DIV_MASK (((1 << XS1_SS_SSWITCH_REF_CLK_DIV_SIZE) - 1) << XS1_SS_SSWITCH_REF_CLK_DIV_SHIFT)
/**
 * Extract the SS_SSWITCH_REF_CLK_DIV bitfield from a packed word x and return it.
 */
#define XS1_SS_SSWITCH_REF_CLK_DIV(x) (((x) & XS1_SS_SSWITCH_REF_CLK_DIV_MASK) >> XS1_SS_SSWITCH_REF_CLK_DIV_SHIFT)
/**
 * Pack the value (v) of the SS_SSWITCH_REF_CLK_DIV bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_SSWITCH_REF_CLK_DIV_SET(x, v) (((x) & ~XS1_SS_SSWITCH_REF_CLK_DIV_MASK) | (((v) << XS1_SS_SSWITCH_REF_CLK_DIV_SHIFT) & XS1_SS_SSWITCH_REF_CLK_DIV_MASK))
///@}
/**
 * \name SS_JTAG_DEVICE_ID_CONST_VAL
 * \anchor SS_JTAG_DEVICE_ID_CONST_VAL
 */
///@{
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SHIFT 0x0
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SIZE 0x1
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL_MASK (((1 << XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SIZE) - 1) << XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SHIFT)
/**
 * Extract the SS_JTAG_DEVICE_ID_CONST_VAL bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL(x) (((x) & XS1_SS_JTAG_DEVICE_ID_CONST_VAL_MASK) >> XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_DEVICE_ID_CONST_VAL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SET(x, v) (((x) & ~XS1_SS_JTAG_DEVICE_ID_CONST_VAL_MASK) | (((v) << XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SHIFT) & XS1_SS_JTAG_DEVICE_ID_CONST_VAL_MASK))
///@}
/**
 * \name SS_JTAG_DEVICE_ID_MANU_ID
 * \anchor SS_JTAG_DEVICE_ID_MANU_ID
 */
///@{
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID_SHIFT 0x1
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID_SIZE 0xb
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID_MASK (((1 << XS1_SS_JTAG_DEVICE_ID_MANU_ID_SIZE) - 1) << XS1_SS_JTAG_DEVICE_ID_MANU_ID_SHIFT)
/**
 * Extract the SS_JTAG_DEVICE_ID_MANU_ID bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID(x) (((x) & XS1_SS_JTAG_DEVICE_ID_MANU_ID_MASK) >> XS1_SS_JTAG_DEVICE_ID_MANU_ID_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_DEVICE_ID_MANU_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID_SET(x, v) (((x) & ~XS1_SS_JTAG_DEVICE_ID_MANU_ID_MASK) | (((v) << XS1_SS_JTAG_DEVICE_ID_MANU_ID_SHIFT) & XS1_SS_JTAG_DEVICE_ID_MANU_ID_MASK))
///@}
/**
 * \name SS_JTAG_DEVICE_ID_PART_NUM
 * \anchor SS_JTAG_DEVICE_ID_PART_NUM
 */
///@{
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM_SHIFT 0xc
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM_SIZE 0x10
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM_MASK (((1 << XS1_SS_JTAG_DEVICE_ID_PART_NUM_SIZE) - 1) << XS1_SS_JTAG_DEVICE_ID_PART_NUM_SHIFT)
/**
 * Extract the SS_JTAG_DEVICE_ID_PART_NUM bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM(x) (((x) & XS1_SS_JTAG_DEVICE_ID_PART_NUM_MASK) >> XS1_SS_JTAG_DEVICE_ID_PART_NUM_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_DEVICE_ID_PART_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM_SET(x, v) (((x) & ~XS1_SS_JTAG_DEVICE_ID_PART_NUM_MASK) | (((v) << XS1_SS_JTAG_DEVICE_ID_PART_NUM_SHIFT) & XS1_SS_JTAG_DEVICE_ID_PART_NUM_MASK))
///@}
/**
 * \name SS_JTAG_DEVICE_ID_VERSION
 * \anchor SS_JTAG_DEVICE_ID_VERSION
 */
///@{
#define XS1_SS_JTAG_DEVICE_ID_VERSION_SHIFT 0x1c
#define XS1_SS_JTAG_DEVICE_ID_VERSION_SIZE 0x4
#define XS1_SS_JTAG_DEVICE_ID_VERSION_MASK (((1 << XS1_SS_JTAG_DEVICE_ID_VERSION_SIZE) - 1) << XS1_SS_JTAG_DEVICE_ID_VERSION_SHIFT)
/**
 * Extract the SS_JTAG_DEVICE_ID_VERSION bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_DEVICE_ID_VERSION(x) (((x) & XS1_SS_JTAG_DEVICE_ID_VERSION_MASK) >> XS1_SS_JTAG_DEVICE_ID_VERSION_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_DEVICE_ID_VERSION bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_DEVICE_ID_VERSION_SET(x, v) (((x) & ~XS1_SS_JTAG_DEVICE_ID_VERSION_MASK) | (((v) << XS1_SS_JTAG_DEVICE_ID_VERSION_SHIFT) & XS1_SS_JTAG_DEVICE_ID_VERSION_MASK))
///@}
/**
 * \name SS_JTAG_USERCODE_MASKID
 * \anchor SS_JTAG_USERCODE_MASKID
 * metal fixable ID code 
 */
///@{
#define XS1_SS_JTAG_USERCODE_MASKID_SHIFT 0x0
#define XS1_SS_JTAG_USERCODE_MASKID_SIZE 0x12
#define XS1_SS_JTAG_USERCODE_MASKID_MASK (((1 << XS1_SS_JTAG_USERCODE_MASKID_SIZE) - 1) << XS1_SS_JTAG_USERCODE_MASKID_SHIFT)
/**
 * Extract the SS_JTAG_USERCODE_MASKID bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_USERCODE_MASKID(x) (((x) & XS1_SS_JTAG_USERCODE_MASKID_MASK) >> XS1_SS_JTAG_USERCODE_MASKID_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_USERCODE_MASKID bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_USERCODE_MASKID_SET(x, v) (((x) & ~XS1_SS_JTAG_USERCODE_MASKID_MASK) | (((v) << XS1_SS_JTAG_USERCODE_MASKID_SHIFT) & XS1_SS_JTAG_USERCODE_MASKID_MASK))
///@}
/**
 * \name SS_JTAG_USERCODE_OTP
 * \anchor SS_JTAG_USERCODE_OTP
 * JTAG USERCODE value programmed into OTP SR
 */
///@{
#define XS1_SS_JTAG_USERCODE_OTP_SHIFT 0x12
#define XS1_SS_JTAG_USERCODE_OTP_SIZE 0xe
#define XS1_SS_JTAG_USERCODE_OTP_MASK (((1 << XS1_SS_JTAG_USERCODE_OTP_SIZE) - 1) << XS1_SS_JTAG_USERCODE_OTP_SHIFT)
/**
 * Extract the SS_JTAG_USERCODE_OTP bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_USERCODE_OTP(x) (((x) & XS1_SS_JTAG_USERCODE_OTP_MASK) >> XS1_SS_JTAG_USERCODE_OTP_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_USERCODE_OTP bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_USERCODE_OTP_SET(x, v) (((x) & ~XS1_SS_JTAG_USERCODE_OTP_MASK) | (((v) << XS1_SS_JTAG_USERCODE_OTP_SHIFT) & XS1_SS_JTAG_USERCODE_OTP_MASK))
///@}
/**
 * \name DIM0_DIR
 * \anchor DIM0_DIR
 * The direction for packets whose dimension is 0.  
 */
///@{
#define XS1_DIM0_DIR_SHIFT 0x0
#define XS1_DIM0_DIR_SIZE 0x4
#define XS1_DIM0_DIR_MASK (((1 << XS1_DIM0_DIR_SIZE) - 1) << XS1_DIM0_DIR_SHIFT)
/**
 * Extract the DIM0_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM0_DIR(x) (((x) & XS1_DIM0_DIR_MASK) >> XS1_DIM0_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM0_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM0_DIR_SET(x, v) (((x) & ~XS1_DIM0_DIR_MASK) | (((v) << XS1_DIM0_DIR_SHIFT) & XS1_DIM0_DIR_MASK))
///@}
/**
 * \name DIM1_DIR
 * \anchor DIM1_DIR
 * The direction for packets whose dimension is 1.  
 */
///@{
#define XS1_DIM1_DIR_SHIFT 0x4
#define XS1_DIM1_DIR_SIZE 0x4
#define XS1_DIM1_DIR_MASK (((1 << XS1_DIM1_DIR_SIZE) - 1) << XS1_DIM1_DIR_SHIFT)
/**
 * Extract the DIM1_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM1_DIR(x) (((x) & XS1_DIM1_DIR_MASK) >> XS1_DIM1_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM1_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM1_DIR_SET(x, v) (((x) & ~XS1_DIM1_DIR_MASK) | (((v) << XS1_DIM1_DIR_SHIFT) & XS1_DIM1_DIR_MASK))
///@}
/**
 * \name DIM2_DIR
 * \anchor DIM2_DIR
 * The direction for packets whose dimension is 2.  
 */
///@{
#define XS1_DIM2_DIR_SHIFT 0x8
#define XS1_DIM2_DIR_SIZE 0x4
#define XS1_DIM2_DIR_MASK (((1 << XS1_DIM2_DIR_SIZE) - 1) << XS1_DIM2_DIR_SHIFT)
/**
 * Extract the DIM2_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM2_DIR(x) (((x) & XS1_DIM2_DIR_MASK) >> XS1_DIM2_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM2_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM2_DIR_SET(x, v) (((x) & ~XS1_DIM2_DIR_MASK) | (((v) << XS1_DIM2_DIR_SHIFT) & XS1_DIM2_DIR_MASK))
///@}
/**
 * \name DIM3_DIR
 * \anchor DIM3_DIR
 * The direction for packets whose dimension is 3.  
 */
///@{
#define XS1_DIM3_DIR_SHIFT 0xc
#define XS1_DIM3_DIR_SIZE 0x4
#define XS1_DIM3_DIR_MASK (((1 << XS1_DIM3_DIR_SIZE) - 1) << XS1_DIM3_DIR_SHIFT)
/**
 * Extract the DIM3_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM3_DIR(x) (((x) & XS1_DIM3_DIR_MASK) >> XS1_DIM3_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM3_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM3_DIR_SET(x, v) (((x) & ~XS1_DIM3_DIR_MASK) | (((v) << XS1_DIM3_DIR_SHIFT) & XS1_DIM3_DIR_MASK))
///@}
/**
 * \name DIM4_DIR
 * \anchor DIM4_DIR
 * The direction for packets whose dimension is 4.  
 */
///@{
#define XS1_DIM4_DIR_SHIFT 0x10
#define XS1_DIM4_DIR_SIZE 0x4
#define XS1_DIM4_DIR_MASK (((1 << XS1_DIM4_DIR_SIZE) - 1) << XS1_DIM4_DIR_SHIFT)
/**
 * Extract the DIM4_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM4_DIR(x) (((x) & XS1_DIM4_DIR_MASK) >> XS1_DIM4_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM4_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM4_DIR_SET(x, v) (((x) & ~XS1_DIM4_DIR_MASK) | (((v) << XS1_DIM4_DIR_SHIFT) & XS1_DIM4_DIR_MASK))
///@}
/**
 * \name DIM5_DIR
 * \anchor DIM5_DIR
 * The direction for packets whose dimension is 5.  
 */
///@{
#define XS1_DIM5_DIR_SHIFT 0x14
#define XS1_DIM5_DIR_SIZE 0x4
#define XS1_DIM5_DIR_MASK (((1 << XS1_DIM5_DIR_SIZE) - 1) << XS1_DIM5_DIR_SHIFT)
/**
 * Extract the DIM5_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM5_DIR(x) (((x) & XS1_DIM5_DIR_MASK) >> XS1_DIM5_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM5_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM5_DIR_SET(x, v) (((x) & ~XS1_DIM5_DIR_MASK) | (((v) << XS1_DIM5_DIR_SHIFT) & XS1_DIM5_DIR_MASK))
///@}
/**
 * \name DIM6_DIR
 * \anchor DIM6_DIR
 * The direction for packets whose dimension is 6.  
 */
///@{
#define XS1_DIM6_DIR_SHIFT 0x18
#define XS1_DIM6_DIR_SIZE 0x4
#define XS1_DIM6_DIR_MASK (((1 << XS1_DIM6_DIR_SIZE) - 1) << XS1_DIM6_DIR_SHIFT)
/**
 * Extract the DIM6_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM6_DIR(x) (((x) & XS1_DIM6_DIR_MASK) >> XS1_DIM6_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM6_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM6_DIR_SET(x, v) (((x) & ~XS1_DIM6_DIR_MASK) | (((v) << XS1_DIM6_DIR_SHIFT) & XS1_DIM6_DIR_MASK))
///@}
/**
 * \name DIM7_DIR
 * \anchor DIM7_DIR
 * The direction for packets whose dimension is 7.  
 */
///@{
#define XS1_DIM7_DIR_SHIFT 0x1c
#define XS1_DIM7_DIR_SIZE 0x4
#define XS1_DIM7_DIR_MASK (((1 << XS1_DIM7_DIR_SIZE) - 1) << XS1_DIM7_DIR_SHIFT)
/**
 * Extract the DIM7_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM7_DIR(x) (((x) & XS1_DIM7_DIR_MASK) >> XS1_DIM7_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM7_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM7_DIR_SET(x, v) (((x) & ~XS1_DIM7_DIR_MASK) | (((v) << XS1_DIM7_DIR_SHIFT) & XS1_DIM7_DIR_MASK))
///@}
/**
 * \name DIM8_DIR
 * \anchor DIM8_DIR
 * The direction for packets whose dimension is 8.  
 */
///@{
#define XS1_DIM8_DIR_SHIFT 0x0
#define XS1_DIM8_DIR_SIZE 0x4
#define XS1_DIM8_DIR_MASK (((1 << XS1_DIM8_DIR_SIZE) - 1) << XS1_DIM8_DIR_SHIFT)
/**
 * Extract the DIM8_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM8_DIR(x) (((x) & XS1_DIM8_DIR_MASK) >> XS1_DIM8_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM8_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM8_DIR_SET(x, v) (((x) & ~XS1_DIM8_DIR_MASK) | (((v) << XS1_DIM8_DIR_SHIFT) & XS1_DIM8_DIR_MASK))
///@}
/**
 * \name DIM9_DIR
 * \anchor DIM9_DIR
 * The direction for packets whose dimension is 9.  
 */
///@{
#define XS1_DIM9_DIR_SHIFT 0x4
#define XS1_DIM9_DIR_SIZE 0x4
#define XS1_DIM9_DIR_MASK (((1 << XS1_DIM9_DIR_SIZE) - 1) << XS1_DIM9_DIR_SHIFT)
/**
 * Extract the DIM9_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM9_DIR(x) (((x) & XS1_DIM9_DIR_MASK) >> XS1_DIM9_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM9_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM9_DIR_SET(x, v) (((x) & ~XS1_DIM9_DIR_MASK) | (((v) << XS1_DIM9_DIR_SHIFT) & XS1_DIM9_DIR_MASK))
///@}
/**
 * \name DIMA_DIR
 * \anchor DIMA_DIR
 * The direction for packets whose dimension is A.  
 */
///@{
#define XS1_DIMA_DIR_SHIFT 0x8
#define XS1_DIMA_DIR_SIZE 0x4
#define XS1_DIMA_DIR_MASK (((1 << XS1_DIMA_DIR_SIZE) - 1) << XS1_DIMA_DIR_SHIFT)
/**
 * Extract the DIMA_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMA_DIR(x) (((x) & XS1_DIMA_DIR_MASK) >> XS1_DIMA_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMA_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMA_DIR_SET(x, v) (((x) & ~XS1_DIMA_DIR_MASK) | (((v) << XS1_DIMA_DIR_SHIFT) & XS1_DIMA_DIR_MASK))
///@}
/**
 * \name DIMB_DIR
 * \anchor DIMB_DIR
 * The direction for packets whose dimension is B.  
 */
///@{
#define XS1_DIMB_DIR_SHIFT 0xc
#define XS1_DIMB_DIR_SIZE 0x4
#define XS1_DIMB_DIR_MASK (((1 << XS1_DIMB_DIR_SIZE) - 1) << XS1_DIMB_DIR_SHIFT)
/**
 * Extract the DIMB_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMB_DIR(x) (((x) & XS1_DIMB_DIR_MASK) >> XS1_DIMB_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMB_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMB_DIR_SET(x, v) (((x) & ~XS1_DIMB_DIR_MASK) | (((v) << XS1_DIMB_DIR_SHIFT) & XS1_DIMB_DIR_MASK))
///@}
/**
 * \name DIMC_DIR
 * \anchor DIMC_DIR
 * The direction for packets whose dimension is C.  
 */
///@{
#define XS1_DIMC_DIR_SHIFT 0x10
#define XS1_DIMC_DIR_SIZE 0x4
#define XS1_DIMC_DIR_MASK (((1 << XS1_DIMC_DIR_SIZE) - 1) << XS1_DIMC_DIR_SHIFT)
/**
 * Extract the DIMC_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMC_DIR(x) (((x) & XS1_DIMC_DIR_MASK) >> XS1_DIMC_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMC_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMC_DIR_SET(x, v) (((x) & ~XS1_DIMC_DIR_MASK) | (((v) << XS1_DIMC_DIR_SHIFT) & XS1_DIMC_DIR_MASK))
///@}
/**
 * \name DIMD_DIR
 * \anchor DIMD_DIR
 * The direction for packets whose dimension is D.  
 */
///@{
#define XS1_DIMD_DIR_SHIFT 0x14
#define XS1_DIMD_DIR_SIZE 0x4
#define XS1_DIMD_DIR_MASK (((1 << XS1_DIMD_DIR_SIZE) - 1) << XS1_DIMD_DIR_SHIFT)
/**
 * Extract the DIMD_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMD_DIR(x) (((x) & XS1_DIMD_DIR_MASK) >> XS1_DIMD_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMD_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMD_DIR_SET(x, v) (((x) & ~XS1_DIMD_DIR_MASK) | (((v) << XS1_DIMD_DIR_SHIFT) & XS1_DIMD_DIR_MASK))
///@}
/**
 * \name DIME_DIR
 * \anchor DIME_DIR
 * The direction for packets whose dimension is E.  
 */
///@{
#define XS1_DIME_DIR_SHIFT 0x18
#define XS1_DIME_DIR_SIZE 0x4
#define XS1_DIME_DIR_MASK (((1 << XS1_DIME_DIR_SIZE) - 1) << XS1_DIME_DIR_SHIFT)
/**
 * Extract the DIME_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIME_DIR(x) (((x) & XS1_DIME_DIR_MASK) >> XS1_DIME_DIR_SHIFT)
/**
 * Pack the value (v) of the DIME_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIME_DIR_SET(x, v) (((x) & ~XS1_DIME_DIR_MASK) | (((v) << XS1_DIME_DIR_SHIFT) & XS1_DIME_DIR_MASK))
///@}
/**
 * \name DIMF_DIR
 * \anchor DIMF_DIR
 * The direction for packets whose dimension is F.  
 */
///@{
#define XS1_DIMF_DIR_SHIFT 0x1c
#define XS1_DIMF_DIR_SIZE 0x4
#define XS1_DIMF_DIR_MASK (((1 << XS1_DIMF_DIR_SIZE) - 1) << XS1_DIMF_DIR_SHIFT)
/**
 * Extract the DIMF_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMF_DIR(x) (((x) & XS1_DIMF_DIR_MASK) >> XS1_DIMF_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMF_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMF_DIR_SET(x, v) (((x) & ~XS1_DIMF_DIR_MASK) | (((v) << XS1_DIMF_DIR_SHIFT) & XS1_DIMF_DIR_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_ENABLE_INDEBUG
 * \anchor GLOBAL_DEBUG_ENABLE_INDEBUG
 * if DEBUGN Set 1 to enable inDebug bit to drive GlobalDebug.else  Reserved.
 */
///@{
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SHIFT 0x0
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SIZE 0x1
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_MASK (((1 << XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SIZE) - 1) << XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_ENABLE_INDEBUG bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG(x) (((x) & XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_MASK) >> XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_ENABLE_INDEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_MASK) | (((v) << XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SHIFT) & XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ
 * \anchor GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ
 * if DEBUGN Set 1 to enable GlobalDebug to generate debug request to XCore.else  Reserved.
 */
///@{
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SHIFT 0x1
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SIZE 0x1
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_MASK (((1 << XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SIZE) - 1) << XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ(x) (((x) & XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_MASK) >> XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_MASK) | (((v) << XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SHIFT) & XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG
 * \anchor GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG
 * If set, XCore0 is the source of last GlobalDebug event.
 */
///@{
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SHIFT 0x0
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SIZE 0x1
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_MASK (((1 << XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SIZE) - 1) << XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG(x) (((x) & XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_MASK) >> XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_MASK) | (((v) << XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SHIFT) & XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG
 * \anchor GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG
 * If set, XCore1 is the source of last GlobalDebug event.
 */
///@{
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SHIFT 0x1
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SIZE 0x1
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_MASK (((1 << XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SIZE) - 1) << XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG(x) (((x) & XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_MASK) >> XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_MASK) | (((v) << XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SHIFT) & XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG
 * \anchor GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG
 * if DEBUGN If set, external pin, is the source of last GlobalDebug event.else  Reserved.
 */
///@{
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SHIFT 0x4
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SIZE 0x1
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_MASK (((1 << XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SIZE) - 1) << XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG(x) (((x) & XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_MASK) >> XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_MASK) | (((v) << XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SHIFT) & XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_MASK))
///@}
/**
 * \name LINK_SRC_INUSE
 * \anchor LINK_SRC_INUSE
 * 1 when the source side of the link is in use.
 */
///@{
#define XS1_LINK_SRC_INUSE_SHIFT 0x0
#define XS1_LINK_SRC_INUSE_SIZE 0x1
#define XS1_LINK_SRC_INUSE_MASK (((1 << XS1_LINK_SRC_INUSE_SIZE) - 1) << XS1_LINK_SRC_INUSE_SHIFT)
/**
 * Extract the LINK_SRC_INUSE bitfield from a packed word x and return it.
 */
#define XS1_LINK_SRC_INUSE(x) (((x) & XS1_LINK_SRC_INUSE_MASK) >> XS1_LINK_SRC_INUSE_SHIFT)
/**
 * Pack the value (v) of the LINK_SRC_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_SRC_INUSE_SET(x, v) (((x) & ~XS1_LINK_SRC_INUSE_MASK) | (((v) << XS1_LINK_SRC_INUSE_SHIFT) & XS1_LINK_SRC_INUSE_MASK))
///@}
/**
 * \name LINK_DST_INUSE
 * \anchor LINK_DST_INUSE
 * 1 when the dest side of the link is in use.
 */
///@{
#define XS1_LINK_DST_INUSE_SHIFT 0x1
#define XS1_LINK_DST_INUSE_SIZE 0x1
#define XS1_LINK_DST_INUSE_MASK (((1 << XS1_LINK_DST_INUSE_SIZE) - 1) << XS1_LINK_DST_INUSE_SHIFT)
/**
 * Extract the LINK_DST_INUSE bitfield from a packed word x and return it.
 */
#define XS1_LINK_DST_INUSE(x) (((x) & XS1_LINK_DST_INUSE_MASK) >> XS1_LINK_DST_INUSE_SHIFT)
/**
 * Pack the value (v) of the LINK_DST_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_DST_INUSE_SET(x, v) (((x) & ~XS1_LINK_DST_INUSE_MASK) | (((v) << XS1_LINK_DST_INUSE_SHIFT) & XS1_LINK_DST_INUSE_MASK))
///@}
/**
 * \name LINK_JUNK
 * \anchor LINK_JUNK
 * 1 when the current packet is considered junk and will be thrown away.
 */
///@{
#define XS1_LINK_JUNK_SHIFT 0x2
#define XS1_LINK_JUNK_SIZE 0x1
#define XS1_LINK_JUNK_MASK (((1 << XS1_LINK_JUNK_SIZE) - 1) << XS1_LINK_JUNK_SHIFT)
/**
 * Extract the LINK_JUNK bitfield from a packed word x and return it.
 */
#define XS1_LINK_JUNK(x) (((x) & XS1_LINK_JUNK_MASK) >> XS1_LINK_JUNK_SHIFT)
/**
 * Pack the value (v) of the LINK_JUNK bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_JUNK_SET(x, v) (((x) & ~XS1_LINK_JUNK_MASK) | (((v) << XS1_LINK_JUNK_SHIFT) & XS1_LINK_JUNK_MASK))
///@}
/**
 * \name LINK_NETWORK
 * \anchor LINK_NETWORK
 * Determines the network to which this link belongs, reset as 0.
 */
///@{
#define XS1_LINK_NETWORK_SHIFT 0x4
#define XS1_LINK_NETWORK_SIZE 0x2
#define XS1_LINK_NETWORK_MASK (((1 << XS1_LINK_NETWORK_SIZE) - 1) << XS1_LINK_NETWORK_SHIFT)
/**
 * Extract the LINK_NETWORK bitfield from a packed word x and return it.
 */
#define XS1_LINK_NETWORK(x) (((x) & XS1_LINK_NETWORK_MASK) >> XS1_LINK_NETWORK_SHIFT)
/**
 * Pack the value (v) of the LINK_NETWORK bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_NETWORK_SET(x, v) (((x) & ~XS1_LINK_NETWORK_MASK) | (((v) << XS1_LINK_NETWORK_SHIFT) & XS1_LINK_NETWORK_MASK))
///@}
/**
 * \name LINK_DIRECTION
 * \anchor LINK_DIRECTION
 * The direction that this link operates in.
 */
///@{
#define XS1_LINK_DIRECTION_SHIFT 0x8
#define XS1_LINK_DIRECTION_SIZE 0x4
#define XS1_LINK_DIRECTION_MASK (((1 << XS1_LINK_DIRECTION_SIZE) - 1) << XS1_LINK_DIRECTION_SHIFT)
/**
 * Extract the LINK_DIRECTION bitfield from a packed word x and return it.
 */
#define XS1_LINK_DIRECTION(x) (((x) & XS1_LINK_DIRECTION_MASK) >> XS1_LINK_DIRECTION_SHIFT)
/**
 * Pack the value (v) of the LINK_DIRECTION bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_DIRECTION_SET(x, v) (((x) & ~XS1_LINK_DIRECTION_MASK) | (((v) << XS1_LINK_DIRECTION_SHIFT) & XS1_LINK_DIRECTION_MASK))
///@}
/**
 * \name SLINK_SRC_TARGET_ID
 * \anchor SLINK_SRC_TARGET_ID
 * When the link is in use, this is the destination link number to which all packets are sent.
 */
///@{
#define XS1_SLINK_SRC_TARGET_ID_SHIFT 0x10
#define XS1_SLINK_SRC_TARGET_ID_SIZE 0x8
#define XS1_SLINK_SRC_TARGET_ID_MASK (((1 << XS1_SLINK_SRC_TARGET_ID_SIZE) - 1) << XS1_SLINK_SRC_TARGET_ID_SHIFT)
/**
 * Extract the SLINK_SRC_TARGET_ID bitfield from a packed word x and return it.
 */
#define XS1_SLINK_SRC_TARGET_ID(x) (((x) & XS1_SLINK_SRC_TARGET_ID_MASK) >> XS1_SLINK_SRC_TARGET_ID_SHIFT)
/**
 * Pack the value (v) of the SLINK_SRC_TARGET_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_SLINK_SRC_TARGET_ID_SET(x, v) (((x) & ~XS1_SLINK_SRC_TARGET_ID_MASK) | (((v) << XS1_SLINK_SRC_TARGET_ID_SHIFT) & XS1_SLINK_SRC_TARGET_ID_MASK))
///@}
/**
 * \name SLINK_SRC_TARGET_TYPE
 * \anchor SLINK_SRC_TARGET_TYPE
 * Identify the SRC_TARGET type 0 - SLink, 1 - PLink, 2 - SSCTL, 3 - Undefine.
 */
///@{
#define XS1_SLINK_SRC_TARGET_TYPE_SHIFT 0x18
#define XS1_SLINK_SRC_TARGET_TYPE_SIZE 0x2
#define XS1_SLINK_SRC_TARGET_TYPE_MASK (((1 << XS1_SLINK_SRC_TARGET_TYPE_SIZE) - 1) << XS1_SLINK_SRC_TARGET_TYPE_SHIFT)
/**
 * Extract the SLINK_SRC_TARGET_TYPE bitfield from a packed word x and return it.
 */
#define XS1_SLINK_SRC_TARGET_TYPE(x) (((x) & XS1_SLINK_SRC_TARGET_TYPE_MASK) >> XS1_SLINK_SRC_TARGET_TYPE_SHIFT)
/**
 * Pack the value (v) of the SLINK_SRC_TARGET_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_SLINK_SRC_TARGET_TYPE_SET(x, v) (((x) & ~XS1_SLINK_SRC_TARGET_TYPE_MASK) | (((v) << XS1_SLINK_SRC_TARGET_TYPE_SHIFT) & XS1_SLINK_SRC_TARGET_TYPE_MASK))
///@}
/**
 * \name PLINK_SRC_TARGET_ID
 * \anchor PLINK_SRC_TARGET_ID
 * When the link is in use, this is the destination link number to which all packets are sent.
 */
///@{
#define XS1_PLINK_SRC_TARGET_ID_SHIFT 0x10
#define XS1_PLINK_SRC_TARGET_ID_SIZE 0x8
#define XS1_PLINK_SRC_TARGET_ID_MASK (((1 << XS1_PLINK_SRC_TARGET_ID_SIZE) - 1) << XS1_PLINK_SRC_TARGET_ID_SHIFT)
/**
 * Extract the PLINK_SRC_TARGET_ID bitfield from a packed word x and return it.
 */
#define XS1_PLINK_SRC_TARGET_ID(x) (((x) & XS1_PLINK_SRC_TARGET_ID_MASK) >> XS1_PLINK_SRC_TARGET_ID_SHIFT)
/**
 * Pack the value (v) of the PLINK_SRC_TARGET_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_PLINK_SRC_TARGET_ID_SET(x, v) (((x) & ~XS1_PLINK_SRC_TARGET_ID_MASK) | (((v) << XS1_PLINK_SRC_TARGET_ID_SHIFT) & XS1_PLINK_SRC_TARGET_ID_MASK))
///@}
/**
 * \name PLINK_SRC_TARGET_TYPE
 * \anchor PLINK_SRC_TARGET_TYPE
 * Identify the SRC_TARGET type 0 - SLink, 1 - PLink, 2 - SSCTL, 3 - Undefine.
 */
///@{
#define XS1_PLINK_SRC_TARGET_TYPE_SHIFT 0x18
#define XS1_PLINK_SRC_TARGET_TYPE_SIZE 0x2
#define XS1_PLINK_SRC_TARGET_TYPE_MASK (((1 << XS1_PLINK_SRC_TARGET_TYPE_SIZE) - 1) << XS1_PLINK_SRC_TARGET_TYPE_SHIFT)
/**
 * Extract the PLINK_SRC_TARGET_TYPE bitfield from a packed word x and return it.
 */
#define XS1_PLINK_SRC_TARGET_TYPE(x) (((x) & XS1_PLINK_SRC_TARGET_TYPE_MASK) >> XS1_PLINK_SRC_TARGET_TYPE_SHIFT)
/**
 * Pack the value (v) of the PLINK_SRC_TARGET_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_PLINK_SRC_TARGET_TYPE_SET(x, v) (((x) & ~XS1_PLINK_SRC_TARGET_TYPE_MASK) | (((v) << XS1_PLINK_SRC_TARGET_TYPE_SHIFT) & XS1_PLINK_SRC_TARGET_TYPE_MASK))
///@}
/**
 * \name XLINK_INTER_TOKEN_DELAY
 * \anchor XLINK_INTER_TOKEN_DELAY
 * Specify min. number of idle system clocks between two continuous transmit tokens -1.
 */
///@{
#define XS1_XLINK_INTER_TOKEN_DELAY_SHIFT 0x0
#define XS1_XLINK_INTER_TOKEN_DELAY_SIZE 0xb
#define XS1_XLINK_INTER_TOKEN_DELAY_MASK (((1 << XS1_XLINK_INTER_TOKEN_DELAY_SIZE) - 1) << XS1_XLINK_INTER_TOKEN_DELAY_SHIFT)
/**
 * Extract the XLINK_INTER_TOKEN_DELAY bitfield from a packed word x and return it.
 */
#define XS1_XLINK_INTER_TOKEN_DELAY(x) (((x) & XS1_XLINK_INTER_TOKEN_DELAY_MASK) >> XS1_XLINK_INTER_TOKEN_DELAY_SHIFT)
/**
 * Pack the value (v) of the XLINK_INTER_TOKEN_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_INTER_TOKEN_DELAY_SET(x, v) (((x) & ~XS1_XLINK_INTER_TOKEN_DELAY_MASK) | (((v) << XS1_XLINK_INTER_TOKEN_DELAY_SHIFT) & XS1_XLINK_INTER_TOKEN_DELAY_MASK))
///@}
/**
 * \name XLINK_INTRA_TOKEN_DELAY
 * \anchor XLINK_INTRA_TOKEN_DELAY
 * Specify min. number of idle system clocks between two continuous symbols witin a transmit token -1.
 */
///@{
#define XS1_XLINK_INTRA_TOKEN_DELAY_SHIFT 0xb
#define XS1_XLINK_INTRA_TOKEN_DELAY_SIZE 0xb
#define XS1_XLINK_INTRA_TOKEN_DELAY_MASK (((1 << XS1_XLINK_INTRA_TOKEN_DELAY_SIZE) - 1) << XS1_XLINK_INTRA_TOKEN_DELAY_SHIFT)
/**
 * Extract the XLINK_INTRA_TOKEN_DELAY bitfield from a packed word x and return it.
 */
#define XS1_XLINK_INTRA_TOKEN_DELAY(x) (((x) & XS1_XLINK_INTRA_TOKEN_DELAY_MASK) >> XS1_XLINK_INTRA_TOKEN_DELAY_SHIFT)
/**
 * Pack the value (v) of the XLINK_INTRA_TOKEN_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_INTRA_TOKEN_DELAY_SET(x, v) (((x) & ~XS1_XLINK_INTRA_TOKEN_DELAY_MASK) | (((v) << XS1_XLINK_INTRA_TOKEN_DELAY_SHIFT) & XS1_XLINK_INTRA_TOKEN_DELAY_MASK))
///@}
/**
 * \name XLINK_RX_RESET
 * \anchor XLINK_RX_RESET
 * Reset the receiver.  The next symbol that is detected will be the first symbol in a token.
 */
///@{
#define XS1_XLINK_RX_RESET_SHIFT 0x17
#define XS1_XLINK_RX_RESET_SIZE 0x1
#define XS1_XLINK_RX_RESET_MASK (((1 << XS1_XLINK_RX_RESET_SIZE) - 1) << XS1_XLINK_RX_RESET_SHIFT)
/**
 * Extract the XLINK_RX_RESET bitfield from a packed word x and return it.
 */
#define XS1_XLINK_RX_RESET(x) (((x) & XS1_XLINK_RX_RESET_MASK) >> XS1_XLINK_RX_RESET_SHIFT)
/**
 * Pack the value (v) of the XLINK_RX_RESET bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_RX_RESET_SET(x, v) (((x) & ~XS1_XLINK_RX_RESET_MASK) | (((v) << XS1_XLINK_RX_RESET_SHIFT) & XS1_XLINK_RX_RESET_MASK))
///@}
/**
 * \name XLINK_HELLO
 * \anchor XLINK_HELLO
 * Clear this end of the xlink's credit and issue a HELLO token.
 */
///@{
#define XS1_XLINK_HELLO_SHIFT 0x18
#define XS1_XLINK_HELLO_SIZE 0x1
#define XS1_XLINK_HELLO_MASK (((1 << XS1_XLINK_HELLO_SIZE) - 1) << XS1_XLINK_HELLO_SHIFT)
/**
 * Extract the XLINK_HELLO bitfield from a packed word x and return it.
 */
#define XS1_XLINK_HELLO(x) (((x) & XS1_XLINK_HELLO_MASK) >> XS1_XLINK_HELLO_SHIFT)
/**
 * Pack the value (v) of the XLINK_HELLO bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_HELLO_SET(x, v) (((x) & ~XS1_XLINK_HELLO_MASK) | (((v) << XS1_XLINK_HELLO_SHIFT) & XS1_XLINK_HELLO_MASK))
///@}
/**
 * \name TX_CREDIT
 * \anchor TX_CREDIT
 * This end of the xlink has credit to allow it to transmit.
 */
///@{
#define XS1_TX_CREDIT_SHIFT 0x19
#define XS1_TX_CREDIT_SIZE 0x1
#define XS1_TX_CREDIT_MASK (((1 << XS1_TX_CREDIT_SIZE) - 1) << XS1_TX_CREDIT_SHIFT)
/**
 * Extract the TX_CREDIT bitfield from a packed word x and return it.
 */
#define XS1_TX_CREDIT(x) (((x) & XS1_TX_CREDIT_MASK) >> XS1_TX_CREDIT_SHIFT)
/**
 * Pack the value (v) of the TX_CREDIT bitfield into a packed word x and return the packed field.
 */
#define XS1_TX_CREDIT_SET(x, v) (((x) & ~XS1_TX_CREDIT_MASK) | (((v) << XS1_TX_CREDIT_SHIFT) & XS1_TX_CREDIT_MASK))
///@}
/**
 * \name RX_CREDIT
 * \anchor RX_CREDIT
 * This end of the xlink has issued credit to allow the remote end to transmit
 */
///@{
#define XS1_RX_CREDIT_SHIFT 0x1a
#define XS1_RX_CREDIT_SIZE 0x1
#define XS1_RX_CREDIT_MASK (((1 << XS1_RX_CREDIT_SIZE) - 1) << XS1_RX_CREDIT_SHIFT)
/**
 * Extract the RX_CREDIT bitfield from a packed word x and return it.
 */
#define XS1_RX_CREDIT(x) (((x) & XS1_RX_CREDIT_MASK) >> XS1_RX_CREDIT_SHIFT)
/**
 * Pack the value (v) of the RX_CREDIT bitfield into a packed word x and return the packed field.
 */
#define XS1_RX_CREDIT_SET(x, v) (((x) & ~XS1_RX_CREDIT_MASK) | (((v) << XS1_RX_CREDIT_SHIFT) & XS1_RX_CREDIT_MASK))
///@}
/**
 * \name XLINK_RX_ERROR
 * \anchor XLINK_RX_ERROR
 * Rx buffer overflow or illegal token encoding received.
 */
///@{
#define XS1_XLINK_RX_ERROR_SHIFT 0x1b
#define XS1_XLINK_RX_ERROR_SIZE 0x1
#define XS1_XLINK_RX_ERROR_MASK (((1 << XS1_XLINK_RX_ERROR_SIZE) - 1) << XS1_XLINK_RX_ERROR_SHIFT)
/**
 * Extract the XLINK_RX_ERROR bitfield from a packed word x and return it.
 */
#define XS1_XLINK_RX_ERROR(x) (((x) & XS1_XLINK_RX_ERROR_MASK) >> XS1_XLINK_RX_ERROR_SHIFT)
/**
 * Pack the value (v) of the XLINK_RX_ERROR bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_RX_ERROR_SET(x, v) (((x) & ~XS1_XLINK_RX_ERROR_MASK) | (((v) << XS1_XLINK_RX_ERROR_SHIFT) & XS1_XLINK_RX_ERROR_MASK))
///@}
/**
 * \name XLINK_WIDE
 * \anchor XLINK_WIDE
 * 0: operate in 2 wire mode; 1: operate in 5 wire mode
 */
///@{
#define XS1_XLINK_WIDE_SHIFT 0x1e
#define XS1_XLINK_WIDE_SIZE 0x1
#define XS1_XLINK_WIDE_MASK (((1 << XS1_XLINK_WIDE_SIZE) - 1) << XS1_XLINK_WIDE_SHIFT)
/**
 * Extract the XLINK_WIDE bitfield from a packed word x and return it.
 */
#define XS1_XLINK_WIDE(x) (((x) & XS1_XLINK_WIDE_MASK) >> XS1_XLINK_WIDE_SHIFT)
/**
 * Pack the value (v) of the XLINK_WIDE bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_WIDE_SET(x, v) (((x) & ~XS1_XLINK_WIDE_MASK) | (((v) << XS1_XLINK_WIDE_SHIFT) & XS1_XLINK_WIDE_MASK))
///@}
/**
 * \name XLINK_ENABLE
 * \anchor XLINK_ENABLE
 * Write to this bit with '1' will enable the XLink, writing '0' will disable it. This bit controls the muxing of ports with overlapping xlinks.
 */
///@{
#define XS1_XLINK_ENABLE_SHIFT 0x1f
#define XS1_XLINK_ENABLE_SIZE 0x1
#define XS1_XLINK_ENABLE_MASK (((1 << XS1_XLINK_ENABLE_SIZE) - 1) << XS1_XLINK_ENABLE_SHIFT)
/**
 * Extract the XLINK_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XLINK_ENABLE(x) (((x) & XS1_XLINK_ENABLE_MASK) >> XS1_XLINK_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XLINK_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_ENABLE_SET(x, v) (((x) & ~XS1_XLINK_ENABLE_MASK) | (((v) << XS1_XLINK_ENABLE_SHIFT) & XS1_XLINK_ENABLE_MASK))
///@}
/**
 * \name XSTATIC_DEST_CHAN_END
 * \anchor XSTATIC_DEST_CHAN_END
 * The destination channel end on this node that packets received in static mode are forwarded to.
 */
///@{
#define XS1_XSTATIC_DEST_CHAN_END_SHIFT 0x0
#define XS1_XSTATIC_DEST_CHAN_END_SIZE 0x5
#define XS1_XSTATIC_DEST_CHAN_END_MASK (((1 << XS1_XSTATIC_DEST_CHAN_END_SIZE) - 1) << XS1_XSTATIC_DEST_CHAN_END_SHIFT)
/**
 * Extract the XSTATIC_DEST_CHAN_END bitfield from a packed word x and return it.
 */
#define XS1_XSTATIC_DEST_CHAN_END(x) (((x) & XS1_XSTATIC_DEST_CHAN_END_MASK) >> XS1_XSTATIC_DEST_CHAN_END_SHIFT)
/**
 * Pack the value (v) of the XSTATIC_DEST_CHAN_END bitfield into a packed word x and return the packed field.
 */
#define XS1_XSTATIC_DEST_CHAN_END_SET(x, v) (((x) & ~XS1_XSTATIC_DEST_CHAN_END_MASK) | (((v) << XS1_XSTATIC_DEST_CHAN_END_SHIFT) & XS1_XSTATIC_DEST_CHAN_END_MASK))
///@}
/**
 * \name XSTATIC_DEST_PROC
 * \anchor XSTATIC_DEST_PROC
 * The destination processor on this node that packets received in static mode are forwarded to.
 */
///@{
#define XS1_XSTATIC_DEST_PROC_SHIFT 0x8
#define XS1_XSTATIC_DEST_PROC_SIZE 0x1
#define XS1_XSTATIC_DEST_PROC_MASK (((1 << XS1_XSTATIC_DEST_PROC_SIZE) - 1) << XS1_XSTATIC_DEST_PROC_SHIFT)
/**
 * Extract the XSTATIC_DEST_PROC bitfield from a packed word x and return it.
 */
#define XS1_XSTATIC_DEST_PROC(x) (((x) & XS1_XSTATIC_DEST_PROC_MASK) >> XS1_XSTATIC_DEST_PROC_SHIFT)
/**
 * Pack the value (v) of the XSTATIC_DEST_PROC bitfield into a packed word x and return the packed field.
 */
#define XS1_XSTATIC_DEST_PROC_SET(x, v) (((x) & ~XS1_XSTATIC_DEST_PROC_MASK) | (((v) << XS1_XSTATIC_DEST_PROC_SHIFT) & XS1_XSTATIC_DEST_PROC_MASK))
///@}
/**
 * \name XSTATIC_ENABLE
 * \anchor XSTATIC_ENABLE
 * Enable static forwarding.
 */
///@{
#define XS1_XSTATIC_ENABLE_SHIFT 0x1f
#define XS1_XSTATIC_ENABLE_SIZE 0x1
#define XS1_XSTATIC_ENABLE_MASK (((1 << XS1_XSTATIC_ENABLE_SIZE) - 1) << XS1_XSTATIC_ENABLE_SHIFT)
/**
 * Extract the XSTATIC_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XSTATIC_ENABLE(x) (((x) & XS1_XSTATIC_ENABLE_MASK) >> XS1_XSTATIC_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XSTATIC_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XSTATIC_ENABLE_SET(x, v) (((x) & ~XS1_XSTATIC_ENABLE_MASK) | (((v) << XS1_XSTATIC_ENABLE_SHIFT) & XS1_XSTATIC_ENABLE_MASK))
///@}
/**
 * \name SSCTRL_PSCTRL_CORE_NUM
 * \anchor SSCTRL_PSCTRL_CORE_NUM
 * Core Number for the PSCTRL register address through the SSwitch
 */
///@{
#define XS1_SSCTRL_PSCTRL_CORE_NUM_SHIFT 0x8
#define XS1_SSCTRL_PSCTRL_CORE_NUM_SIZE 0x8
#define XS1_SSCTRL_PSCTRL_CORE_NUM_MASK (((1 << XS1_SSCTRL_PSCTRL_CORE_NUM_SIZE) - 1) << XS1_SSCTRL_PSCTRL_CORE_NUM_SHIFT)
/**
 * Extract the SSCTRL_PSCTRL_CORE_NUM bitfield from a packed word x and return it.
 */
#define XS1_SSCTRL_PSCTRL_CORE_NUM(x) (((x) & XS1_SSCTRL_PSCTRL_CORE_NUM_MASK) >> XS1_SSCTRL_PSCTRL_CORE_NUM_SHIFT)
/**
 * Pack the value (v) of the SSCTRL_PSCTRL_CORE_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_SSCTRL_PSCTRL_CORE_NUM_SET(x, v) (((x) & ~XS1_SSCTRL_PSCTRL_CORE_NUM_MASK) | (((v) << XS1_SSCTRL_PSCTRL_CORE_NUM_SHIFT) & XS1_SSCTRL_PSCTRL_CORE_NUM_MASK))
///@}
/// @}
/**
 * \defgroup xs2aMiscellaneousDefinitions xs2a Miscellaneous Definitions
 * @{
 */
#define XS1_DEVICE_ID0_VERSION_VALUE 0x0
#define XS1_DEVICE_ID0_REVISION_VALUE 0x4
#define XS1_NUM_NETWORKS 0x4
/**
 * \name RESOURCE_TYPES_DEFS
 * \anchor RESOURCE_TYPES_DEFS
 * Resource types
 */
///@{
/**
 * Ports
 */
#define XS1_RES_TYPE_PORT 0x0
/**
 * Timers
 */
#define XS1_RES_TYPE_TIMER 0x1
/**
 * Channel ends
 */
#define XS1_RES_TYPE_CHANEND 0x2
/**
 * Synchronisers
 */
#define XS1_RES_TYPE_SYNC 0x3
/**
 * Threads
 */
#define XS1_RES_TYPE_THREAD 0x4
/**
 * Lock
 */
#define XS1_RES_TYPE_LOCK 0x5
/**
 * Clock source
 */
#define XS1_RES_TYPE_CLKBLK 0x6
/**
 * Co-processor interface/multicycle unit
 */
#define XS1_RES_TYPE_COPROC 0x7
/**
 * Processor state
 */
#define XS1_RES_TYPE_PS 0xb
/**
 * Configuration messages
 */
#define XS1_RES_TYPE_CONFIG 0xc
/**
 * Instruction type
 */
#define XS1_RES_TYPE_INSTRUCTION 0xd
///@}
#define XS1_NUM_RES_TYPES 0x8
#define XS1_CLK_REF 0x1
#define XS1_CLK_XCORE 0x101
/**
 * \name ClockBlocks_DEFS
 * \anchor ClockBlocks_DEFS
 */
///@{
#define XS1_CLKBLK_REF 0x6
#define XS1_CLKBLK_1 0x106
#define XS1_CLKBLK_2 0x206
#define XS1_CLKBLK_3 0x306
#define XS1_CLKBLK_4 0x406
#define XS1_CLKBLK_5 0x506
#define XS1_CLKBLK_6 0x606
#define XS1_CLKBLK_7 0x706
///@}
/**
 * \name EXCEPTION_TYPES_DEFS
 * \anchor EXCEPTION_TYPES_DEFS
 * Exceptions change
 *         the normal flow of control; they may be caused by
 *         interrupts, errors arising during instruction execution and by
 *         system calls. On
 *         an exception, the processor will save the ``pc`` and ``sr`` in ``spc`` and ``ssr``,
 *         disable events and interrupts, and start executing
 *         an exception handler. The program counter that is saved normally points to the instruction that raised the exception. Two registers are also set. The
 *         exception-data (``ed``) and
 *         exception-type (``et``) will be set to reflect the cause of the
 *         exception. The exception handler can choose how to deal with the
 *         exception.
 * 
 *         In this chapter the different types of exception are listed,
 *         together with their representation, their meaning, and the
 *         instructions that may cause them.
 *       
 */
///@{
/**
 * Link errors
 */
#define XS1_ET_LINK_ERROR 0x1
/**
 * see [[XcoreArchTraps#Illegal_PC][Illegal PC]]
 */
#define XS1_ET_ILLEGAL_PC 0x2
/**
 * see [[XcoreArchTraps#Illegal_instructionsPC][Illegal instructions]]
 */
#define XS1_ET_ILLEGAL_INSTRUCTION 0x3
/**
 * thread / synchroniser / channel end / port / lock
 */
#define XS1_ET_ILLEGAL_RESOURCE 0x4
/**
 * see [[XcoreArchTraps#Illegal_load_store][Illegal load/store]]
 */
#define XS1_ET_LOAD_STORE 0x5
/**
 * see [[XcoreArchMachineState#Traps][Traps]]
 */
#define XS1_ET_ILLEGAL_PS 0x6
/**
 * see [[XcoreArchTraps#Arithmetic_exceptions][Arithmetic exceptions]]
 */
#define XS1_ET_ARITHMETIC 0x7
/**
 * see [[XcoreArchTraps#Exception_calls][Exception calls]]
 */
#define XS1_ET_ECALL 0x8
/**
 * see [[XcoreArchResources#Back_to_Back_Access][Resource dependencies]]
 */
#define XS1_ET_RESOURCE_DEP 0x9
/**
 * see [[XcoreArchTraps#Kernel_calls][Kernel calls]]
 */
#define XS1_ET_KCALL 0xf
/**
 * Indicates exception took place in the resource lane
 */
#define XS1_ET_IOLANE 0x10
///@}
#define XS1_ET_NONE 0x0
#define XS1_RES_ID_INVALID 0x0
#define XS1_KEP_ALIGNMENT 0x80
#define XS1_KCALL_ALIGNMENT 0x40
#define XS1_TRAP_KCALL_OFFSET 0x40
#define XS1_ARG0_REG r0
#define XS1_ARG1_REG r1
#define XS1_ARG2_REG r2
#define XS1_ARG3_REG r3
#define XS1_RET0_REG r0
#define XS1_RET1_REG r1
#define XS1_RET2_REG r2
#define XS1_RET3_REG r3
/**
 * \name T_REG_VALUES_DEFS
 * \anchor T_REG_VALUES_DEFS
 * Thread state register numbers for debug.
 */
///@{
#define XS1_DBG_T_REG_CP_NUM 0xc
#define XS1_DBG_T_REG_DP_NUM 0xd
#define XS1_DBG_T_REG_SP_NUM 0xe
#define XS1_DBG_T_REG_LR_NUM 0xf
#define XS1_DBG_T_REG_PC_NUM 0x10
#define XS1_DBG_T_REG_SR_NUM 0x11
#define XS1_DBG_T_REG_SPC_NUM 0x12
#define XS1_DBG_T_REG_SSR_NUM 0x13
#define XS1_DBG_T_REG_ET_NUM 0x14
#define XS1_DBG_T_REG_ED_NUM 0x15
#define XS1_DBG_T_REG_SED_NUM 0x16
#define XS1_DBG_T_REG_KEP_NUM 0x17
#define XS1_DBG_T_REG_KSP_NUM 0x18
#define XS1_DBG_T_REG_ID_NUM 0x19
///@}
/**
 * \name STACK_OFFSET_DEFS
 * \anchor STACK_OFFSET_DEFS
 * Stack offsets for ld,st instructions.
 */
///@{
#define XS1_STACK_OFFSET_SPC 0x1
#define XS1_STACK_OFFSET_SSR 0x2
#define XS1_STACK_OFFSET_SED 0x3
#define XS1_STACK_OFFSET_ET 0x4
///@}
#define XS1_NUM_LOCKS 0x4
#define XS1_NUM_SYNCS 0x7
#define XS1_NUM_TIMERS 0xa
#define XS1_NUM_THREADS 0x8
#define XS1_NUM_CHANENDS 0x20
#define XS1_NUM_CLKBLKS 0x6
#define XS1_NUM_MMAPS 0x10
#define XS1_DBG_BUFFER_WORDS 0x20
/**
 * \name DBG_CAUSE_DEFS
 * \anchor DBG_CAUSE_DEFS
 * Types of debug causes, with their value
 */
///@{
#define XS1_DBG_CAUSE_NONE 0x0
#define XS1_DBG_CAUSE_HOST 0x1
#define XS1_DBG_CAUSE_DCALL 0x2
#define XS1_DBG_CAUSE_IBREAK 0x3
#define XS1_DBG_CAUSE_DWATCH 0x4
#define XS1_DBG_CAUSE_RWATCH 0x5
///@}
/**
 * \name DEBUG_COMMANDS_DEFS
 * \anchor DEBUG_COMMANDS_DEFS
 * Debug commands.
 */
///@{
#define XS1_DBG_CMD_ACK 0x0
#define XS1_DBG_CMD_NACK 0x1
#define XS1_DBG_CMD_READ 0x2
#define XS1_DBG_CMD_WRITE 0x3
#define XS1_DBG_CMD_GETPS 0x4
#define XS1_DBG_CMD_SETPS 0x5
#define XS1_DBG_CMD_GETSTATE 0x6
#define XS1_DBG_CMD_SETSTATE 0x7
#define XS1_DBG_CMD_CALL 0x8
#define XS1_DBG_CMD_RFDBG 0x9
#define XS1_DBG_CMD_READ4PI 0xa
#define XS1_DBG_CMD_WRITE4PI 0xb
///@}
/**
 * \name DB_SCRATCH_USAGE_DEFS
 * \anchor DB_SCRATCH_USAGE_DEFS
 * Debug scratch register usage.
 */
///@{
#define XS1_PS_DBG_HANDLER XS1_PS_DBG_SCRATCH_0
#define XS1_PS_DBG_COMMAND XS1_PS_DBG_SCRATCH_1
#define XS1_PS_DBG_ARG0_REG XS1_PS_DBG_SCRATCH_2
#define XS1_PS_DBG_ARG1_REG XS1_PS_DBG_SCRATCH_3
#define XS1_PS_DBG_ARG2_REG XS1_PS_DBG_SCRATCH_4
#define XS1_PS_DBG_ARG3_REG XS1_PS_DBG_SCRATCH_5
#define XS1_PS_DBG_ARG4_REG XS1_PS_DBG_SCRATCH_6
#define XS1_PS_DBG_ARG5_REG XS1_PS_DBG_SCRATCH_7
#define XS1_NUM_DBG_SCRATCH_REGS 0x8
#define XS1_LOG2_NUM_DBG_SCRATCH_REGS 0x3
#define XS1_PSWITCH_DBG_HANDLER_NUM XS1_PSWITCH_DBG_SCRATCH_0_NUM
#define XS1_PSWITCH_DBG_COMMAND_NUM XS1_PSWITCH_DBG_SCRATCH_1_NUM
#define XS1_PSWITCH_DBG_ARG0_NUM XS1_PSWITCH_DBG_SCRATCH_2_NUM
#define XS1_PSWITCH_DBG_ARG1_NUM XS1_PSWITCH_DBG_SCRATCH_3_NUM
#define XS1_PSWITCH_DBG_ARG2_NUM XS1_PSWITCH_DBG_SCRATCH_4_NUM
#define XS1_PSWITCH_DBG_ARG3_NUM XS1_PSWITCH_DBG_SCRATCH_5_NUM
#define XS1_PSWITCH_DBG_ARG4_NUM XS1_PSWITCH_DBG_SCRATCH_6_NUM
#define XS1_PSWITCH_DBG_ARG5_NUM XS1_PSWITCH_DBG_SCRATCH_7_NUM
///@}
/**
 * \name DBG_BREAKPOINTS_DEFS
 * \anchor DBG_BREAKPOINTS_DEFS
 * Debug breakpoints and watchpoints
 */
///@{
#define XS1_NUM_DBG_IBREAK 0x4
#define XS1_NUM_DBG_RWATCH 0x4
#define XS1_NUM_DBG_DWATCH 0x4
///@}
#define XS1_RAM_BASE 0x40000
#define XS1_RAM_SIZE 0x40000
#define XS1_RAM_ADDR_WIDTH 0x10
/**
 * \name ROM_DEFS
 * \anchor ROM_DEFS
 * ROM definitions.
 */
///@{
#define XS1_ROM_BASE 0xfff00000
#define XS1_ROM_SIZE 0x2000
#define XS1_ROM_ADDR_WIDTH 0xb
#define XS1_ROM_BASE_WIDTH 0x10
#define XS1_DEBUG_VECTOR 0xfff00004
///@}
/**
 * \name USER_CONTROL_TOKENS_DEFS
 * \anchor USER_CONTROL_TOKENS_DEFS
 * User control tokens.
 */
///@{
/**
 * Start transaction.
 */
#define XS1_CT_START_TRANSACTION 0x0
/**
 * End - free up interconnect and tell target.
 */
#define XS1_CT_END 0x1
/**
 * End with control token bit set - free up interconnect and tell target.
 */
#define XS1_EOM_TOKEN 0x101
/**
 * Pause - free up interconnect but don't tell target.
 */
#define XS1_CT_PAUSE 0x2
/**
 * Pause with control token bit set - free up interconnect but don't tell target.
 */
#define XS1_PAUSE_TOKEN 0x102
/**
 * Acknowledge operation completed successfully.
 */
#define XS1_CT_ACK 0x3
/**
 * Acknowledge with control token bit set - operation completed successfully.
 */
#define XS1_ACK_TOKEN 0x103
/**
 * Acknowledge that there was an error.
 */
#define XS1_CT_NACK 0x4
/**
 * Acknowledge that there was an error with control token bit set.
 */
#define XS1_NACK_TOKEN 0x104
/**
 * Read data.
 */
#define XS1_CT_READN 0x10
/**
 * Read one byte.
 */
#define XS1_CT_READ1 0x11
/**
 * Read two bytes.
 */
#define XS1_CT_READ2 0x12
/**
 * Read four bytes.
 */
#define XS1_CT_READ4 0x13
/**
 * Read eight bytes.
 */
#define XS1_CT_READ8 0x14
/**
 * Write data.
 */
#define XS1_CT_WRITEN 0x15
/**
 * Write one byte.
 */
#define XS1_CT_WRITE1 0x16
/**
 * Write two bytes.
 */
#define XS1_CT_WRITE2 0x17
/**
 * Write four bytes.
 */
#define XS1_CT_WRITE4 0x18
/**
 * Write eight bytes.
 */
#define XS1_CT_WRITE8 0x19
/**
 * Call code at the specified address.
 */
#define XS1_CT_CALL 0x1a
///@}
/**
 * Write control register.
 */
#define XS1_CT_WRITEC 0xc0
/**
 * Read control register.
 */
#define XS1_CT_READC 0xc1
/**
 * PSwitch configuration message data value.
 */
#define XS1_CT_PSCTRL 0xc2
/**
 * SSwitch configuration message data value.
 */
#define XS1_CT_SSCTRL 0xc3
/**
 * \name RESOURCE_CREGS_DEFS
 * \anchor RESOURCE_CREGS_DEFS
 * Resource control registers.
 */
///@{
#define XS1_RES_PS_CTRL0 0x0
#define XS1_RES_PS_CTRL1 0x1
#define XS1_RES_PS_CTRL2 0x2
#define XS1_RES_PS_VECTOR 0x3
#define XS1_RES_PS_EV 0x4
#define XS1_RES_PS_DATA 0x5
#define XS1_RES_PS_CLKSRC 0x6
#define XS1_RES_PS_RDYSRC 0x7
#define XS1_RES_PS_TBV0 0x8
///@}
/**
 * \name SETCTRL_MODES_DEFS
 * \anchor SETCTRL_MODES_DEFS
 */
///@{
#define XS1_SETC_MODE_INUSE 0x0
#define XS1_SETC_MODE_COND 0x1
#define XS1_SETC_MODE_IE_MODE 0x2
#define XS1_SETC_MODE_DRIVE 0x3
#define XS1_SETC_MODE_LONG 0x7
///@}
/**
 * \name SETCTRL_LMODE_DEFS
 * \anchor SETCTRL_LMODE_DEFS
 */
///@{
#define XS1_SETC_LMODE_RUN 0x0
#define XS1_SETC_LMODE_MS 0x1
#define XS1_SETC_LMODE_BUF 0x2
#define XS1_SETC_LMODE_RDY 0x3
#define XS1_SETC_LMODE_SDELAY 0x4
#define XS1_SETC_LMODE_PORT 0x5
#define XS1_SETC_LMODE_INV 0x6
#define XS1_SETC_LMODE_PIN_DELAY 0x7
#define XS1_SETC_LMODE_FALL_DELAY 0x8
#define XS1_SETC_LMODE_RISE_DELAY 0x9
///@}
/**
 * \name CTRL_MODE_DEFS
 * \anchor CTRL_MODE_DEFS
 */
///@{
#define XS1_SETC_INUSE_OFF 0x0
#define XS1_SETC_INUSE_ON 0x8
#define XS1_SETC_COND_NONE 0x1
#define XS1_SETC_COND_FULL 0x1
#define XS1_SETC_COND_AFTER 0x9
#define XS1_SETC_COND_EQ 0x11
#define XS1_SETC_COND_NEQ 0x19
#define XS1_SETC_COND_GREATER 0x21
#define XS1_SETC_COND_LESS 0x29
#define XS1_SETC_IE_MODE_EVENT 0x2
#define XS1_SETC_IE_MODE_INTERRUPT 0xa
#define XS1_SETC_DRIVE_DRIVE 0x3
#define XS1_SETC_DRIVE_PULL_DOWN 0xb
#define XS1_SETC_DRIVE_PULL_UP 0x13
#define XS1_SETC_RUN_STOPR 0x7
#define XS1_SETC_RUN_STARTR 0xf
#define XS1_SETC_RUN_CLRBUF 0x17
#define XS1_SETC_MS_MASTER 0x1007
#define XS1_SETC_MS_SLAVE 0x100f
#define XS1_SETC_BUF_NOBUFFERS 0x2007
#define XS1_SETC_BUF_BUFFERS 0x200f
#define XS1_SETC_RDY_NOREADY 0x3007
#define XS1_SETC_RDY_STROBED 0x300f
#define XS1_SETC_RDY_HANDSHAKE 0x3017
#define XS1_SETC_SDELAY_NOSDELAY 0x4007
#define XS1_SETC_SDELAY_SDELAY 0x400f
#define XS1_SETC_PORT_DATAPORT 0x5007
#define XS1_SETC_PORT_CLOCKPORT 0x500f
#define XS1_SETC_PORT_READYPORT 0x5017
#define XS1_SETC_INV_NOINVERT 0x6007
#define XS1_SETC_INV_INVERT 0x600f
///@}
/// @}
/**
 * \defgroup xs2aPortDefinitions xs2a Port Definitions
 * @{
 */
/* gpio ports*/
#define XS1_NUM_1BIT_GPIO_PORTS 0x10
#define XS1_NUM_4BIT_GPIO_PORTS 0x6
#define XS1_NUM_8BIT_GPIO_PORTS 0x4
#define XS1_NUM_16BIT_GPIO_PORTS 0x2
#define XS1_NUM_32BIT_GPIO_PORTS 0x1
/* periph ports*/
#define XS1_NUM_16BIT_PERIPH_PORTS 0x2
#define XS1_NUM_32BIT_PERIPH_PORTS 0x1
/* Totals*/
#define XS1_NUM_1BIT_PORTS 0x10
#define XS1_NUM_4BIT_PORTS 0x6
#define XS1_NUM_8BIT_PORTS 0x4
#define XS1_NUM_16BIT_PORTS 0x4
#define XS1_NUM_32BIT_PORTS 0x2
/// @}
#endif /* _xs2a_defines_H_ */
