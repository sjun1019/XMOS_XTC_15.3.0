/*
 *
 * Copyright XMOS Limited - (c) 2005-2022
 *
 * AUTOGENERATED - DO NOT EDIT
 * tools_xmosutils/DefinesGeneration/HashDefinesGenerator.cpp
 *
 */
/**
 * @file 
 */

#ifndef _xs3a_defines_H_
#define _xs3a_defines_H_

/**
 * \defgroup xs3aPSRegisters xs3a PS Registers
 * @{
 */
/**
 * PS_RAM_BASE processor state register ID.
 * Use getps() and setps() to access.
 * 
 * This register contains the base address of the RAM. It is initialized to 0x00080000.
 * 
 * Sub-Fields:
 * 
 * \ref WORD_ADDRESS_BITS Most significant 16 bits of all addresses.
 * 
 */
#define XS1_PS_RAM_BASE 0xb
/**
 * PS_VECTOR_BASE processor state register ID.
 * Use getps() and setps() to access.
 * 
 * Base address of event vectors in each resource. On an interrupt or event, the 16 most significant bits of the destination address are provided by this register; the least significant 16 bits come from the event vector.
 * 
 * Sub-Fields:
 * 
 * \ref VECTOR_BASE The event and interrupt vectors.
 * 
 */
#define XS1_PS_VECTOR_BASE 0x10b
/**
 * PS_XCORE_CTRL0 processor state register ID.
 * Use getps() and setps() to access.
 * 
 * Register to control features in the xCORE tile
 * 
 * Sub-Fields:
 * 
 * \ref XCORE_CTRL0_EXTMEM_ENABLE Enable External memory interface
 * 
 * \ref XCORE_CTRL0_USB_ENABLE Enable the USB hardware support module
 * 
 * \ref XCORE_CTRL0_CLK_DIVIDER_EN Enable the clock divider.  This divides the output of the PLL to facilitate one of the low power modes.
 * 
 * \ref XCORE_CTRL0_CLK_DIVIDER_DYN Select the dynamic mode (1) for the clock divider when the clock divider is enabled.  In dynamic mode the clock divider is only activated when all active threads are paused.  In static mode the clock divider is always enabled.
 * 
 * \ref XCORE_CTRL0_MIPI_ENABLE Enable MIPI interface periph ports
 * 
 * \ref XCORE_CTRL0_MEMSLEEP_ENABLE Enable memory auto-sleep feature
 * 
 * \ref XCORE_CTRL0_RAMSHUTDOWN Disable RAMs to save power (contents will be lost)
 * 
 * \ref XCORE_CTRL0_EXTMEM_DEVICE_SIZE Specify size of a connected LPDDR device (options are: 128,256,512Mbits, 1Gbit),
 * 
 */
#define XS1_PS_XCORE_CTRL0 0x20b
/**
 * PS_BOOT_CONFIG processor state register ID.
 * Use getps() to access.
 * 
 * This read-only register describes the boot status of the xCORE tile.
 * 
 * Sub-Fields:
 * 
 * \ref BOOT_CONFIG_PLL_MODE_PINS The boot PLL mode pin value.
 * 
 * \ref BOOT_CONFIG_BOOT_FROM_JTAG Boot ROM boots from JTAG 
 * 
 * \ref BOOT_CONFIG_BOOT_FROM_RAM Boot ROM boots from RAM 
 * 
 * \ref BOOT_CONFIG_DISABLE_OTP_POLL Cause the ROM to not poll the OTP for correct read levels
 * 
 * \ref BOOT_CONFIG_SECURE_BOOT Overwrite BOOT_MODE.
 * 
 * \ref BOOT_CONFIG_PROCESSOR Processor number.
 * 
 */
#define XS1_PS_BOOT_CONFIG 0x30b
/**
 * PS_BOOT_STATUS processor state register ID.
 * Use getps() and setps() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref BOOT_STATUS_LEDS Boot status LED value.
 * 
 * \ref BOOT_STATUS_BITS Other boot status LED bits.
 * 
 */
#define XS1_PS_BOOT_STATUS 0x40b
/**
 * PS_SECURITY_CONFIG processor state register ID.
 * Use getps() and setps() to access.
 * 
 * Copy of the security register as read from OTP.
 * 
 * Sub-Fields:
 * 
 * \ref SECUR_CFG_DISABLE_XCORE_JTAG Disable access to XCore's JTAG debug TAP 
 * 
 * \ref SECUR_CFG_DISABLE_PLL_JTAG Disable JTAG access to the PLL/BOOT configuration registers 
 * 
 * \ref SECUR_CFG_SECURE_BOOT Override boot mode and read boot image from OTP 
 * 
 * \ref SECUR_CFG_OTP_COMBINED Combine OTP into a single address-space for reading.
 * 
 * \ref SECUR_CFG_OTP_PROGRAM_DISABLE Prevent access to OTP SBPI interface to prevent programming and other functions. 
 * 
 * \ref SECUR_CFG_OTP_READ_LOCK Disable read access to OTP. 
 * 
 * \ref SECUR_CFG_DISABLE_GLOBAL_DEBUG Disable access to XCore's global debug 
 * 
 * \ref SECUR_CFG_DISABLE_ACCESS Disables write permission on this register 
 * 
 */
#define XS1_PS_SECURITY_CONFIG 0x50b
/**
 * PS_RING_OSC_CTRL processor state register ID.
 * Use getps() and setps() to access.
 * 
 * There are four free-running oscillators that clock
 *       four counters. The oscillators can be started and stopped using this
 *       register. The counters should only be read when the ring oscillator
 *       has been stopped for at least 10 core clock cycles (this can be
 *       achieved by inserting two nop instructions between the SETPS and GETPS).
 *       The counter values can be read using two subsequent
 *       registers. The ring oscillators are asynchronous to the xCORE tile clock
 *       and can be used as a source of random bits.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_PERPH_ENABLE Set to 1 to enable the core peripheral ring oscillator.
 * 
 * \ref RING_OSC_CORE_ENABLE Core ring oscillator enable.
 * 
 */
#define XS1_PS_RING_OSC_CTRL 0x60b
/**
 * PS_RING_OSC_DATA0 processor state register ID.
 * Use getps() to access.
 * 
 * This register contains the current count of the xCORE Tile Cell ring oscillator. This value is not reset on a system reset.
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_DATA Ring oscillator Counter data.
 * 
 */
#define XS1_PS_RING_OSC_DATA0 0x70b
/**
 * PS_RING_OSC_DATA1 processor state register ID.
 * Use getps() to access.
 * 
 * This register contains the current count of the xCORE Tile Wire ring oscillator. This value is not reset on a system reset.
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_DATA Ring oscillator Counter data.
 * 
 */
#define XS1_PS_RING_OSC_DATA1 0x80b
/**
 * PS_RING_OSC_DATA2 processor state register ID.
 * Use getps() to access.
 * 
 * This register contains the current count of the Peripheral Cell ring oscillator. This value is not reset on a system reset.
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_DATA Ring oscillator Counter data.
 * 
 */
#define XS1_PS_RING_OSC_DATA2 0x90b
/**
 * PS_RING_OSC_DATA3 processor state register ID.
 * Use getps() to access.
 * 
 * This register contains the current count of the Peripheral Wire ring oscillator. This value is not reset on a system reset.
 * 
 * Sub-Fields:
 * 
 * \ref RING_OSC_DATA Ring oscillator Counter data.
 * 
 */
#define XS1_PS_RING_OSC_DATA3 0xa0b
/**
 * PS_UNAVAILABLE_RESOURCE processor state register ID.
 * Use getps() and setps() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref RAM_MASK Blocks of 64k rams unavailable
 * 
 * \ref CORE1_DISABLE Core 1's clock is gated off 
 * 
 * \ref THREAD_MASK Threads unavailable
 * 
 */
#define XS1_PS_UNAVAILABLE_RESOURCE 0xb0b
/**
 * PS_RAM_SIZE processor state register ID.
 * Use getps() to access.
 * 
 * The size of the RAM in bytes
 * 
 * Sub-Fields:
 * 
 * \ref WORD_ADDRESS_BITS Most significant 16 bits of all addresses.
 * 
 */
#define XS1_PS_RAM_SIZE 0xc0b
/**
 * PS_ROM_RMA processor state register ID.
 * Use getps() and setps() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref RTSEL ROM debug timing adjust.
 * 
 * \ref PTSEL ROM debug timing adjust.
 * 
 * \ref TRB ROM debug timing adjust.
 * 
 */
#define XS1_PS_ROM_RMA 0xf0b
/**
 * PS_DBG_SSR processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * This register contains the value of the SSR register when the debugger was called.
 * 
 * Sub-Fields:
 * 
 * \ref SR_EEBLE 1 when events are enabled for the thread.
 * 
 * \ref SR_IEBLE 1 when interrupts are enabled for the thread.
 * 
 * \ref SR_INENB 1 when in an event enabling sequence.
 * 
 * \ref SR_ININT 1 when in an interrupt handler.
 * 
 * \ref SR_INK 1 when in kernel mode.
 * 
 * \ref SR_WAITING 1 when the thread is paused waiting for events, a lock or another resource.
 * 
 * \ref SR_FAST 1 when the thread is in fast mode and will continually issue.
 * 
 * \ref SR_DI 1 when in dual issue mode.
 * 
 * \ref SR_KEDI 1 if, on kernel entry, the thread will switch to dual issue.
 * 
 * \ref SR_QUEUE 1 if in high priority mode
 * 
 */
#define XS1_PS_DBG_SSR 0x100b
/**
 * PS_DBG_SPC processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * This register contains the value of the SPC register when the debugger was called.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PS_DBG_SPC 0x110b
/**
 * PS_DBG_SSP processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * This register contains the value of the SSP register when the debugger was called.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PS_DBG_SSP 0x120b
/**
 * PS_DBG_T_NUM processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * The resource ID of the logical core whose state is to be read.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_T_NUM_NUM Thread number to be read
 * 
 */
#define XS1_PS_DBG_T_NUM 0x130b
/**
 * PS_DBG_T_REG processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * Register number to be read by DGETREG
 * 
 * Sub-Fields:
 * 
 * \ref DBG_T_REG_REG Register number to be read
 * 
 */
#define XS1_PS_DBG_T_REG 0x140b
/**
 * PS_DBG_TYPE processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * Register that specifies what activated the debug interrupt.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_TYPE_CAUSE Indicates the cause of the debug interrupt
 * 
 * 1: Host initiated a debug interrupt through JTAG
 * 
 * 2: Program executed a DCALL instruction
 * 
 * 3: Instruction breakpoint
 * 
 * 4: Data watch point
 * 
 * 5: Resource watch point
 * 
 * 
 * \ref DBG_TYPE_T_NUM Number of thread which caused the debug interrupt (always 0 in the case of =HOST=).
 * 
 * \ref DBG_TYPE_HW_NUM Number of the hardware breakpoint/watchpoint which caused the interrupt (always 0 for =HOST= and =DCALL=). If multiple breakpoints/watchpoints trigger at once, the lowest number is taken.
 * 
 */
#define XS1_PS_DBG_TYPE 0x150b
/**
 * PS_DBG_DATA processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * On a data watchpoint, this register contains 
 *       the effective address of the memory operation that triggered 
 *       the debugger. On a resource watchpoint, it countains the resource
 *       identifier.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PS_DBG_DATA 0x160b
/**
 * PS_DBG_RUN_CTRL processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 * 
 * This register enables the debugger to temporarily disable logical cores. When returning from the debug interrupts, the cores set in this register will not execute. This enables single stepping to be implemented.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_RUN_CTRL_STOP 1-hot vector defining which threads are stopped when not in debug mode. Every bit which is set prevents the respective thread from running.
 * 
 */
#define XS1_PS_DBG_RUN_CTRL 0x180b
/**
 * \name PS_DBG_SCRATCH
 * \anchor PS_DBG_SCRATCH
 * A set of registers used by the debug ROM to communicate with an external debugger, for example over JTAG. This is the same set of registers as the Debug Scratch registers in the xCORE tile configuration.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_SCRATCH 0x8
/**
 * \ref PS_DBG_SCRATCH 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_0 0x200b
/**
 * \ref PS_DBG_SCRATCH 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_1 0x210b
/**
 * \ref PS_DBG_SCRATCH 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_2 0x220b
/**
 * \ref PS_DBG_SCRATCH 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_3 0x230b
/**
 * \ref PS_DBG_SCRATCH 4 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_4 0x240b
/**
 * \ref PS_DBG_SCRATCH 5 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_5 0x250b
/**
 * \ref PS_DBG_SCRATCH 6 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_6 0x260b
/**
 * \ref PS_DBG_SCRATCH 7 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_SCRATCH_7 0x270b
///@}
/**
 * \name PS_DBG_IBREAK_ADDR
 * \anchor PS_DBG_IBREAK_ADDR
 * This register contains the address of the instruction breakpoint. If the PC matches this address, then a debug interrupt will be taken. There are four instruction breakpoints that are controlled individually.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_IBREAK_ADDR 0x4
/**
 * \ref PS_DBG_IBREAK_ADDR 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_ADDR_0 0x300b
/**
 * \ref PS_DBG_IBREAK_ADDR 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_ADDR_1 0x310b
/**
 * \ref PS_DBG_IBREAK_ADDR 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_ADDR_2 0x320b
/**
 * \ref PS_DBG_IBREAK_ADDR 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_ADDR_3 0x330b
///@}
/**
 * \name PS_DBG_IBREAK_CTRL
 * \anchor PS_DBG_IBREAK_CTRL
 * This register controls which logical cores may take an instruction breakpoint, and under which condition.
 * 
 * Sub-Fields:
 * 
 * \ref BRK_ENABLE When 1 the breakpoint is enabled.
 * 
 * \ref IBRK_CONDITION When 0 break when PC == IBREAK_ADDR. When 1 = break when PC != IBREAK_ADDR.
 * 
 * \ref BRK_THREADS A bit for each thread in the machine allowing the breakpoint to be enabled individually for each thread.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_IBREAK_CTRL 0x4
/**
 * \ref PS_DBG_IBREAK_CTRL 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_CTRL_0 0x400b
/**
 * \ref PS_DBG_IBREAK_CTRL 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_CTRL_1 0x410b
/**
 * \ref PS_DBG_IBREAK_CTRL 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_CTRL_2 0x420b
/**
 * \ref PS_DBG_IBREAK_CTRL 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_IBREAK_CTRL_3 0x430b
///@}
/**
 * \name PS_DBG_DWATCH_ADDR1
 * \anchor PS_DBG_DWATCH_ADDR1
 * This set of registers contains the first address for
 *       the four data watchpoints. Condition ``A`` of a watchpoint is met if
 *       the effective address of an instruction is greater than or equal to the value in
 *       this register.
 *       
 *       The CTRL register for the watchpoint will dictate whether the
 *       watchpoint triggers on stores only or on loads and stores, and
 *       whether it requires either condition ``A`` or ``B``, or both ``A`` and ``B``.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_DWATCH_ADDR1 0x4
/**
 * \ref PS_DBG_DWATCH_ADDR1 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR1_0 0x500b
/**
 * \ref PS_DBG_DWATCH_ADDR1 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR1_1 0x510b
/**
 * \ref PS_DBG_DWATCH_ADDR1 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR1_2 0x520b
/**
 * \ref PS_DBG_DWATCH_ADDR1 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR1_3 0x530b
///@}
/**
 * \name PS_DBG_DWATCH_ADDR2
 * \anchor PS_DBG_DWATCH_ADDR2
 * This set of registers contains the second address for
 *       the four data watchpoints. Condition ``B`` of a watchpoint is met if
 *       the effective address of an instruction is less than or equal to the value in
 *       this register.
 *       
 *       The CTRL register for the watchpoint will dictate whether the
 *       watchpoint triggers on stores only or on loads and stores, and
 *       whether it requires either condition ``A`` or ``B``, or both ``A`` and ``B``.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_DWATCH_ADDR2 0x4
/**
 * \ref PS_DBG_DWATCH_ADDR2 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR2_0 0x600b
/**
 * \ref PS_DBG_DWATCH_ADDR2 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR2_1 0x610b
/**
 * \ref PS_DBG_DWATCH_ADDR2 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR2_2 0x620b
/**
 * \ref PS_DBG_DWATCH_ADDR2 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_ADDR2_3 0x630b
///@}
/**
 * \name PS_DBG_DWATCH_CTRL
 * \anchor PS_DBG_DWATCH_CTRL
 * This set of registers controls each of the four data watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref BRK_ENABLE When 1 the breakpoint is enabled.
 * 
 * \ref DBRK_CONDITION Determines the break condition: 0 = A AND B, 1 = A OR B.
 * 
 * \ref BRK_LOAD When 1 the breakpoints will be be triggered on loads.
 * 
 * \ref BRK_THREADS A bit for each thread in the machine allowing the breakpoint to be enabled individually for each thread.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_DWATCH_CTRL 0x4
/**
 * \ref PS_DBG_DWATCH_CTRL 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_CTRL_0 0x700b
/**
 * \ref PS_DBG_DWATCH_CTRL 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_CTRL_1 0x710b
/**
 * \ref PS_DBG_DWATCH_CTRL 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_CTRL_2 0x720b
/**
 * \ref PS_DBG_DWATCH_CTRL 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_DWATCH_CTRL_3 0x730b
///@}
/**
 * \name PS_DBG_RWATCH_ADDR1
 * \anchor PS_DBG_RWATCH_ADDR1
 * This set of registers contains the mask for the four resource watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_RWATCH_ADDR1 0x4
/**
 * \ref PS_DBG_RWATCH_ADDR1 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR1_0 0x800b
/**
 * \ref PS_DBG_RWATCH_ADDR1 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR1_1 0x810b
/**
 * \ref PS_DBG_RWATCH_ADDR1 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR1_2 0x820b
/**
 * \ref PS_DBG_RWATCH_ADDR1 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR1_3 0x830b
///@}
/**
 * \name PS_DBG_RWATCH_ADDR2
 * \anchor PS_DBG_RWATCH_ADDR2
 * This set of registers contains the value for the four resource watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_RWATCH_ADDR2 0x4
/**
 * \ref PS_DBG_RWATCH_ADDR2 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR2_0 0x900b
/**
 * \ref PS_DBG_RWATCH_ADDR2 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR2_1 0x910b
/**
 * \ref PS_DBG_RWATCH_ADDR2 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR2_2 0x920b
/**
 * \ref PS_DBG_RWATCH_ADDR2 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_ADDR2_3 0x930b
///@}
/**
 * \name PS_DBG_RWATCH_CTRL
 * \anchor PS_DBG_RWATCH_CTRL
 * This set of registers controls each of the four resource watchpoints.
 * 
 * Sub-Fields:
 * 
 * \ref BRK_ENABLE When 1 the breakpoint is enabled.
 * 
 * \ref RBRK_CONDITION When 0 break when condition A is met. When 1 = break when condition B is met.
 * 
 * \ref BRK_THREADS A bit for each thread in the machine allowing the breakpoint to be enabled individually for each thread.
 * 
 */
///@{
#define XS1_NUM_PS_DBG_RWATCH_CTRL 0x4
/**
 * \ref PS_DBG_RWATCH_CTRL 0 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_CTRL_0 0x9c0b
/**
 * \ref PS_DBG_RWATCH_CTRL 1 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_CTRL_1 0x9d0b
/**
 * \ref PS_DBG_RWATCH_CTRL 2 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_CTRL_2 0x9e0b
/**
 * \ref PS_DBG_RWATCH_CTRL 3 processor state register ID.
 * Use getps() to access.
 * Only accessible in debug mode.
 */
#define XS1_PS_DBG_RWATCH_CTRL_3 0x9f0b
///@}
/**
 * PS_CACHE_MISS_CNT processor state register ID.
 * Use getps() to access.
 * 
 * This is a free running, unresetable, read-only counter incremented on every cache miss by any thread to either SWMEM or EXTMEM.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PS_CACHE_MISS_CNT 0xa00b
/**
 * PS_CACHE_ACCESS_CNT processor state register ID.
 * Use getps() to access.
 * 
 * This is a free running, unresetable, read-only counter incremented on every cache access by any thread to either SWMEM or EXTMEM.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PS_CACHE_ACCESS_CNT 0xa10b
/// @}
/**
 * \defgroup xs3aPSWITCHRegisters xs3a PSWITCH Registers
 * @{
 */
/**
 * PSWITCH_DEVICE_ID0 processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register identifies the xCORE Tile
 * 
 * Sub-Fields:
 * 
 * \ref DEVICE_ID0_VERSION XCore version.
 * 
 * \ref DEVICE_ID0_REVISION XCore revision.
 * 
 * \ref DEVICE_ID0_NODE Number of the node in which this XCore is located.
 * 
 * \ref DEVICE_ID0_PID Processor ID of this XCore.
 * 
 */
#define XS1_PSWITCH_DEVICE_ID0_NUM 0x0
/**
 * PSWITCH_DEVICE_ID1 processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register describes the number of logical cores, synchronisers, locks and channel ends available on this xCORE tile.
 * 
 * Sub-Fields:
 * 
 * \ref DEVICE_ID1_NUM_THREADS Number of threads.
 * 
 * \ref DEVICE_ID1_NUM_SYNCS Number of synchronisers.
 * 
 * \ref DEVICE_ID1_NUM_LOCKS Number of the locks.
 * 
 * \ref DEVICE_ID1_NUM_CHANENDS Number of channel ends.
 * 
 */
#define XS1_PSWITCH_DEVICE_ID1_NUM 0x1
/**
 * PSWITCH_DEVICE_ID2 processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register describes the number of timers and clock blocks available on this xCORE tile.
 * 
 * Sub-Fields:
 * 
 * \ref DEVICE_ID2_NUM_TIMERS Number of timers.
 * 
 * \ref DEVICE_ID2_NUM_CLKBLKS Number of clock blocks.
 * 
 */
#define XS1_PSWITCH_DEVICE_ID2_NUM 0x2
/**
 * PSWITCH_DEVICE_ID3 processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 */
#define XS1_PSWITCH_DEVICE_ID3_NUM 0x3
/**
 * PSWITCH_DBG_CTRL processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register can be used to control whether the debug registers (marked with permission CRW) are accessible through the tile configuration registers. When this bit is set, write -access to those registers is disabled, preventing debugging of the xCORE tile over the interconnect.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_CTRL_PSWITCH_RO_EXT When 1 the PSwitch is restricted to RO access to all CRW registers from SSwitch 
 * 
 * \ref DBG_CTRL_PSWITCH_RO When 1 the PSwitch is restricted to RO access to all CRW registers from SSwitch, XCore(PS_DBG_Scratch) and JTAG 
 * 
 */
#define XS1_PSWITCH_DBG_CTRL_NUM 0x4
/**
 * PSWITCH_DBG_INT processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register can be used to raise a debug interrupt in this xCORE tile.
 * 
 * Sub-Fields:
 * 
 * \ref DBG_INT_REQ_DBG Request a debug interrupt on the processor.
 * 
 * \ref DBG_INT_IN_DBG 1 when the processor is in debug mode.
 * 
 */
#define XS1_PSWITCH_DBG_INT_NUM 0x5
/**
 * PSWITCH_PLL_CLK_DIVIDER processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * This register contains the value used to divide the PLL clock to create the xCORE tile clock. The divider is enabled under control of the tile control register
 * 
 * Sub-Fields:
 * 
 * \ref PLL_CLK_DIVIDER Clock divider.
 * 
 * \ref PLL_CLK_DISABLE Clock disable. Writing '1' will remove the clock to the tile.
 * 
 */
#define XS1_PSWITCH_PLL_CLK_DIVIDER_NUM 0x6
/**
 * PSWITCH_SECU_CONFIG processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Copy of the security register as read from OTP.
 * 
 * Sub-Fields:
 * 
 * \ref SECUR_CFG_DISABLE_XCORE_JTAG Disable access to XCore's JTAG debug TAP 
 * 
 * \ref SECUR_CFG_DISABLE_PLL_JTAG Disable JTAG access to the PLL/BOOT configuration registers 
 * 
 * \ref SECUR_CFG_SECURE_BOOT Override boot mode and read boot image from OTP 
 * 
 * \ref SECUR_CFG_OTP_COMBINED Combine OTP into a single address-space for reading.
 * 
 * \ref SECUR_CFG_OTP_PROGRAM_DISABLE Prevent access to OTP SBPI interface to prevent programming and other functions. 
 * 
 * \ref SECUR_CFG_OTP_READ_LOCK Disable read access to OTP. 
 * 
 * \ref SECUR_CFG_DISABLE_GLOBAL_DEBUG Disable access to XCore's global debug 
 * 
 * \ref SECUR_CFG_DISABLE_ACCESS Disables write permission on this register 
 * 
 */
#define XS1_PSWITCH_SECU_CONFIG_NUM 0x7
/**
 * \name PSWITCH_DBG_SCRATCH
 * \anchor PSWITCH_DBG_SCRATCH
 * A set of registers used by the debug ROM to communicate with an external debugger, for example over the switch. This is the same set of registers as the Debug Scratch registers in the processor status.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
///@{
#define XS1_NUM_PSWITCH_DBG_SCRATCH 0x8
/**
 * \ref PSWITCH_DBG_SCRATCH 0 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_0_NUM 0x20
/**
 * \ref PSWITCH_DBG_SCRATCH 1 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_1_NUM 0x21
/**
 * \ref PSWITCH_DBG_SCRATCH 2 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_2_NUM 0x22
/**
 * \ref PSWITCH_DBG_SCRATCH 3 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_3_NUM 0x23
/**
 * \ref PSWITCH_DBG_SCRATCH 4 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_4_NUM 0x24
/**
 * \ref PSWITCH_DBG_SCRATCH 5 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_5_NUM 0x25
/**
 * \ref PSWITCH_DBG_SCRATCH 6 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_6_NUM 0x26
/**
 * \ref PSWITCH_DBG_SCRATCH 7 processor switch register number.
 * Use read_pswitch_reg() and write_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 */
#define XS1_PSWITCH_DBG_SCRATCH_7_NUM 0x27
///@}
/**
 * PSWITCH_T0_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 0.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T0_PC_NUM 0x40
/**
 * PSWITCH_T1_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 1.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T1_PC_NUM 0x41
/**
 * PSWITCH_T2_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 2.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T2_PC_NUM 0x42
/**
 * PSWITCH_T3_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 3.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T3_PC_NUM 0x43
/**
 * PSWITCH_T4_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 4.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T4_PC_NUM 0x44
/**
 * PSWITCH_T5_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 5.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T5_PC_NUM 0x45
/**
 * PSWITCH_T6_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 6.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T6_PC_NUM 0x46
/**
 * PSWITCH_T7_PC processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the PC of logical core 7.
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T7_PC_NUM 0x47
/**
 * PSWITCH_T0_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 0
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T0_SR_NUM 0x60
/**
 * PSWITCH_T1_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 1
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T1_SR_NUM 0x61
/**
 * PSWITCH_T2_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 2
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T2_SR_NUM 0x62
/**
 * PSWITCH_T3_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 3
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T3_SR_NUM 0x63
/**
 * PSWITCH_T4_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 4
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T4_SR_NUM 0x64
/**
 * PSWITCH_T5_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 5
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T5_SR_NUM 0x65
/**
 * PSWITCH_T6_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 6
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T6_SR_NUM 0x66
/**
 * PSWITCH_T7_SR processor switch register number.
 * Use read_pswitch_reg() to access.
 * Only accessible if PSWITCH_DBG_CTRL is zero.
 * 
 * Value of the SR of logical core 7
 * 
 * Sub-Fields:
 * 
 * \ref ALL_BITS Value.
 * 
 */
#define XS1_PSWITCH_T7_SR_NUM 0x67
/// @}
/**
 * \defgroup xs3aSSWITCHRegisters xs3a SSWITCH Registers
 * @{
 */
/**
 * SSWITCH_DEVICE_ID0 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * This register contains version and revision identifiers and the mode-pins as sampled at boot-time.
 * 
 * Sub-Fields:
 * 
 * \ref SS_DEVICE_ID0_VERSION SSwitch version.
 * 
 * \ref SS_DEVICE_ID0_REVISION SSwitch revision.
 * 
 * \ref SS_DEVICE_ID0_BOOT_CTRL Sampled values of BootCtl pins on Power On Reset.
 * 
 */
#define XS1_SSWITCH_DEVICE_ID0_NUM 0x0
/**
 * SSWITCH_DEVICE_ID1 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * This register specifies the number of processors and links that are connected to this switch.
 * 
 * Sub-Fields:
 * 
 * \ref SS_DEVICE_ID1_NUM_PLINKS_PER_PROC Number of processors on the device.
 * 
 * \ref SS_DEVICE_ID1_NUM_PROCESSORS Number of processors on the SSwitch.
 * 
 * \ref SS_DEVICE_ID1_NUM_SLINKS Number of SLinks on the SSwitch.
 * 
 */
#define XS1_SSWITCH_DEVICE_ID1_NUM 0x1
/**
 * SSWITCH_DEVICE_ID2 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_DEVICE_ID2_NUM 0x2
/**
 * SSWITCH_DEVICE_ID3 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_DEVICE_ID3_NUM 0x3
/**
 * SSWITCH_NODE_CONFIG system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register enables the setting of two security modes (that disable updates to the PLL or any other registers) and the header-mode.
 * 
 * Sub-Fields:
 * 
 * \ref SS_NODE_CONFIG_HEADERS 0 = 2-byte headers, 1 = 1-byte headers (reset as 0).
 * 
 * \ref SS_NODE_CONFIG_DISABLE_PLL_CTL_REG 0 = PLL_CTL_REG has write access. 1 = PLL_CTL_REG can not be written to.
 * 
 * \ref SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE 0 = SSCTL registers have write access. 1 = SSCTL registers can not be written to.
 * 
 */
#define XS1_SSWITCH_NODE_CONFIG_NUM 0x4
/**
 * SSWITCH_NODE_ID system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register contains the node identifier.
 * 
 * Sub-Fields:
 * 
 * \ref SS_NODE_ID_ID The unique ID of this node.
 * 
 */
#define XS1_SSWITCH_NODE_ID_NUM 0x5
/**
 * SSWITCH_PLL_CTL system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * An on-chip PLL multiplies the input clock up to a higher frequency clock, used to clock the I/O, processor, and switch, see Oscillator. Note: a write to this register will cause the tile to be reset.
 * 
 * Sub-Fields:
 * 
 * \ref SS_PLL_CTL_INPUT_DIVISOR Oscilator input divider value range from 0 (0x00) to 63 (0x3F). R value.
 * 
 * \ref SS_PLL_CTL_FEEDBACK_MUL Feedback multiplication ratio, range from 1 (0x0001) to 8191 (0x1FFF). F value.
 * 
 * \ref SS_PLL_CTL_POST_DIVISOR Output divider value range from 0 to 7. OD value.
 * 
 * \ref SS_PLL_CTL_DISABLE If set to 1, the PLL is disabled.
 * 
 * \ref SS_TEST_MODE_BOOT_RAM If set to 1, set the boot mode to jump to RAM
 * 
 * \ref SS_TEST_MODE_PLL_BYPASS If set to 1, set the PLL to be bypassed
 * 
 * \ref SS_TEST_MODE_BOOT_JTAG If set to 1, set the boot mode to boot from JTAG
 * 
 * \ref SS_PLL_CTL_NLOCK If set to 1, the chip will not wait for the PLL to re-lock. Only use this
 *       if a gradual change is made to the PLL
 * 
 * \ref SS_PLL_CTL_NRESET If set to 1, the chip will not be reset
 * 
 */
#define XS1_SSWITCH_PLL_CTL_NUM 0x6
/**
 * SSWITCH_CLK_DIVIDER system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Sets the ratio of the PLL clock and the switch clock.
 * 
 * Sub-Fields:
 * 
 * \ref SS_CLK_DIVIDER_CLK_DIV SSwitch clock divider
 * 
 */
#define XS1_SSWITCH_CLK_DIVIDER_NUM 0x7
/**
 * SSWITCH_REF_CLK_DIVIDER system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Sets the ratio of the PLL clock and the reference clock used by the node.
 * 
 * Sub-Fields:
 * 
 * \ref SS_SSWITCH_REF_CLK_DIV Software reference clock divider
 * 
 */
#define XS1_SSWITCH_REF_CLK_DIVIDER_NUM 0x8
/**
 * SSWITCH_JTAG_DEVICE_ID system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref SS_JTAG_DEVICE_ID_CONST_VAL 
 * 
 * \ref SS_JTAG_DEVICE_ID_MANU_ID 
 * 
 * \ref SS_JTAG_DEVICE_ID_PART_NUM 
 * 
 * \ref SS_JTAG_DEVICE_ID_VERSION 
 * 
 */
#define XS1_SSWITCH_JTAG_DEVICE_ID_NUM 0x9
/**
 * SSWITCH_JTAG_USERCODE system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref SS_JTAG_USERCODE_MASKID metal fixable ID code 
 * 
 * \ref SS_JTAG_USERCODE_OTP JTAG USERCODE value programmed into OTP SR
 * 
 */
#define XS1_SSWITCH_JTAG_USERCODE_NUM 0xa
/**
 * SSWITCH_DDR_CLK_DIVIDER system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Sets the ratio of the PLL/APP PLL clock and the LPDDR clock. There is a divide by 2 permanently after the clock divider to create a matched mark space ratio. The LPDDR clock needs to be set to be twice the frequency required.
 * 
 * Sub-Fields:
 * 
 * \ref SS_DDR_CLK_DIV LPDDR clock divider. When set to ``X`` the input clock
 *       is divided by ``2(X+1)``.
 * 
 * \ref SS_DDR_CLK_DIV_DISABLE LPDDR clock divider disable. When set to 0, the
 *       divider is enabled.
 * 
 * \ref SS_DDR_CLK_FROM_APP_PLL If set to 1, the secondary PLL is used as a source for
 *       the LPDDR clock divider. By default, the output of the core PLL is used.
 * 
 */
#define XS1_SSWITCH_DDR_CLK_DIVIDER_NUM 0xb
/**
 * SSWITCH_DIMENSION_DIRECTION0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register contains eight directions, for packets with a mismatch in bits 7..0 of the node-identifier. The direction in which a packet will be routed is goverened by the most significant mismatching bit.
 * 
 * Sub-Fields:
 * 
 * \ref DIM0_DIR The direction for packets whose dimension is 0.  
 * 
 * \ref DIM1_DIR The direction for packets whose dimension is 1.  
 * 
 * \ref DIM2_DIR The direction for packets whose dimension is 2.  
 * 
 * \ref DIM3_DIR The direction for packets whose dimension is 3.  
 * 
 * \ref DIM4_DIR The direction for packets whose dimension is 4.  
 * 
 * \ref DIM5_DIR The direction for packets whose dimension is 5.  
 * 
 * \ref DIM6_DIR The direction for packets whose dimension is 6.  
 * 
 * \ref DIM7_DIR The direction for packets whose dimension is 7.  
 * 
 */
#define XS1_SSWITCH_DIMENSION_DIRECTION0_NUM 0xc
/**
 * SSWITCH_DIMENSION_DIRECTION1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register contains eight directions, for packets with a mismatch in bits 15..8 of the node-identifier. The direction in which a packet will be routed is goverened by the most significant mismatching bit.
 * 
 * Sub-Fields:
 * 
 * \ref DIM8_DIR The direction for packets whose dimension is 8.  
 * 
 * \ref DIM9_DIR The direction for packets whose dimension is 9.  
 * 
 * \ref DIMA_DIR The direction for packets whose dimension is A.  
 * 
 * \ref DIMB_DIR The direction for packets whose dimension is B.  
 * 
 * \ref DIMC_DIR The direction for packets whose dimension is C.  
 * 
 * \ref DIMD_DIR The direction for packets whose dimension is D.  
 * 
 * \ref DIME_DIR The direction for packets whose dimension is E.  
 * 
 * \ref DIMF_DIR The direction for packets whose dimension is F.  
 * 
 */
#define XS1_SSWITCH_DIMENSION_DIRECTION1_NUM 0xd
/**
 * SSWITCH_SS_APP_CLK_DIVIDER system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * The clock divider and output of the secondary PLL can be set
 *       in this register
 * 
 * Sub-Fields:
 * 
 * \ref SS_APP_CLK_DIV Application clock divider. When set to ``X``, the output
 *       of the secondary PLL will be divided by ``2(X+1)`` in order to form the
 *       output on the output pin
 * 
 * \ref SS_APP_CLK_DIV_DISABLE Application clock divider disable. When set to 0, the
 *       divider is enabled, and pin X1D11 will be connected to the
 *       application clock rather than to port 1D.
 * 
 * \ref SS_APP_CLK_FROM_APP_PLL If set to 1, the secondary PLL is used as a source for
 *       the application clock divider. By default, the output of the core PLL is used.
 * 
 */
#define XS1_SSWITCH_SS_APP_CLK_DIVIDER_NUM 0xe
/**
 * SSWITCH_SS_APP_PLL_CTL system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * A secondary on-chip PLL multiplies the input clock
 *       up to a higher frequency clock.
 *       See Section secondary-pll.
 * 
 * Sub-Fields:
 * 
 * \ref SS_PLL_CTL_INPUT_DIVISOR Oscilator input divider value range from 0 (0x00) to 63 (0x3F). R value.
 * 
 * \ref SS_PLL_CTL_FEEDBACK_MUL Feedback multiplication ratio, range from 1 (0x0001) to 8191 (0x1FFF). F value.
 * 
 * \ref SS_PLL_CTL_POST_DIVISOR Output divider value range from 0 to 7. OD value.
 * 
 * \ref SS_APP_PLL_ENABLE If set to 1, enable the secondary PLL
 * 
 * \ref SS_APP_PLL_INPUT_FROM_SYS_PLL If set to 1, use the output of the core PLL as input,
 *       otherwise use the crystal oscillator as input.
 * 
 * \ref SS_APP_PLL_BYPASS If set to 1, set the APP PLL to be bypassed
 * 
 */
#define XS1_SSWITCH_SS_APP_PLL_CTL_NUM 0xf
/**
 * SSWITCH_XCORE0_GLOBAL_DEBUG_CONFIG system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * if DEBUGN Configures the behavior of the DEBUG_N pin.else  Reserved.
 * 
 * Sub-Fields:
 * 
 * \ref GLOBAL_DEBUG_ENABLE_INDEBUG if DEBUGN Set 1 to enable inDebug bit to drive GlobalDebug.else  Reserved.
 * 
 * \ref GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ if DEBUGN Set 1 to enable GlobalDebug to generate debug request to XCore.else  Reserved.
 * 
 */
#define XS1_SSWITCH_XCORE0_GLOBAL_DEBUG_CONFIG_NUM 0x10
/**
 * SSWITCH_XCORE1_GLOBAL_DEBUG_CONFIG system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * if DEBUGN Configures the behavior of the DEBUG_N pin.else  Reserved.
 * 
 * Sub-Fields:
 * 
 * \ref GLOBAL_DEBUG_ENABLE_INDEBUG if DEBUGN Set 1 to enable inDebug bit to drive GlobalDebug.else  Reserved.
 * 
 * \ref GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ if DEBUGN Set 1 to enable GlobalDebug to generate debug request to XCore.else  Reserved.
 * 
 */
#define XS1_SSWITCH_XCORE1_GLOBAL_DEBUG_CONFIG_NUM 0x11
/**
 * SSWITCH_SS_APP_PLL_FRAC_N_DIVIDER system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Controls an optional fractional N Divider on the
 *       secondary PLL. When enabled, the multiplier ``F`` for the secondary PLL
 *       will effectively become ``F+\frac{f+1}{p+1}``, ``f`` must be less than
 *       ``p``. This is achieved by running
 *       the PLL with a divider ``F`` for the first part of the fractional
 *       period, and then ``F+1`` for the remainder of the period. The period is
 *       measured in input clocks divided by ``R+1``.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref SS_FRAC_N_PERIOD_CYC_CNT The ``p`` value for the fractional divider. The period
 *       over which the fractional N divider
 *       oscillates between ``F`` and ``F+1`` is ``p+1``
 * 
 * \ref SS_FRAC_N_F_HIGH_CYC_CNT The ``f`` value for the fractional divider.
 *       The number of clock cycles in the period that a divider ``F+1`` is used
 *       is ``f+1``.
 * 
 * \ref SS_FRAC_N_ENABLE When set to 1, the secondary PLL will be a fractional
 *       ``N`` divided PLL
 * 
 */
#define XS1_SSWITCH_SS_APP_PLL_FRAC_N_DIVIDER_NUM 0x12
/**
 * SSWITCH_SS_LPDDR_CONTROLLER_CONFIG system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Controls whether LPDDR Controller is enabled, and which core it is accessible to through the mux.
 * 
 * Sub-Fields:
 * 
 * \ref SS_LPDDR_ENABLE When set to 1 this will allow the LPDDR controller to access the pads
 * 
 * \ref SS_LPDDR_MUXTO_CORE1 Defines which xCORE has access to the LPDDR controller via the mux
 * 
 */
#define XS1_SSWITCH_SS_LPDDR_CONTROLLER_CONFIG_NUM 0x13
/**
 * SSWITCH_MIPI_CLK_DIVIDER system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Configures the clock to the MIPI shim, the hardware
 *       block interfacing the MIPI PHY to the xCORE.
 * 
 * Sub-Fields:
 * 
 * \ref SS_SSWITCH_MIPI_CLK_DIV MIPI shim clock divider. When set to ``X`` the input clock
 *       is divided by ``2(X+1)``.
 * 
 * \ref SS_SSWITCH_MIPI_CLK_DIV_DISABLE MIPI clock divider disable. When set to 0, the
 *       divider is enabled.
 * 
 * \ref SS_MIPI_CLK_FROM_APP_PLL If set to 1, the secondary PLL is used as a source for
 *       the MIPI shim clock divider. By default, the output of the core PLL is used.
 * 
 */
#define XS1_SSWITCH_MIPI_CLK_DIVIDER_NUM 0x14
/**
 * SSWITCH_MIPI_CFG_CLK_DIVIDER system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Configures the clock to the MIPI PHY.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref SS_MIPI_CFG_CLK_DIV MIPI PHY clock divider. When set to ``X``, the input
 *       clock will be divided by ``2(X+1)``.
 * 
 * \ref SS_MIPI_CFG_CLK_DIV_DISABLE MIPI PHY clock divider disable. When set to 0, the
 *       divider is enabled.
 * 
 * \ref SS_MIPI_CFG_CLK_FROM_APP_PLL If set to 1, the secondary PLL is used as a source for
 *       the MIPI PHY clock divider. By default, the output of the core PLL is used.
 * 
 */
#define XS1_SSWITCH_MIPI_CFG_CLK_DIVIDER_NUM 0x15
/**
 * SSWITCH_GLOBAL_DEBUG_SOURCE system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * Contains the source of the most recent debug event.
 * 
 * Sub-Fields:
 * 
 * \ref GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG If set, XCore0 is the source of last GlobalDebug event.
 * 
 * \ref GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG If set, XCore1 is the source of last GlobalDebug event.
 * 
 * \ref GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG if DEBUGN If set, external pin, is the source of last GlobalDebug event.else  Reserved.
 * 
 */
#define XS1_SSWITCH_GLOBAL_DEBUG_SOURCE_NUM 0x1f
/**
 * \name SSWITCH_SLINK
 * \anchor SSWITCH_SLINK
 * These registers contain status information for low level debugging
 *         (read-only), the network number that each link belongs to, and the
 *         direction that each link is part of. The registers control links 0..7.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref LINK_SRC_INUSE 1 when the source side of the link is in use.
 * 
 * \ref LINK_DST_INUSE 1 when the dest side of the link is in use.
 * 
 * \ref LINK_JUNK 1 when the current packet is considered junk and will be thrown away.
 * 
 * \ref LINK_NETWORK Determines the network to which this link belongs, reset as 0.
 * 
 * \ref LINK_DIRECTION The direction that this link operates in.
 * 
 * \ref SLINK_SRC_TARGET_ID When the link is in use, this is the destination link number to which all packets are sent.
 * 
 * \ref SLINK_SRC_TARGET_TYPE Identify the SRC_TARGET type 0 - SLink, 1 - PLink, 2 - SSCTL, 3 - Undefine.
 * 
 */
///@{
#define XS1_NUM_SSWITCH_SLINK 0x9
/**
 * \ref SSWITCH_SLINK 0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_0_NUM 0x20
/**
 * \ref SSWITCH_SLINK 1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_1_NUM 0x21
/**
 * \ref SSWITCH_SLINK 2 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_2_NUM 0x22
/**
 * \ref SSWITCH_SLINK 3 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_3_NUM 0x23
/**
 * \ref SSWITCH_SLINK 4 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_4_NUM 0x24
/**
 * \ref SSWITCH_SLINK 5 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_5_NUM 0x25
/**
 * \ref SSWITCH_SLINK 6 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_6_NUM 0x26
/**
 * \ref SSWITCH_SLINK 7 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_7_NUM 0x27
/**
 * \ref SSWITCH_SLINK 8 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_SLINK_8_NUM 0x28
///@}
/**
 * \name SSWITCH_PLINK
 * \anchor SSWITCH_PLINK
 * These registers contain status information and the network number that each processor-link belongs to.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref LINK_SRC_INUSE 1 when the source side of the link is in use.
 * 
 * \ref LINK_DST_INUSE 1 when the dest side of the link is in use.
 * 
 * \ref LINK_JUNK 1 when the current packet is considered junk and will be thrown away.
 * 
 * \ref LINK_NETWORK Determines the network to which this link belongs, reset as 0.
 * 
 * \ref PLINK_SRC_TARGET_ID When the link is in use, this is the destination link number to which all packets are sent.
 * 
 * \ref PLINK_SRC_TARGET_TYPE Identify the SRC_TARGET type 0 - SLink, 1 - PLink, 2 - SSCTL, 3 - Undefine.
 * 
 */
///@{
#define XS1_NUM_SSWITCH_PLINK 0x8
/**
 * \ref SSWITCH_PLINK 0 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_0_NUM 0x40
/**
 * \ref SSWITCH_PLINK 1 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_1_NUM 0x41
/**
 * \ref SSWITCH_PLINK 2 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_2_NUM 0x42
/**
 * \ref SSWITCH_PLINK 3 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_3_NUM 0x43
/**
 * \ref SSWITCH_PLINK 4 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_4_NUM 0x44
/**
 * \ref SSWITCH_PLINK 5 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_5_NUM 0x45
/**
 * \ref SSWITCH_PLINK 6 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_6_NUM 0x46
/**
 * \ref SSWITCH_PLINK 7 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_PLINK_7_NUM 0x47
///@}
/**
 * \name SSWITCH_XLINK
 * \anchor SSWITCH_XLINK
 * These registers contain configuration and debugging information
 *         specific to external links. The link speed and width can be set,
 *         the link can be initialized, and the link status can be monitored.
 *         The registers control links 0..7.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref XLINK_INTER_TOKEN_DELAY Specify min. number of idle system clocks between two continuous transmit tokens -1.
 * 
 * \ref XLINK_INTRA_TOKEN_DELAY Specify min. number of idle system clocks between two continuous symbols witin a transmit token -1.
 * 
 * \ref XLINK_RX_RESET Reset the receiver.  The next symbol that is detected will be the first symbol in a token.
 * 
 * \ref XLINK_HELLO Clear this end of the xlink's credit and issue a HELLO token.
 * 
 * \ref TX_CREDIT This end of the xlink has credit to allow it to transmit.
 * 
 * \ref RX_CREDIT This end of the xlink has issued credit to allow the remote end to transmit
 * 
 * \ref XLINK_RX_ERROR Rx buffer overflow or illegal token encoding received.
 * 
 * \ref XLINK_WIDE 0: operate in 2 wire mode; 1: operate in 5 wire mode
 * 
 * \ref XLINK_ENABLE Write to this bit with '1' will enable the XLink, writing '0' will disable it. This bit controls the muxing of ports with overlapping xlinks.
 * 
 */
///@{
#define XS1_NUM_SSWITCH_XLINK 0x9
/**
 * \ref SSWITCH_XLINK 0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_0_NUM 0x80
/**
 * \ref SSWITCH_XLINK 1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_1_NUM 0x81
/**
 * \ref SSWITCH_XLINK 2 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_2_NUM 0x82
/**
 * \ref SSWITCH_XLINK 3 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_3_NUM 0x83
/**
 * \ref SSWITCH_XLINK 4 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_4_NUM 0x84
/**
 * \ref SSWITCH_XLINK 5 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_5_NUM 0x85
/**
 * \ref SSWITCH_XLINK 6 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_6_NUM 0x86
/**
 * \ref SSWITCH_XLINK 7 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_7_NUM 0x87
/**
 * \ref SSWITCH_XLINK 8 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XLINK_8_NUM 0x88
///@}
/**
 * \name SSWITCH_XSTATIC
 * \anchor SSWITCH_XSTATIC
 * These registers are used for static (ie, non-routed) links.
 *         When a link is made static, all traffic is forwarded to the
 *         designated channel end and no routing is attempted.
 *         The registers control links C, D, A, B, G, H, E, and F in that order.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref XSTATIC_DEST_CHAN_END The destination channel end on this node that packets received in static mode are forwarded to.
 * 
 * \ref XSTATIC_DEST_PROC The destination processor on this node that packets received in static mode are forwarded to.
 * 
 * \ref XSTATIC_ENABLE Enable static forwarding.
 * 
 */
///@{
#define XS1_NUM_SSWITCH_XSTATIC 0x8
/**
 * \ref SSWITCH_XSTATIC 0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_0_NUM 0xa0
/**
 * \ref SSWITCH_XSTATIC 1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_1_NUM 0xa1
/**
 * \ref SSWITCH_XSTATIC 2 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_2_NUM 0xa2
/**
 * \ref SSWITCH_XSTATIC 3 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_3_NUM 0xa3
/**
 * \ref SSWITCH_XSTATIC 4 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_4_NUM 0xa4
/**
 * \ref SSWITCH_XSTATIC 5 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_5_NUM 0xa5
/**
 * \ref SSWITCH_XSTATIC 6 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_6_NUM 0xa6
/**
 * \ref SSWITCH_XSTATIC 7 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_XSTATIC_7_NUM 0xa7
///@}
/**
 * SSWITCH_USB_XCFGI_REG0 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_USB_XCFGI_REG0_NUM 0xf000
/**
 * SSWITCH_USB_XCFGI_REG1 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_USB_XCFGI_REG1_NUM 0xf001
/**
 * SSWITCH_USB_XCFGI_REG2 system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_USB_XCFGI_REG2_NUM 0xf002
/**
 * SSWITCH_USB_XCFG_COARSE_TUNE system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_USB_XCFG_COARSE_TUNE_NUM 0xf003
/**
 * SSWITCH_USB_XCFG_FINE_TUNE system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_USB_XCFG_FINE_TUNE_NUM 0xf004
/**
 * SSWITCH_USB_XCFG_LOCK_RANGE_MAX system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_USB_XCFG_LOCK_RANGE_MAX_NUM 0xf005
/**
 * SSWITCH_USB_XCFG_LOCK_RANGE_MIN system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_USB_XCFG_LOCK_RANGE_MIN_NUM 0xf006
/**
 * SSWITCH_USB_PHY_CFG0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register configures the UTMI signals to the USB
 *       PHY. See the UTMI specification for more details. The oscillator
 *       speed should be set to match the crystal on XIN/XOUT.
 * 
 * Sub-Fields:
 * 
 * \ref USB_PHY_CFG0_UTMI_XCVRSELECT Value of the UTMI XCVRSelect signals to the USB Phy
 * 
 * \ref USB_PHY_CFG0_UTMI_TERMSELECT Value of the UTMI Terminal Select signal to the USB Phy
 * 
 * \ref USB_PHY_CFG0_UTMI_OPMODE Value of the UTMI OpMode signals to the USB Phy
 * 
 * \ref USB_PHY_CFG0_UTMI_SUSPENDM Value of the UTMI SuspendM signal to the USB Phy
 * 
 * \ref USB_PHY_CFG0_DPPULLDOWN Set to 1 to enable the DP Pulldown
 * 
 * \ref USB_PHY_CFG0_DMPULLDOWN Set to 1 to enable the DM Pulldown
 * 
 * \ref USB_PHY_CFG0_TXBITSTUFF_EN Set to 1 to enable USB Tx BitStuffing
 * 
 * \ref USB_PHY_CFG0_PLL_EN Set to 1 to enable the USB PLL
 * 
 * \ref USB_PHY_CFG0_LPM_ALIVE Set to 1 to enable USB LPM
 * 
 * \ref USB_PHY_CFG0_IDPAD_EN Set to 1 to enable the ID PAD
 * 
 * \ref USB_PHY_CFG0_XTLSEL Oscillator freqeuncy. Set to: 0 (10MHz), 1 (12MHz), 2
 *       (25MHz), 3~(30MHz),
 *       4 (19.2MHz), 5 (24MHz), 6 (27MHz), or 7 (40MHz).
 * 
 */
#define XS1_SSWITCH_USB_PHY_CFG0_NUM 0xf008
/**
 * SSWITCH_USB_PHY_CFG1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_USB_PHY_CFG1_NUM 0xf009
/**
 * SSWITCH_USB_PHY_CFG2 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref USB_PHY_CFG2_PONRST USB PHY reset, set to 1 to take the PHY out of reset
 * 
 * \ref USB_PHY_CFG2_UTMI_RESET UTMI reset, set to 0 to take UTMI out of reset
 * 
 */
#define XS1_SSWITCH_USB_PHY_CFG2_NUM 0xf00a
/**
 * SSWITCH_USB_PHY_CFG3 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref USB_PHY_CFG3_VCONTROL USB VCONTROL
 * 
 * \ref USB_PHY_CFG3_EXTERNAL_TEST_MODE USB EXTERNAL TEST MODE
 * 
 * \ref USB_PHY_CFG3_LS_EN USB LS Enable
 * 
 * \ref USB_PHY_CFG3_UTMI_VCONTROLLOADM USB UTMI VCONTROLLOADM
 * 
 * \ref USB_PHY_CFG3_HS_BIST_MODE USB HS BIST Mode
 * 
 */
#define XS1_SSWITCH_USB_PHY_CFG3_NUM 0xf00b
/**
 * SSWITCH_USB_SHIM_CFG system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register contains the hardware interfacing the
 *       USB PHY and the xCORE. It governs how the rxActive, rxValid, and
 *       line-state signals are mapped onto two one-bit ports.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref USB_SHIM_CFG_AND_RXV_RXA When enabled RxValid output to xCore is AND'd with RxActive
 * 
 * \ref USB_SHIM_CFG_FLAG_MODE USB flag mode selection: 1 selects linestate; 0 selects RxActive and RxValid
 * 
 */
#define XS1_SSWITCH_USB_SHIM_CFG_NUM 0xf00c
/**
 * SSWITCH_USB_PHY_XCFGO_REG0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_USB_PHY_XCFGO_REG0_NUM 0xf010
/**
 * SSWITCH_USB_PHY_STATUS system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref USB_PHY_STATUS_UTMI_LINESTATE The UTMI line state; 0: SE0, 1: J, 2: K, 3: SE1
 * 
 * \ref USB_PHY_STATUS_HOSTDISCONNECT Set to 1 if no peripheral is connected
 * 
 * \ref USB_PHY_STATUS_IDPAD 1 if resistance of IDPAD to ground is > 100 kOhm (mini B
 *       plug)
 * 
 * \ref USB_PHY_STATUS_BIST_OK 1 if BIST succeeded
 * 
 * \ref USB_PHY_STATUS_DEBUG_OUT Debug output signals
 * 
 */
#define XS1_SSWITCH_USB_PHY_STATUS_NUM 0xf011
/**
 * SSWITCH_USB_SHIM_STATUS system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register does not do anything
 */
#define XS1_SSWITCH_USB_SHIM_STATUS_NUM 0xf018
/**
 * SSWITCH_USB_STATUS_CLR system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register does not do anything
 */
#define XS1_SSWITCH_USB_STATUS_CLR_NUM 0xf019
/**
 * SSWITCH_WATCHDOG_CFG system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Register to control the watchdog. By default the
 *       watchdog is neither counting, nor triggering. When used as a watchdog
 *       it should be set to both count and trigger a reset on reaching 0. It
 *       can be set to just count for debugging purposes
 * 
 * Sub-Fields:
 * 
 * \ref WATCHDOG_COUNT_ENABLE Set this bit to 1 to enable the watchdog counter.
 * 
 * \ref WATCHDOG_TRIGGER_ENABLE Set this bit to 1 to enable the watchdog to actually
 *       reset the chip.
 * 
 */
#define XS1_SSWITCH_WATCHDOG_CFG_NUM 0xf020
/**
 * SSWITCH_WATCHDOG_PRESCALER system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * Register to read out the current divider counter.
 *       Can be used to implement a timer that is independent of the PLL.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref WATCHDOG_PRESCALER_VALUE This is the current count of the prescaler. One is
 *       added one every input clock edge on the oscillator (XIN). When it
 *       reaches the prescaler wrap value (see below), it resets to zero and
 *       one is subtracted from the watchdog count (see below).
 * 
 */
#define XS1_SSWITCH_WATCHDOG_PRESCALER_NUM 0xf021
/**
 * SSWITCH_WATCHDOG_PRESCALER_WRAP system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Register to set the watchdog pre-scale divider value.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref WATCHDOG_PRESCALER_WRAP_VALUE This is the prescaler divider. The input clock on
 *       XIN is divided by this value plus one, before being used to adjust
 *       the watchdog count (see below).
 * 
 */
#define XS1_SSWITCH_WATCHDOG_PRESCALER_WRAP_NUM 0xf022
/**
 * SSWITCH_WATCHDOG_COUNT system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Register to set the value at which the watchdog
 *       timer should time out. This register must be overwritten regularly to
 *       stop the watchdog from resetting the chip.
 * 
 * Sub-Fields:
 * 
 * \ref WATCHDOG_COUNT_VALUE This is the watchdog counter. It counts down every
 *       PRESCALER_WRAP_VALUE input clock edges. When it reaches zero
 *       the chip is reset. The maximum time for the watchdog is
 *       ``2^{12} \times 2^{16} = 2^{28} = 268,435,456`` input clocks.
 *       
 * 
 */
#define XS1_SSWITCH_WATCHDOG_COUNT_NUM 0xf023
/**
 * SSWITCH_WATCHDOG_STATUS system switch register number.
 * Use read_sswitch_reg() to access.
 * 
 * Register that can be used to inspect whether the
 *       watchdog has triggered.
 * 
 * Sub-Fields:
 * 
 * \ref WATCHDOG_HAS_TRIGGERED When 1, the watchdog has been triggered. This bit is
 *       only reset to 0 on a power-on-reset.
 * 
 */
#define XS1_SSWITCH_WATCHDOG_STATUS_NUM 0xf024
/**
 * \name SSWITCH_MIPI_XCFGI_REG
 * \anchor SSWITCH_MIPI_XCFGI_REG
 * Internal MIPI config registers
 */
///@{
#define XS1_NUM_SSWITCH_MIPI_XCFGI_REG 0x13
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_0_NUM 0xe000
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_1_NUM 0xe001
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 2 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_2_NUM 0xe002
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 3 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_3_NUM 0xe003
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 4 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_4_NUM 0xe004
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 5 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_5_NUM 0xe005
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 6 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_6_NUM 0xe006
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 7 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_7_NUM 0xe007
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 8 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_8_NUM 0xe008
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 9 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_9_NUM 0xe009
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 10 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_10_NUM 0xe00a
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 11 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_11_NUM 0xe00b
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 12 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_12_NUM 0xe00c
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 13 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_13_NUM 0xe00d
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 14 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_14_NUM 0xe00e
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 15 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_15_NUM 0xe00f
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 16 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_16_NUM 0xe010
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 17 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_17_NUM 0xe011
/**
 * \ref SSWITCH_MIPI_XCFGI_REG 18 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGI_REG_18_NUM 0xe012
///@}
/**
 * SSWITCH_MIPI_STATUS0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref MIPI_STATUS0_OSC_CLK_ACT Test mode osc clock act
 * 
 * \ref MIPI_STATUS0_OSC_CLK_READY Test mode osc clock ready
 * 
 * \ref MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G Test mode bit clk greater than 2400G
 * 
 * \ref MIPI_STATUS0_DATA_CORRECT_LAN0 Test mode data correct lan0
 * 
 * \ref MIPI_STATUS0_DATA_CORRECT_LAN1 Test mode data correct lan1
 * 
 * \ref MIPI_STATUS0_DATA_CORRECT_LAN2 Test mode data correct lan2
 * 
 * \ref MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C Test mode da cdphy r100 control0 2d1c
 * 
 * \ref MIPI_STATUS0_STOPSTATE_CLK Clock lane is in the stop state
 * 
 * \ref MIPI_STATUS0_STOPSTATE_LAN0 Lane 0 is in the stop state
 * 
 * \ref MIPI_STATUS0_STOPSTATE_LAN1 Lane 1 is in the stop state
 * 
 */
#define XS1_SSWITCH_MIPI_STATUS0_NUM 0xe013
/**
 * SSWITCH_MIPI_SHIM_STATUS system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register provides status for the MIPI demuxing logic
 * 
 * Sub-Fields:
 * 
 * \ref MIPI_SHIM_STATUS_REG Set to 1 if an overflow has been detected in the
 *       DEMUXER. This is not recoverable, and indicates that the MIPI_CLK is
 *       too slow for the rate at which data is received.
 * 
 */
#define XS1_SSWITCH_MIPI_SHIM_STATUS_NUM 0xe014
/**
 * SSWITCH_MIPI_DPHY_CFG0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Controls the reset signals to the MIPI D-PHY
 *       
 * 
 * Sub-Fields:
 * 
 * \ref MIPI_DPHY_CFG0_HW_RSTN Reset, set to 1 to take the MIPI PHY out of reset
 * 
 * \ref MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON Set to 1
 * 
 */
#define XS1_SSWITCH_MIPI_DPHY_CFG0_NUM 0xe018
/**
 * SSWITCH_MIPI_DPHY_CFG1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref MIPI_DPHY_CFG1_MP_TEST_EN MIPI dphy config1 mp test mode enable
 * 
 * \ref MIPI_DPHY_CFG1_MP_TEST_MODE_SEL MIPI dphy config1 mp test mode select
 * 
 * \ref MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN MIPI dphy config1 cdphy r100 control 0 2d1c efuse enable
 * 
 * \ref MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN MIPI dphy config1 cdphy r100 control 0 2d1c efuse in
 * 
 */
#define XS1_SSWITCH_MIPI_DPHY_CFG1_NUM 0xe019
/**
 * SSWITCH_MIPI_DPHY_CFG2 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref MIPI_DPHY_CFG2_PLL_CLK_SEL MIPI dphy config2 pll clock select
 * 
 */
#define XS1_SSWITCH_MIPI_DPHY_CFG2_NUM 0xe01a
/**
 * SSWITCH_MIPI_DPHY_CFG3 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Configures the settings for the three lanes, in particular, where
 *         the wires appear on the physical interfaces and which ones are enabled.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref MIPI_DPHY_CFG3_LANE_SWAP_CLK The DP/DN pair over which to input the clock
 * 
 * \ref MIPI_DPHY_CFG3_LANE_SWAP_LAN0 The DP/DN pair over which to input lane 0
 * 
 * \ref MIPI_DPHY_CFG3_LANE_SWAP_LAN1 The DP/DN pair over which to input lane 1 (if two lanes
 *       are needed)
 * 
 * \ref MIPI_DPHY_CFG3_DPDN_SWAP_CLK Set to 1 to swap the DN/DP pair on the clock lane
 * 
 * \ref MIPI_DPHY_CFG3_DPDN_SWAP_LAN0 Set to 1 to swap the DN/DP pair on the lane 0
 * 
 * \ref MIPI_DPHY_CFG3_DPDN_SWAP_LAN1 Set to 1 to swap the DN/DP pair on the lane 1
 * 
 * \ref MIPI_DPHY_CFG3_ENABLE_CLK Set to 0 to disable the clock lane receiver
 * 
 * \ref MIPI_DPHY_CFG3_ENABLE_LAN0 Set to 0 to disable lane 0 receiver
 * 
 * \ref MIPI_DPHY_CFG3_ENABLE_LAN1 Set to 0 to disable lane 1 receiver
 * 
 */
#define XS1_SSWITCH_MIPI_DPHY_CFG3_NUM 0xe01b
/**
 * SSWITCH_MIPI_DPHY_CFG4 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK MIPI dphy Tclk-settle for clock
 * 
 * \ref MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0 MIPI dphy Tclk-settle in lane 0
 * 
 * \ref MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1 MIPI dphy Tclk-settle in lane 1
 * 
 */
#define XS1_SSWITCH_MIPI_DPHY_CFG4_NUM 0xe01c
/**
 * SSWITCH_MIPI_DPHY_CFG5 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref MIPI_DPHY_CFG5_DEBUG_MODE_SEL MIPI dphy debug mode select
 * 
 */
#define XS1_SSWITCH_MIPI_DPHY_CFG5_NUM 0xe01d
/**
 * SSWITCH_MIPI_SHIM_CFG0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register is used to configure the MIPI shim,
 *       the hardware block interfacing the MIPI D-PHY to the xCORE. By
 *       default the MIPI shim just passes the data from the MIPI D-PHY
 *       straight through to the receiver. This register enables you to
 *       demultiplex 10-bit, 12-bit, 14-bit and 565-data into 16-bit and 8-bit
 *       values. When the demultiplexer is enabled, you must specify the CSI-2
 *       packet type that demultiplexing should apply to. Optionally, you can
 *       choose to align add an extra fourth byte for RGB formats, or you can
 *       choose to bias the data so that all the data values are signed.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref MIPI_SHIM_CFG0_PIXEL_DEMUX_EN Set to 1 to enable the MIPI shim to demultiplex data
 *       according to the demux mode and stuff fields. Demuxing is only
 *       applied to packets that have the correct datatype.
 * 
 * \ref MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE This field needs to be set to the CSI-2 packet type that
 *       needs to be demuxed. Only packets with a matching type are
 *       demultiplexed.
 * 
 * \ref MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE Specifies how the demultiplexer operates. The modes
 *       supported are 10to16, 12to16, 14to16, rgb565to888, rgb888to888.
 * 
 * \ref MIPI_SHIM_DEMUX_STUFF Set to 1 to add an extra data byte after every RGB565 or
 *       RGB888 pixel. This will align pixels to a 32-bit word.
 * 
 * \ref MIPI_SHIM_BIAS Set to 1 to offset the output pixels with -0x80 (for
 *       8-bit outputs) or -0x8000 (for 16-bit outputs). This can be used to
 *       make unsigned data signed around zero.
 * 
 * \ref MIPI_SHIM_CFG0_SEL_DEBUG_OUT MIPI shim config0 sel debug out
 * 
 * \ref MIPI_SHIM_CFG0_SEL_DEBUG MIPI shim config0 sel debug
 * 
 */
#define XS1_SSWITCH_MIPI_SHIM_CFG0_NUM 0xe01f
/**
 * \name SSWITCH_MIPI_XCFGO_REG
 * \anchor SSWITCH_MIPI_XCFGO_REG
 * Internal MIPI config registers
 */
///@{
#define XS1_NUM_SSWITCH_MIPI_XCFGO_REG 0x3
/**
 * \ref SSWITCH_MIPI_XCFGO_REG 0 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGO_REG_0_NUM 0xe020
/**
 * \ref SSWITCH_MIPI_XCFGO_REG 1 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGO_REG_1_NUM 0xe021
/**
 * \ref SSWITCH_MIPI_XCFGO_REG 2 system switch register number.
 * Use read_sswitch_reg() to access.
 */
#define XS1_SSWITCH_MIPI_XCFGO_REG_2_NUM 0xe022
///@}
/**
 * SSWITCH_LPDDR_IID_ENABLE system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * This register is used to enable one or more threads
 *       to route its requests through specified queues. There are three
 *       queues (one read-only queue, RO, and two read-write queues, RW0/RW1)
 *       and for each thread instruction accesses and data accesses can be
 *       routed through specified queues.
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_IID_ENABLE Two 8-bit masks, one bit per thread. Top eight bits enable
 *       instructions to be routed through a specified queue, bottom eight
 *       bits enable data to be routed through a specified queue.
 * 
 */
#define XS1_SSWITCH_LPDDR_IID_ENABLE_NUM 0xc000
/**
 * SSWITCH_LPDDR_IID_0_7 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * For each thread, this register specifies which queue
 *       a data access should be routed through.
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_IID_0_7 Four bits per thread. Top bit sets the queue type that
 *       this thread should be using (0: RO, 1: RW), further three bits the
 *       number of the queue. Valid values for the further three bits are 000
 *       for RO queues, and 000/001 for a RW queue.
 * 
 */
#define XS1_SSWITCH_LPDDR_IID_0_7_NUM 0xc001
/**
 * SSWITCH_LPDDR_IID_8_15 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * For each thread, this register specifies which queue
 *       an instruction access should be routed through.
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_IID_8_15 Four bits per thread. Top bit sets the queue type that
 *       this thread should be using (0: RO, 1: RW), further three bits the
 *       number of the queue. Valid values for the further three bits are 000
 *       for RO queues, and 000/001 for a RW queue.
 * 
 */
#define XS1_SSWITCH_LPDDR_IID_8_15_NUM 0xc002
/**
 * SSWITCH_LPDDR_QUEUE_CONT system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_QUEUE_CONT Slow sys clock. Set this bit if the tile clock is less
 *       than the LPDDR clock.
 * 
 */
#define XS1_SSWITCH_LPDDR_QUEUE_CONT_NUM 0xc003
/**
 * SSWITCH_LPDDR_RO_COMMAND_QUEUE_PRIORITY system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_RO_PRI Priority for RO queue. Zero is lowest priority.
 * 
 */
#define XS1_SSWITCH_LPDDR_RO_COMMAND_QUEUE_PRIORITY_NUM 0xc008
/**
 * SSWITCH_LPDDR_RW_COMMAND_QUEUE_PRIORITY system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_RW0_PRI Priority for RW queue 0. Zero is lowest priority.
 * 
 * \ref LPDDR_RW1_PRI Priority for RW queue 1. Zero is lowest priority.
 * 
 */
#define XS1_SSWITCH_LPDDR_RW_COMMAND_QUEUE_PRIORITY_NUM 0xc009
/**
 * SSWITCH_LPDDR_ARBITRATION_TIMEOUT system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Setting this to a non-zero value guarantees that
 *       each queue is served at least every ``N`` transactions and prevents
 *       starvation.
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_TOUT Maximum number of transactions until a queue is served.
 *                    Set to 0 to disable a timeout
 * 
 */
#define XS1_SSWITCH_LPDDR_ARBITRATION_TIMEOUT_NUM 0xc00a
/**
 * SSWITCH_LPDDR_ARBITRATION_MTG_COMMAND system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_MTG_CMD MTG Commands status for CSR Read
 * 
 */
#define XS1_SSWITCH_LPDDR_ARBITRATION_MTG_COMMAND_NUM 0xc010
/**
 * SSWITCH_LPDDR_DLL_CONTROL system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_DLL_CONTROL DLL Control
 * 
 */
#define XS1_SSWITCH_LPDDR_DLL_CONTROL_NUM 0xc014
/**
 * SSWITCH_LPDDR_DLL_MEASUREMENT_STATUS system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_DLL_MEASUREMENT_STATUS Measurement status of the DLL
 * 
 */
#define XS1_SSWITCH_LPDDR_DLL_MEASUREMENT_STATUS_NUM 0xc015
/**
 * SSWITCH_LPDDR_DLL_MANUAL_CONTROL system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_DLL_MANUAL_CONTROL DLL Manual Control
 * 
 */
#define XS1_SSWITCH_LPDDR_DLL_MANUAL_CONTROL_NUM 0xc016
/**
 * SSWITCH_LPDDR_DLL_PHY_CALIBRATION_DATA system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_DLL_PHY_CALIBRATION_DATA DLL Calibration Data
 * 
 */
#define XS1_SSWITCH_LPDDR_DLL_PHY_CALIBRATION_DATA_NUM 0xc017
/**
 * SSWITCH_LPDDR_PHY_CONTROL system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_PHY_CONTROL PHY Control
 * 
 */
#define XS1_SSWITCH_LPDDR_PHY_CONTROL_NUM 0xc01d
/**
 * SSWITCH_LPDDR_LMR_OPCODE system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_LMR_OPCODE LMR opcode
 * 
 */
#define XS1_SSWITCH_LPDDR_LMR_OPCODE_NUM 0xc01e
/**
 * SSWITCH_LPDDR_EMR_OPCODE system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * 
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_EMR_OPCODE EMR opcode
 * 
 */
#define XS1_SSWITCH_LPDDR_EMR_OPCODE_NUM 0xc01f
/**
 * SSWITCH_LPDDR_PROTOCOL_ENGINE_CONF_0 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Register used to set the tREFI, tRAS, tXSR, and tWR
 *       timings, all measured in terms of LPDDR clocks
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_PE_TREFI_CNT LPDDR tREFI clock count
 * 
 * \ref LPDDR_PE_TRAS_CNT LPDDR tRAS clock count
 * 
 * \ref LPDDR_PE_TXSR_CNT LPDDR tXSR clock count
 * 
 * \ref LPDDR_PE_TWR_CNT LPDDR tWR clock count
 * 
 */
#define XS1_SSWITCH_LPDDR_PROTOCOL_ENGINE_CONF_0_NUM 0xc020
/**
 * SSWITCH_LPDDR_PROTOCOL_ENGINE_CONF_1 system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * Register used to set the tRRC, tRCD, tRP, tRFC,
 *       and tRRD timings, all measured in terms of LPDDR clocks. This
 *       register is also used to configure the use of 256 bit memories.
 *       
 * 
 * Sub-Fields:
 * 
 * \ref LPDDR_PE_TRC_CNT LPDDR tRC clock count
 * 
 * \ref LPDDR_PE_TRCD_CNT LPDDR tRCD clock count
 * 
 * \ref LPDDR_PE_TRP_CNT LPDDR tRP clock count
 * 
 * \ref LPDDR_PE_TRFC_CNT LPDDR tRFC clock count
 * 
 * \ref LPDDR_PE_TRRD_CNT LPDDR tRRD clock count
 * 
 * \ref LPDDR_PE_EN_256M_DEV_SIZE Enable 256 Mbit device
 * 
 */
#define XS1_SSWITCH_LPDDR_PROTOCOL_ENGINE_CONF_1_NUM 0xc021
/**
 * SSWITCH_LPDDR_PROTOCOL_ENGINE_STATUS system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 */
#define XS1_SSWITCH_LPDDR_PROTOCOL_ENGINE_STATUS_NUM 0xc022
/**
 * SSWITCH_PADCTRL_CLK system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the
 *       PAD properties for the CLK and CLK_N pins
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_CLK_NUM 0xd000
/**
 * SSWITCH_PADCTRL_CKE system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the
 *       PAD properties for the CKE pin
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_CKE_NUM 0xd001
/**
 * SSWITCH_PADCTRL_CS_N system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the
 *       PAD properties for the CS_N pin
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_CS_N_NUM 0xd002
/**
 * SSWITCH_PADCTRL_WE_N system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the PAD properties for the WE_N pin
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_WE_N_NUM 0xd003
/**
 * SSWITCH_PADCTRL_CAS_N system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the PAD properties for the CAS_N pin
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_CAS_N_NUM 0xd004
/**
 * SSWITCH_PADCTRL_RAS_N system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the PAD properties for the RAS_N pin
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_RAS_N_NUM 0xd005
/**
 * SSWITCH_PADCTRL_ADDR system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the
 *       PAD properties for the A0-A13 pins
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_ADDR_NUM 0xd006
/**
 * SSWITCH_PADCTRL_BA system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the
 *       PAD properties for the BA0 and BA1 pins
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_BA_NUM 0xd007
/**
 * SSWITCH_PADCTRL_DQ system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the
 *       PAD properties for the DQ0-DQ15 pins
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_DQ_NUM 0xd008
/**
 * SSWITCH_PADCTRL_DQS system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the
 *       PAD properties for the UDQS and LDQS pins
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_DQS_NUM 0xd009
/**
 * SSWITCH_PADCTRL_DM system switch register number.
 * Use read_sswitch_reg() and write_sswitch_reg() to access.
 * 
 * When LPDDR is enabled, this register controls the
 *       PAD properties for the UDM and LDM pins
 * 
 * Sub-Fields:
 * 
 * \ref PADCTRL_RECEIVER_ENABLE Set to 1 to enable the input receiver
 * 
 * \ref PADCTRL_PULL Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 * 
 * \ref PADCTRL_DRIVE_STRENGTH Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 * 
 * \ref PADCTRL_SCHMITT_TRIGGER_ENABLE Set to 1 to enable the schmitt trigger
 * 
 * \ref PADCTRL_SLEW_RATE_CONTROL Set to 1 to enable slew-rate control
 * 
 */
#define XS1_SSWITCH_PADCTRL_DM_NUM 0xd00a
/// @}
/**
 * \defgroup xs3aRegisterBitfields xs3a Register Bitfields
 * @{
 */
/**
 * \name VSR_HEADROOM
 * \anchor VSR_HEADROOM
 * Max headroom seen on VST
 */
///@{
#define XS1_VSR_HEADROOM_SHIFT 0x0
#define XS1_VSR_HEADROOM_SIZE 0x5
#define XS1_VSR_HEADROOM_MASK (((1 << XS1_VSR_HEADROOM_SIZE) - 1) << XS1_VSR_HEADROOM_SHIFT)
/**
 * Extract the VSR_HEADROOM bitfield from a packed word x and return it.
 */
#define XS1_VSR_HEADROOM(x) (((x) & XS1_VSR_HEADROOM_MASK) >> XS1_VSR_HEADROOM_SHIFT)
/**
 * Pack the value (v) of the VSR_HEADROOM bitfield into a packed word x and return the packed field.
 */
#define XS1_VSR_HEADROOM_SET(x, v) (((x) & ~XS1_VSR_HEADROOM_MASK) | (((v) << XS1_VSR_HEADROOM_SHIFT) & XS1_VSR_HEADROOM_MASK))
///@}
/**
 * \name VSR_SHIFT
 * \anchor VSR_SHIFT
 * Shift none/left/right on VLBUT
 */
///@{
#define XS1_VSR_SHIFT_SHIFT 0x6
#define XS1_VSR_SHIFT_SIZE 0x2
#define XS1_VSR_SHIFT_MASK (((1 << XS1_VSR_SHIFT_SIZE) - 1) << XS1_VSR_SHIFT_SHIFT)
/**
 * Extract the VSR_SHIFT bitfield from a packed word x and return it.
 */
#define XS1_VSR_SHIFT(x) (((x) & XS1_VSR_SHIFT_MASK) >> XS1_VSR_SHIFT_SHIFT)
/**
 * Pack the value (v) of the VSR_SHIFT bitfield into a packed word x and return the packed field.
 */
#define XS1_VSR_SHIFT_SET(x, v) (((x) & ~XS1_VSR_SHIFT_MASK) | (((v) << XS1_VSR_SHIFT_SHIFT) & XS1_VSR_SHIFT_MASK))
///@}
/**
 * \name VSR_TYPE
 * \anchor VSR_TYPE
 * Data type of VC, VD, RC
 */
///@{
#define XS1_VSR_TYPE_SHIFT 0x8
#define XS1_VSR_TYPE_SIZE 0x4
#define XS1_VSR_TYPE_MASK (((1 << XS1_VSR_TYPE_SIZE) - 1) << XS1_VSR_TYPE_SHIFT)
/**
 * Extract the VSR_TYPE bitfield from a packed word x and return it.
 */
#define XS1_VSR_TYPE(x) (((x) & XS1_VSR_TYPE_MASK) >> XS1_VSR_TYPE_SHIFT)
/**
 * Pack the value (v) of the VSR_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_VSR_TYPE_SET(x, v) (((x) & ~XS1_VSR_TYPE_MASK) | (((v) << XS1_VSR_TYPE_SHIFT) & XS1_VSR_TYPE_MASK))
///@}
/**
 * \name VSR_LENGTH
 * \anchor VSR_LENGTH
 * Log2(convolution length)
 */
///@{
#define XS1_VSR_LENGTH_SHIFT 0xc
#define XS1_VSR_LENGTH_SIZE 0x4
#define XS1_VSR_LENGTH_MASK (((1 << XS1_VSR_LENGTH_SIZE) - 1) << XS1_VSR_LENGTH_SHIFT)
/**
 * Extract the VSR_LENGTH bitfield from a packed word x and return it.
 */
#define XS1_VSR_LENGTH(x) (((x) & XS1_VSR_LENGTH_MASK) >> XS1_VSR_LENGTH_SHIFT)
/**
 * Pack the value (v) of the VSR_LENGTH bitfield into a packed word x and return the packed field.
 */
#define XS1_VSR_LENGTH_SET(x, v) (((x) & ~XS1_VSR_LENGTH_MASK) | (((v) << XS1_VSR_LENGTH_SHIFT) & XS1_VSR_LENGTH_MASK))
///@}
/**
 * \name SR_EEBLE
 * \anchor SR_EEBLE
 * 1 when events are enabled for the thread.
 */
///@{
#define XS1_SR_EEBLE_SHIFT 0x0
#define XS1_SR_EEBLE_SIZE 0x1
#define XS1_SR_EEBLE_MASK (((1 << XS1_SR_EEBLE_SIZE) - 1) << XS1_SR_EEBLE_SHIFT)
/**
 * Extract the SR_EEBLE bitfield from a packed word x and return it.
 */
#define XS1_SR_EEBLE(x) (((x) & XS1_SR_EEBLE_MASK) >> XS1_SR_EEBLE_SHIFT)
/**
 * Pack the value (v) of the SR_EEBLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_EEBLE_SET(x, v) (((x) & ~XS1_SR_EEBLE_MASK) | (((v) << XS1_SR_EEBLE_SHIFT) & XS1_SR_EEBLE_MASK))
///@}
/**
 * \name SR_IEBLE
 * \anchor SR_IEBLE
 * 1 when interrupts are enabled for the thread.
 */
///@{
#define XS1_SR_IEBLE_SHIFT 0x1
#define XS1_SR_IEBLE_SIZE 0x1
#define XS1_SR_IEBLE_MASK (((1 << XS1_SR_IEBLE_SIZE) - 1) << XS1_SR_IEBLE_SHIFT)
/**
 * Extract the SR_IEBLE bitfield from a packed word x and return it.
 */
#define XS1_SR_IEBLE(x) (((x) & XS1_SR_IEBLE_MASK) >> XS1_SR_IEBLE_SHIFT)
/**
 * Pack the value (v) of the SR_IEBLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_IEBLE_SET(x, v) (((x) & ~XS1_SR_IEBLE_MASK) | (((v) << XS1_SR_IEBLE_SHIFT) & XS1_SR_IEBLE_MASK))
///@}
/**
 * \name SR_INENB
 * \anchor SR_INENB
 * 1 when in an event enabling sequence.
 */
///@{
#define XS1_SR_INENB_SHIFT 0x2
#define XS1_SR_INENB_SIZE 0x1
#define XS1_SR_INENB_MASK (((1 << XS1_SR_INENB_SIZE) - 1) << XS1_SR_INENB_SHIFT)
/**
 * Extract the SR_INENB bitfield from a packed word x and return it.
 */
#define XS1_SR_INENB(x) (((x) & XS1_SR_INENB_MASK) >> XS1_SR_INENB_SHIFT)
/**
 * Pack the value (v) of the SR_INENB bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_INENB_SET(x, v) (((x) & ~XS1_SR_INENB_MASK) | (((v) << XS1_SR_INENB_SHIFT) & XS1_SR_INENB_MASK))
///@}
/**
 * \name SR_ININT
 * \anchor SR_ININT
 * 1 when in an interrupt handler.
 */
///@{
#define XS1_SR_ININT_SHIFT 0x3
#define XS1_SR_ININT_SIZE 0x1
#define XS1_SR_ININT_MASK (((1 << XS1_SR_ININT_SIZE) - 1) << XS1_SR_ININT_SHIFT)
/**
 * Extract the SR_ININT bitfield from a packed word x and return it.
 */
#define XS1_SR_ININT(x) (((x) & XS1_SR_ININT_MASK) >> XS1_SR_ININT_SHIFT)
/**
 * Pack the value (v) of the SR_ININT bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_ININT_SET(x, v) (((x) & ~XS1_SR_ININT_MASK) | (((v) << XS1_SR_ININT_SHIFT) & XS1_SR_ININT_MASK))
///@}
/**
 * \name SR_INK
 * \anchor SR_INK
 * 1 when in kernel mode.
 */
///@{
#define XS1_SR_INK_SHIFT 0x4
#define XS1_SR_INK_SIZE 0x1
#define XS1_SR_INK_MASK (((1 << XS1_SR_INK_SIZE) - 1) << XS1_SR_INK_SHIFT)
/**
 * Extract the SR_INK bitfield from a packed word x and return it.
 */
#define XS1_SR_INK(x) (((x) & XS1_SR_INK_MASK) >> XS1_SR_INK_SHIFT)
/**
 * Pack the value (v) of the SR_INK bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_INK_SET(x, v) (((x) & ~XS1_SR_INK_MASK) | (((v) << XS1_SR_INK_SHIFT) & XS1_SR_INK_MASK))
///@}
/**
 * \name SR_SINK
 * \anchor SR_SINK
 * Copy of the SSR INK bit.
 */
///@{
#define XS1_SR_SINK_SHIFT 0x5
#define XS1_SR_SINK_SIZE 0x1
#define XS1_SR_SINK_MASK (((1 << XS1_SR_SINK_SIZE) - 1) << XS1_SR_SINK_SHIFT)
/**
 * Extract the SR_SINK bitfield from a packed word x and return it.
 */
#define XS1_SR_SINK(x) (((x) & XS1_SR_SINK_MASK) >> XS1_SR_SINK_SHIFT)
/**
 * Pack the value (v) of the SR_SINK bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_SINK_SET(x, v) (((x) & ~XS1_SR_SINK_MASK) | (((v) << XS1_SR_SINK_SHIFT) & XS1_SR_SINK_MASK))
///@}
/**
 * \name SR_WAITING
 * \anchor SR_WAITING
 * 1 when the thread is paused waiting for events, a lock or another resource.
 */
///@{
#define XS1_SR_WAITING_SHIFT 0x6
#define XS1_SR_WAITING_SIZE 0x1
#define XS1_SR_WAITING_MASK (((1 << XS1_SR_WAITING_SIZE) - 1) << XS1_SR_WAITING_SHIFT)
/**
 * Extract the SR_WAITING bitfield from a packed word x and return it.
 */
#define XS1_SR_WAITING(x) (((x) & XS1_SR_WAITING_MASK) >> XS1_SR_WAITING_SHIFT)
/**
 * Pack the value (v) of the SR_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_WAITING_SET(x, v) (((x) & ~XS1_SR_WAITING_MASK) | (((v) << XS1_SR_WAITING_SHIFT) & XS1_SR_WAITING_MASK))
///@}
/**
 * \name SR_FAST
 * \anchor SR_FAST
 * 1 when the thread is in fast mode and will continually issue.
 */
///@{
#define XS1_SR_FAST_SHIFT 0x7
#define XS1_SR_FAST_SIZE 0x1
#define XS1_SR_FAST_MASK (((1 << XS1_SR_FAST_SIZE) - 1) << XS1_SR_FAST_SHIFT)
/**
 * Extract the SR_FAST bitfield from a packed word x and return it.
 */
#define XS1_SR_FAST(x) (((x) & XS1_SR_FAST_MASK) >> XS1_SR_FAST_SHIFT)
/**
 * Pack the value (v) of the SR_FAST bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_FAST_SET(x, v) (((x) & ~XS1_SR_FAST_MASK) | (((v) << XS1_SR_FAST_SHIFT) & XS1_SR_FAST_MASK))
///@}
/**
 * \name SR_DI
 * \anchor SR_DI
 * 1 when in dual issue mode.
 */
///@{
#define XS1_SR_DI_SHIFT 0x8
#define XS1_SR_DI_SIZE 0x1
#define XS1_SR_DI_MASK (((1 << XS1_SR_DI_SIZE) - 1) << XS1_SR_DI_SHIFT)
/**
 * Extract the SR_DI bitfield from a packed word x and return it.
 */
#define XS1_SR_DI(x) (((x) & XS1_SR_DI_MASK) >> XS1_SR_DI_SHIFT)
/**
 * Pack the value (v) of the SR_DI bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_DI_SET(x, v) (((x) & ~XS1_SR_DI_MASK) | (((v) << XS1_SR_DI_SHIFT) & XS1_SR_DI_MASK))
///@}
/**
 * \name SR_KEDI
 * \anchor SR_KEDI
 * 1 if, on kernel entry, the thread will switch to dual issue.
 */
///@{
#define XS1_SR_KEDI_SHIFT 0x9
#define XS1_SR_KEDI_SIZE 0x1
#define XS1_SR_KEDI_MASK (((1 << XS1_SR_KEDI_SIZE) - 1) << XS1_SR_KEDI_SHIFT)
/**
 * Extract the SR_KEDI bitfield from a packed word x and return it.
 */
#define XS1_SR_KEDI(x) (((x) & XS1_SR_KEDI_MASK) >> XS1_SR_KEDI_SHIFT)
/**
 * Pack the value (v) of the SR_KEDI bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_KEDI_SET(x, v) (((x) & ~XS1_SR_KEDI_MASK) | (((v) << XS1_SR_KEDI_SHIFT) & XS1_SR_KEDI_MASK))
///@}
/**
 * \name SR_QUEUE
 * \anchor SR_QUEUE
 * 1 if in high priority mode
 */
///@{
#define XS1_SR_QUEUE_SHIFT 0xa
#define XS1_SR_QUEUE_SIZE 0x1
#define XS1_SR_QUEUE_MASK (((1 << XS1_SR_QUEUE_SIZE) - 1) << XS1_SR_QUEUE_SHIFT)
/**
 * Extract the SR_QUEUE bitfield from a packed word x and return it.
 */
#define XS1_SR_QUEUE(x) (((x) & XS1_SR_QUEUE_MASK) >> XS1_SR_QUEUE_SHIFT)
/**
 * Pack the value (v) of the SR_QUEUE bitfield into a packed word x and return the packed field.
 */
#define XS1_SR_QUEUE_SET(x, v) (((x) & ~XS1_SR_QUEUE_MASK) | (((v) << XS1_SR_QUEUE_SHIFT) & XS1_SR_QUEUE_MASK))
///@}
/**
 * \name ID_ID
 * \anchor ID_ID
 * Number of the thread.
 */
///@{
#define XS1_ID_ID_SHIFT 0x0
#define XS1_ID_ID_SIZE 0x6
#define XS1_ID_ID_MASK (((1 << XS1_ID_ID_SIZE) - 1) << XS1_ID_ID_SHIFT)
/**
 * Extract the ID_ID bitfield from a packed word x and return it.
 */
#define XS1_ID_ID(x) (((x) & XS1_ID_ID_MASK) >> XS1_ID_ID_SHIFT)
/**
 * Pack the value (v) of the ID_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_ID_ID_SET(x, v) (((x) & ~XS1_ID_ID_MASK) | (((v) << XS1_ID_ID_SHIFT) & XS1_ID_ID_MASK))
///@}
/**
 * \name EXCEPTION_TYPE
 * \anchor EXCEPTION_TYPE
 * The exception type.
 */
///@{
#define XS1_EXCEPTION_TYPE_SHIFT 0x0
#define XS1_EXCEPTION_TYPE_SIZE 0x5
#define XS1_EXCEPTION_TYPE_MASK (((1 << XS1_EXCEPTION_TYPE_SIZE) - 1) << XS1_EXCEPTION_TYPE_SHIFT)
/**
 * Extract the EXCEPTION_TYPE bitfield from a packed word x and return it.
 */
#define XS1_EXCEPTION_TYPE(x) (((x) & XS1_EXCEPTION_TYPE_MASK) >> XS1_EXCEPTION_TYPE_SHIFT)
/**
 * Pack the value (v) of the EXCEPTION_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_EXCEPTION_TYPE_SET(x, v) (((x) & ~XS1_EXCEPTION_TYPE_MASK) | (((v) << XS1_EXCEPTION_TYPE_SHIFT) & XS1_EXCEPTION_TYPE_MASK))
///@}
/**
 * \name DBG_T_NUM_NUM
 * \anchor DBG_T_NUM_NUM
 * Thread number to be read
 */
///@{
#define XS1_DBG_T_NUM_NUM_SHIFT 0x0
#define XS1_DBG_T_NUM_NUM_SIZE 0x8
#define XS1_DBG_T_NUM_NUM_MASK (((1 << XS1_DBG_T_NUM_NUM_SIZE) - 1) << XS1_DBG_T_NUM_NUM_SHIFT)
/**
 * Extract the DBG_T_NUM_NUM bitfield from a packed word x and return it.
 */
#define XS1_DBG_T_NUM_NUM(x) (((x) & XS1_DBG_T_NUM_NUM_MASK) >> XS1_DBG_T_NUM_NUM_SHIFT)
/**
 * Pack the value (v) of the DBG_T_NUM_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_T_NUM_NUM_SET(x, v) (((x) & ~XS1_DBG_T_NUM_NUM_MASK) | (((v) << XS1_DBG_T_NUM_NUM_SHIFT) & XS1_DBG_T_NUM_NUM_MASK))
///@}
/**
 * \name DBG_T_REG_REG
 * \anchor DBG_T_REG_REG
 * Register number to be read
 */
///@{
#define XS1_DBG_T_REG_REG_SHIFT 0x0
#define XS1_DBG_T_REG_REG_SIZE 0x5
#define XS1_DBG_T_REG_REG_MASK (((1 << XS1_DBG_T_REG_REG_SIZE) - 1) << XS1_DBG_T_REG_REG_SHIFT)
/**
 * Extract the DBG_T_REG_REG bitfield from a packed word x and return it.
 */
#define XS1_DBG_T_REG_REG(x) (((x) & XS1_DBG_T_REG_REG_MASK) >> XS1_DBG_T_REG_REG_SHIFT)
/**
 * Pack the value (v) of the DBG_T_REG_REG bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_T_REG_REG_SET(x, v) (((x) & ~XS1_DBG_T_REG_REG_MASK) | (((v) << XS1_DBG_T_REG_REG_SHIFT) & XS1_DBG_T_REG_REG_MASK))
///@}
/**
 * \name BRK_ENABLE
 * \anchor BRK_ENABLE
 * When 1 the breakpoint is enabled.
 */
///@{
#define XS1_BRK_ENABLE_SHIFT 0x0
#define XS1_BRK_ENABLE_SIZE 0x1
#define XS1_BRK_ENABLE_MASK (((1 << XS1_BRK_ENABLE_SIZE) - 1) << XS1_BRK_ENABLE_SHIFT)
/**
 * Extract the BRK_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_BRK_ENABLE(x) (((x) & XS1_BRK_ENABLE_MASK) >> XS1_BRK_ENABLE_SHIFT)
/**
 * Pack the value (v) of the BRK_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_BRK_ENABLE_SET(x, v) (((x) & ~XS1_BRK_ENABLE_MASK) | (((v) << XS1_BRK_ENABLE_SHIFT) & XS1_BRK_ENABLE_MASK))
///@}
/**
 * \name ALL_BITS
 * \anchor ALL_BITS
 * Value.
 */
///@{
#define XS1_ALL_BITS_SHIFT 0x0
#define XS1_ALL_BITS_SIZE 0x20
#define XS1_ALL_BITS_MASK (((1 << XS1_ALL_BITS_SIZE) - 1) << XS1_ALL_BITS_SHIFT)
/**
 * Extract the ALL_BITS bitfield from a packed word x and return it.
 */
#define XS1_ALL_BITS(x) (((x) & XS1_ALL_BITS_MASK) >> XS1_ALL_BITS_SHIFT)
/**
 * Pack the value (v) of the ALL_BITS bitfield into a packed word x and return the packed field.
 */
#define XS1_ALL_BITS_SET(x, v) (((x) & ~XS1_ALL_BITS_MASK) | (((v) << XS1_ALL_BITS_SHIFT) & XS1_ALL_BITS_MASK))
///@}
/**
 * \name KEP_ADDRESS_BITS
 * \anchor KEP_ADDRESS_BITS
 * KEP Address bits
 */
///@{
#define XS1_KEP_ADDRESS_BITS_SHIFT 0x7
#define XS1_KEP_ADDRESS_BITS_SIZE 0x19
#define XS1_KEP_ADDRESS_BITS_MASK (((1 << XS1_KEP_ADDRESS_BITS_SIZE) - 1) << XS1_KEP_ADDRESS_BITS_SHIFT)
/**
 * Extract the KEP_ADDRESS_BITS bitfield from a packed word x and return it.
 */
#define XS1_KEP_ADDRESS_BITS(x) (((x) & XS1_KEP_ADDRESS_BITS_MASK) >> XS1_KEP_ADDRESS_BITS_SHIFT)
/**
 * Pack the value (v) of the KEP_ADDRESS_BITS bitfield into a packed word x and return the packed field.
 */
#define XS1_KEP_ADDRESS_BITS_SET(x, v) (((x) & ~XS1_KEP_ADDRESS_BITS_MASK) | (((v) << XS1_KEP_ADDRESS_BITS_SHIFT) & XS1_KEP_ADDRESS_BITS_MASK))
///@}
/**
 * \name WORD_ADDRESS_BITS
 * \anchor WORD_ADDRESS_BITS
 * Most significant 16 bits of all addresses.
 */
///@{
#define XS1_WORD_ADDRESS_BITS_SHIFT 0x2
#define XS1_WORD_ADDRESS_BITS_SIZE 0x1e
#define XS1_WORD_ADDRESS_BITS_MASK (((1 << XS1_WORD_ADDRESS_BITS_SIZE) - 1) << XS1_WORD_ADDRESS_BITS_SHIFT)
/**
 * Extract the WORD_ADDRESS_BITS bitfield from a packed word x and return it.
 */
#define XS1_WORD_ADDRESS_BITS(x) (((x) & XS1_WORD_ADDRESS_BITS_MASK) >> XS1_WORD_ADDRESS_BITS_SHIFT)
/**
 * Pack the value (v) of the WORD_ADDRESS_BITS bitfield into a packed word x and return the packed field.
 */
#define XS1_WORD_ADDRESS_BITS_SET(x, v) (((x) & ~XS1_WORD_ADDRESS_BITS_MASK) | (((v) << XS1_WORD_ADDRESS_BITS_SHIFT) & XS1_WORD_ADDRESS_BITS_MASK))
///@}
/**
 * \name VECTOR_BASE
 * \anchor VECTOR_BASE
 * The event and interrupt vectors.
 */
///@{
#define XS1_VECTOR_BASE_SHIFT 0x13
#define XS1_VECTOR_BASE_SIZE 0xd
#define XS1_VECTOR_BASE_MASK (((1 << XS1_VECTOR_BASE_SIZE) - 1) << XS1_VECTOR_BASE_SHIFT)
/**
 * Extract the VECTOR_BASE bitfield from a packed word x and return it.
 */
#define XS1_VECTOR_BASE(x) (((x) & XS1_VECTOR_BASE_MASK) >> XS1_VECTOR_BASE_SHIFT)
/**
 * Pack the value (v) of the VECTOR_BASE bitfield into a packed word x and return the packed field.
 */
#define XS1_VECTOR_BASE_SET(x, v) (((x) & ~XS1_VECTOR_BASE_MASK) | (((v) << XS1_VECTOR_BASE_SHIFT) & XS1_VECTOR_BASE_MASK))
///@}
/**
 * \name IBRK_CONDITION
 * \anchor IBRK_CONDITION
 * When 0 break when PC == IBREAK_ADDR. When 1 = break when PC != IBREAK_ADDR.
 */
///@{
#define XS1_IBRK_CONDITION_SHIFT 0x1
#define XS1_IBRK_CONDITION_SIZE 0x1
#define XS1_IBRK_CONDITION_MASK (((1 << XS1_IBRK_CONDITION_SIZE) - 1) << XS1_IBRK_CONDITION_SHIFT)
/**
 * Extract the IBRK_CONDITION bitfield from a packed word x and return it.
 */
#define XS1_IBRK_CONDITION(x) (((x) & XS1_IBRK_CONDITION_MASK) >> XS1_IBRK_CONDITION_SHIFT)
/**
 * Pack the value (v) of the IBRK_CONDITION bitfield into a packed word x and return the packed field.
 */
#define XS1_IBRK_CONDITION_SET(x, v) (((x) & ~XS1_IBRK_CONDITION_MASK) | (((v) << XS1_IBRK_CONDITION_SHIFT) & XS1_IBRK_CONDITION_MASK))
///@}
/**
 * \name DBRK_CONDITION
 * \anchor DBRK_CONDITION
 * Determines the break condition: 0 = A AND B, 1 = A OR B.
 */
///@{
#define XS1_DBRK_CONDITION_SHIFT 0x1
#define XS1_DBRK_CONDITION_SIZE 0x1
#define XS1_DBRK_CONDITION_MASK (((1 << XS1_DBRK_CONDITION_SIZE) - 1) << XS1_DBRK_CONDITION_SHIFT)
/**
 * Extract the DBRK_CONDITION bitfield from a packed word x and return it.
 */
#define XS1_DBRK_CONDITION(x) (((x) & XS1_DBRK_CONDITION_MASK) >> XS1_DBRK_CONDITION_SHIFT)
/**
 * Pack the value (v) of the DBRK_CONDITION bitfield into a packed word x and return the packed field.
 */
#define XS1_DBRK_CONDITION_SET(x, v) (((x) & ~XS1_DBRK_CONDITION_MASK) | (((v) << XS1_DBRK_CONDITION_SHIFT) & XS1_DBRK_CONDITION_MASK))
///@}
/**
 * \name RBRK_CONDITION
 * \anchor RBRK_CONDITION
 * When 0 break when condition A is met. When 1 = break when condition B is met.
 */
///@{
#define XS1_RBRK_CONDITION_SHIFT 0x1
#define XS1_RBRK_CONDITION_SIZE 0x1
#define XS1_RBRK_CONDITION_MASK (((1 << XS1_RBRK_CONDITION_SIZE) - 1) << XS1_RBRK_CONDITION_SHIFT)
/**
 * Extract the RBRK_CONDITION bitfield from a packed word x and return it.
 */
#define XS1_RBRK_CONDITION(x) (((x) & XS1_RBRK_CONDITION_MASK) >> XS1_RBRK_CONDITION_SHIFT)
/**
 * Pack the value (v) of the RBRK_CONDITION bitfield into a packed word x and return the packed field.
 */
#define XS1_RBRK_CONDITION_SET(x, v) (((x) & ~XS1_RBRK_CONDITION_MASK) | (((v) << XS1_RBRK_CONDITION_SHIFT) & XS1_RBRK_CONDITION_MASK))
///@}
/**
 * \name BRK_LOAD
 * \anchor BRK_LOAD
 * When 1 the breakpoints will be be triggered on loads.
 */
///@{
#define XS1_BRK_LOAD_SHIFT 0x2
#define XS1_BRK_LOAD_SIZE 0x1
#define XS1_BRK_LOAD_MASK (((1 << XS1_BRK_LOAD_SIZE) - 1) << XS1_BRK_LOAD_SHIFT)
/**
 * Extract the BRK_LOAD bitfield from a packed word x and return it.
 */
#define XS1_BRK_LOAD(x) (((x) & XS1_BRK_LOAD_MASK) >> XS1_BRK_LOAD_SHIFT)
/**
 * Pack the value (v) of the BRK_LOAD bitfield into a packed word x and return the packed field.
 */
#define XS1_BRK_LOAD_SET(x, v) (((x) & ~XS1_BRK_LOAD_MASK) | (((v) << XS1_BRK_LOAD_SHIFT) & XS1_BRK_LOAD_MASK))
///@}
/**
 * \name BRK_THREADS
 * \anchor BRK_THREADS
 * A bit for each thread in the machine allowing the breakpoint to be enabled individually for each thread.
 */
///@{
#define XS1_BRK_THREADS_SHIFT 0x10
#define XS1_BRK_THREADS_SIZE 0x8
#define XS1_BRK_THREADS_MASK (((1 << XS1_BRK_THREADS_SIZE) - 1) << XS1_BRK_THREADS_SHIFT)
/**
 * Extract the BRK_THREADS bitfield from a packed word x and return it.
 */
#define XS1_BRK_THREADS(x) (((x) & XS1_BRK_THREADS_MASK) >> XS1_BRK_THREADS_SHIFT)
/**
 * Pack the value (v) of the BRK_THREADS bitfield into a packed word x and return the packed field.
 */
#define XS1_BRK_THREADS_SET(x, v) (((x) & ~XS1_BRK_THREADS_MASK) | (((v) << XS1_BRK_THREADS_SHIFT) & XS1_BRK_THREADS_MASK))
///@}
/**
 * \name DBG_TYPE_CAUSE
 * \anchor DBG_TYPE_CAUSE
 * Indicates the cause of the debug interrupt
 * 
 * 1: Host initiated a debug interrupt through JTAG
 * 
 * 2: Program executed a DCALL instruction
 * 
 * 3: Instruction breakpoint
 * 
 * 4: Data watch point
 * 
 * 5: Resource watch point
 */
///@{
#define XS1_DBG_TYPE_CAUSE_SHIFT 0x0
#define XS1_DBG_TYPE_CAUSE_SIZE 0x3
#define XS1_DBG_TYPE_CAUSE_MASK (((1 << XS1_DBG_TYPE_CAUSE_SIZE) - 1) << XS1_DBG_TYPE_CAUSE_SHIFT)
/**
 * Extract the DBG_TYPE_CAUSE bitfield from a packed word x and return it.
 */
#define XS1_DBG_TYPE_CAUSE(x) (((x) & XS1_DBG_TYPE_CAUSE_MASK) >> XS1_DBG_TYPE_CAUSE_SHIFT)
/**
 * Pack the value (v) of the DBG_TYPE_CAUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_TYPE_CAUSE_SET(x, v) (((x) & ~XS1_DBG_TYPE_CAUSE_MASK) | (((v) << XS1_DBG_TYPE_CAUSE_SHIFT) & XS1_DBG_TYPE_CAUSE_MASK))
///@}
/**
 * \name DBG_TYPE_T_NUM
 * \anchor DBG_TYPE_T_NUM
 * Number of thread which caused the debug interrupt (always 0 in the case of =HOST=).
 */
///@{
#define XS1_DBG_TYPE_T_NUM_SHIFT 0x8
#define XS1_DBG_TYPE_T_NUM_SIZE 0x8
#define XS1_DBG_TYPE_T_NUM_MASK (((1 << XS1_DBG_TYPE_T_NUM_SIZE) - 1) << XS1_DBG_TYPE_T_NUM_SHIFT)
/**
 * Extract the DBG_TYPE_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_DBG_TYPE_T_NUM(x) (((x) & XS1_DBG_TYPE_T_NUM_MASK) >> XS1_DBG_TYPE_T_NUM_SHIFT)
/**
 * Pack the value (v) of the DBG_TYPE_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_TYPE_T_NUM_SET(x, v) (((x) & ~XS1_DBG_TYPE_T_NUM_MASK) | (((v) << XS1_DBG_TYPE_T_NUM_SHIFT) & XS1_DBG_TYPE_T_NUM_MASK))
///@}
/**
 * \name DBG_TYPE_HW_NUM
 * \anchor DBG_TYPE_HW_NUM
 * Number of the hardware breakpoint/watchpoint which caused the interrupt (always 0 for =HOST= and =DCALL=). If multiple breakpoints/watchpoints trigger at once, the lowest number is taken.
 */
///@{
#define XS1_DBG_TYPE_HW_NUM_SHIFT 0x10
#define XS1_DBG_TYPE_HW_NUM_SIZE 0x2
#define XS1_DBG_TYPE_HW_NUM_MASK (((1 << XS1_DBG_TYPE_HW_NUM_SIZE) - 1) << XS1_DBG_TYPE_HW_NUM_SHIFT)
/**
 * Extract the DBG_TYPE_HW_NUM bitfield from a packed word x and return it.
 */
#define XS1_DBG_TYPE_HW_NUM(x) (((x) & XS1_DBG_TYPE_HW_NUM_MASK) >> XS1_DBG_TYPE_HW_NUM_SHIFT)
/**
 * Pack the value (v) of the DBG_TYPE_HW_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_TYPE_HW_NUM_SET(x, v) (((x) & ~XS1_DBG_TYPE_HW_NUM_MASK) | (((v) << XS1_DBG_TYPE_HW_NUM_SHIFT) & XS1_DBG_TYPE_HW_NUM_MASK))
///@}
/**
 * \name DBG_RUN_CTRL_STOP
 * \anchor DBG_RUN_CTRL_STOP
 * 1-hot vector defining which threads are stopped when not in debug mode. Every bit which is set prevents the respective thread from running.
 */
///@{
#define XS1_DBG_RUN_CTRL_STOP_SHIFT 0x0
#define XS1_DBG_RUN_CTRL_STOP_SIZE 0x8
#define XS1_DBG_RUN_CTRL_STOP_MASK (((1 << XS1_DBG_RUN_CTRL_STOP_SIZE) - 1) << XS1_DBG_RUN_CTRL_STOP_SHIFT)
/**
 * Extract the DBG_RUN_CTRL_STOP bitfield from a packed word x and return it.
 */
#define XS1_DBG_RUN_CTRL_STOP(x) (((x) & XS1_DBG_RUN_CTRL_STOP_MASK) >> XS1_DBG_RUN_CTRL_STOP_SHIFT)
/**
 * Pack the value (v) of the DBG_RUN_CTRL_STOP bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_RUN_CTRL_STOP_SET(x, v) (((x) & ~XS1_DBG_RUN_CTRL_STOP_MASK) | (((v) << XS1_DBG_RUN_CTRL_STOP_SHIFT) & XS1_DBG_RUN_CTRL_STOP_MASK))
///@}
/**
 * \name XCORE_CTRL0_EXTMEM_ENABLE
 * \anchor XCORE_CTRL0_EXTMEM_ENABLE
 * Enable External memory interface
 */
///@{
#define XS1_XCORE_CTRL0_EXTMEM_ENABLE_SHIFT 0x0
#define XS1_XCORE_CTRL0_EXTMEM_ENABLE_SIZE 0x1
#define XS1_XCORE_CTRL0_EXTMEM_ENABLE_MASK (((1 << XS1_XCORE_CTRL0_EXTMEM_ENABLE_SIZE) - 1) << XS1_XCORE_CTRL0_EXTMEM_ENABLE_SHIFT)
/**
 * Extract the XCORE_CTRL0_EXTMEM_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_EXTMEM_ENABLE(x) (((x) & XS1_XCORE_CTRL0_EXTMEM_ENABLE_MASK) >> XS1_XCORE_CTRL0_EXTMEM_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_EXTMEM_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_EXTMEM_ENABLE_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_EXTMEM_ENABLE_MASK) | (((v) << XS1_XCORE_CTRL0_EXTMEM_ENABLE_SHIFT) & XS1_XCORE_CTRL0_EXTMEM_ENABLE_MASK))
///@}
/**
 * \name XCORE_CTRL0_USB_ENABLE
 * \anchor XCORE_CTRL0_USB_ENABLE
 * Enable the USB hardware support module
 */
///@{
#define XS1_XCORE_CTRL0_USB_ENABLE_SHIFT 0x1
#define XS1_XCORE_CTRL0_USB_ENABLE_SIZE 0x1
#define XS1_XCORE_CTRL0_USB_ENABLE_MASK (((1 << XS1_XCORE_CTRL0_USB_ENABLE_SIZE) - 1) << XS1_XCORE_CTRL0_USB_ENABLE_SHIFT)
/**
 * Extract the XCORE_CTRL0_USB_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_USB_ENABLE(x) (((x) & XS1_XCORE_CTRL0_USB_ENABLE_MASK) >> XS1_XCORE_CTRL0_USB_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_USB_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_USB_ENABLE_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_USB_ENABLE_MASK) | (((v) << XS1_XCORE_CTRL0_USB_ENABLE_SHIFT) & XS1_XCORE_CTRL0_USB_ENABLE_MASK))
///@}
/**
 * \name XCORE_CTRL0_CLK_DIVIDER_EN
 * \anchor XCORE_CTRL0_CLK_DIVIDER_EN
 * Enable the clock divider.  This divides the output of the PLL to facilitate one of the low power modes.
 */
///@{
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SHIFT 0x4
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SIZE 0x1
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN_MASK (((1 << XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SIZE) - 1) << XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SHIFT)
/**
 * Extract the XCORE_CTRL0_CLK_DIVIDER_EN bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN(x) (((x) & XS1_XCORE_CTRL0_CLK_DIVIDER_EN_MASK) >> XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_CLK_DIVIDER_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_CLK_DIVIDER_EN_MASK) | (((v) << XS1_XCORE_CTRL0_CLK_DIVIDER_EN_SHIFT) & XS1_XCORE_CTRL0_CLK_DIVIDER_EN_MASK))
///@}
/**
 * \name XCORE_CTRL0_CLK_DIVIDER_DYN
 * \anchor XCORE_CTRL0_CLK_DIVIDER_DYN
 * Select the dynamic mode (1) for the clock divider when the clock divider is enabled.  In dynamic mode the clock divider is only activated when all active threads are paused.  In static mode the clock divider is always enabled.
 */
///@{
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SHIFT 0x5
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SIZE 0x1
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_MASK (((1 << XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SIZE) - 1) << XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SHIFT)
/**
 * Extract the XCORE_CTRL0_CLK_DIVIDER_DYN bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN(x) (((x) & XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_MASK) >> XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_CLK_DIVIDER_DYN bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_MASK) | (((v) << XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_SHIFT) & XS1_XCORE_CTRL0_CLK_DIVIDER_DYN_MASK))
///@}
/**
 * \name XCORE_CTRL0_MIPI_ENABLE
 * \anchor XCORE_CTRL0_MIPI_ENABLE
 * Enable MIPI interface periph ports
 */
///@{
#define XS1_XCORE_CTRL0_MIPI_ENABLE_SHIFT 0x8
#define XS1_XCORE_CTRL0_MIPI_ENABLE_SIZE 0x1
#define XS1_XCORE_CTRL0_MIPI_ENABLE_MASK (((1 << XS1_XCORE_CTRL0_MIPI_ENABLE_SIZE) - 1) << XS1_XCORE_CTRL0_MIPI_ENABLE_SHIFT)
/**
 * Extract the XCORE_CTRL0_MIPI_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_MIPI_ENABLE(x) (((x) & XS1_XCORE_CTRL0_MIPI_ENABLE_MASK) >> XS1_XCORE_CTRL0_MIPI_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_MIPI_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_MIPI_ENABLE_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_MIPI_ENABLE_MASK) | (((v) << XS1_XCORE_CTRL0_MIPI_ENABLE_SHIFT) & XS1_XCORE_CTRL0_MIPI_ENABLE_MASK))
///@}
/**
 * \name XCORE_CTRL0_MEMSLEEP_ENABLE
 * \anchor XCORE_CTRL0_MEMSLEEP_ENABLE
 * Enable memory auto-sleep feature
 */
///@{
#define XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_SHIFT 0x9
#define XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_SIZE 0x1
#define XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_MASK (((1 << XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_SIZE) - 1) << XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_SHIFT)
/**
 * Extract the XCORE_CTRL0_MEMSLEEP_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_MEMSLEEP_ENABLE(x) (((x) & XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_MASK) >> XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_MEMSLEEP_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_MASK) | (((v) << XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_SHIFT) & XS1_XCORE_CTRL0_MEMSLEEP_ENABLE_MASK))
///@}
/**
 * \name XCORE_CTRL0_RAMSHUTDOWN
 * \anchor XCORE_CTRL0_RAMSHUTDOWN
 * Disable RAMs to save power (contents will be lost)
 */
///@{
#define XS1_XCORE_CTRL0_RAMSHUTDOWN_SHIFT 0xa
#define XS1_XCORE_CTRL0_RAMSHUTDOWN_SIZE 0x1
#define XS1_XCORE_CTRL0_RAMSHUTDOWN_MASK (((1 << XS1_XCORE_CTRL0_RAMSHUTDOWN_SIZE) - 1) << XS1_XCORE_CTRL0_RAMSHUTDOWN_SHIFT)
/**
 * Extract the XCORE_CTRL0_RAMSHUTDOWN bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_RAMSHUTDOWN(x) (((x) & XS1_XCORE_CTRL0_RAMSHUTDOWN_MASK) >> XS1_XCORE_CTRL0_RAMSHUTDOWN_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_RAMSHUTDOWN bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_RAMSHUTDOWN_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_RAMSHUTDOWN_MASK) | (((v) << XS1_XCORE_CTRL0_RAMSHUTDOWN_SHIFT) & XS1_XCORE_CTRL0_RAMSHUTDOWN_MASK))
///@}
/**
 * \name XCORE_CTRL0_EXTMEM_DEVICE_SIZE
 * \anchor XCORE_CTRL0_EXTMEM_DEVICE_SIZE
 * Specify size of a connected LPDDR device (options are: 128,256,512Mbits, 1Gbit),
 */
///@{
#define XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_SHIFT 0xb
#define XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_SIZE 0x2
#define XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_MASK (((1 << XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_SIZE) - 1) << XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_SHIFT)
/**
 * Extract the XCORE_CTRL0_EXTMEM_DEVICE_SIZE bitfield from a packed word x and return it.
 */
#define XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE(x) (((x) & XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_MASK) >> XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_SHIFT)
/**
 * Pack the value (v) of the XCORE_CTRL0_EXTMEM_DEVICE_SIZE bitfield into a packed word x and return the packed field.
 */
#define XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_SET(x, v) (((x) & ~XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_MASK) | (((v) << XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_SHIFT) & XS1_XCORE_CTRL0_EXTMEM_DEVICE_SIZE_MASK))
///@}
/**
 * \name BOOT_CONFIG_PLL_MODE_PINS
 * \anchor BOOT_CONFIG_PLL_MODE_PINS
 * The boot PLL mode pin value.
 */
///@{
#define XS1_BOOT_CONFIG_PLL_MODE_PINS_SHIFT 0x0
#define XS1_BOOT_CONFIG_PLL_MODE_PINS_SIZE 0x2
#define XS1_BOOT_CONFIG_PLL_MODE_PINS_MASK (((1 << XS1_BOOT_CONFIG_PLL_MODE_PINS_SIZE) - 1) << XS1_BOOT_CONFIG_PLL_MODE_PINS_SHIFT)
/**
 * Extract the BOOT_CONFIG_PLL_MODE_PINS bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_PLL_MODE_PINS(x) (((x) & XS1_BOOT_CONFIG_PLL_MODE_PINS_MASK) >> XS1_BOOT_CONFIG_PLL_MODE_PINS_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_PLL_MODE_PINS bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_PLL_MODE_PINS_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_PLL_MODE_PINS_MASK) | (((v) << XS1_BOOT_CONFIG_PLL_MODE_PINS_SHIFT) & XS1_BOOT_CONFIG_PLL_MODE_PINS_MASK))
///@}
/**
 * \name BOOT_CONFIG_BOOT_FROM_JTAG
 * \anchor BOOT_CONFIG_BOOT_FROM_JTAG
 * Boot ROM boots from JTAG 
 */
///@{
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SHIFT 0x2
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SIZE 0x1
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG_MASK (((1 << XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SIZE) - 1) << XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SHIFT)
/**
 * Extract the BOOT_CONFIG_BOOT_FROM_JTAG bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG(x) (((x) & XS1_BOOT_CONFIG_BOOT_FROM_JTAG_MASK) >> XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_BOOT_FROM_JTAG bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_BOOT_FROM_JTAG_MASK) | (((v) << XS1_BOOT_CONFIG_BOOT_FROM_JTAG_SHIFT) & XS1_BOOT_CONFIG_BOOT_FROM_JTAG_MASK))
///@}
/**
 * \name BOOT_CONFIG_BOOT_FROM_RAM
 * \anchor BOOT_CONFIG_BOOT_FROM_RAM
 * Boot ROM boots from RAM 
 */
///@{
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM_SHIFT 0x3
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM_SIZE 0x1
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM_MASK (((1 << XS1_BOOT_CONFIG_BOOT_FROM_RAM_SIZE) - 1) << XS1_BOOT_CONFIG_BOOT_FROM_RAM_SHIFT)
/**
 * Extract the BOOT_CONFIG_BOOT_FROM_RAM bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM(x) (((x) & XS1_BOOT_CONFIG_BOOT_FROM_RAM_MASK) >> XS1_BOOT_CONFIG_BOOT_FROM_RAM_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_BOOT_FROM_RAM bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_BOOT_FROM_RAM_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_BOOT_FROM_RAM_MASK) | (((v) << XS1_BOOT_CONFIG_BOOT_FROM_RAM_SHIFT) & XS1_BOOT_CONFIG_BOOT_FROM_RAM_MASK))
///@}
/**
 * \name BOOT_CONFIG_DISABLE_OTP_POLL
 * \anchor BOOT_CONFIG_DISABLE_OTP_POLL
 * Cause the ROM to not poll the OTP for correct read levels
 */
///@{
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SHIFT 0x4
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SIZE 0x1
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL_MASK (((1 << XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SIZE) - 1) << XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SHIFT)
/**
 * Extract the BOOT_CONFIG_DISABLE_OTP_POLL bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL(x) (((x) & XS1_BOOT_CONFIG_DISABLE_OTP_POLL_MASK) >> XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_DISABLE_OTP_POLL bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_DISABLE_OTP_POLL_MASK) | (((v) << XS1_BOOT_CONFIG_DISABLE_OTP_POLL_SHIFT) & XS1_BOOT_CONFIG_DISABLE_OTP_POLL_MASK))
///@}
/**
 * \name BOOT_CONFIG_CORE1_POWER_DOWN_N
 * \anchor BOOT_CONFIG_CORE1_POWER_DOWN_N
 * Indicates if core1 has been powered off 
 */
///@{
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SHIFT 0x5
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SIZE 0x1
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_MASK (((1 << XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SIZE) - 1) << XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SHIFT)
/**
 * Extract the BOOT_CONFIG_CORE1_POWER_DOWN_N bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N(x) (((x) & XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_MASK) >> XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_CORE1_POWER_DOWN_N bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_MASK) | (((v) << XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_SHIFT) & XS1_BOOT_CONFIG_CORE1_POWER_DOWN_N_MASK))
///@}
/**
 * \name BOOT_CONFIG_SECURE_BOOT
 * \anchor BOOT_CONFIG_SECURE_BOOT
 * Overwrite BOOT_MODE.
 */
///@{
#define XS1_BOOT_CONFIG_SECURE_BOOT_SHIFT 0x8
#define XS1_BOOT_CONFIG_SECURE_BOOT_SIZE 0x1
#define XS1_BOOT_CONFIG_SECURE_BOOT_MASK (((1 << XS1_BOOT_CONFIG_SECURE_BOOT_SIZE) - 1) << XS1_BOOT_CONFIG_SECURE_BOOT_SHIFT)
/**
 * Extract the BOOT_CONFIG_SECURE_BOOT bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_SECURE_BOOT(x) (((x) & XS1_BOOT_CONFIG_SECURE_BOOT_MASK) >> XS1_BOOT_CONFIG_SECURE_BOOT_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_SECURE_BOOT bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_SECURE_BOOT_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_SECURE_BOOT_MASK) | (((v) << XS1_BOOT_CONFIG_SECURE_BOOT_SHIFT) & XS1_BOOT_CONFIG_SECURE_BOOT_MASK))
///@}
/**
 * \name BOOT_CONFIG_PROCESSOR
 * \anchor BOOT_CONFIG_PROCESSOR
 * Processor number.
 */
///@{
#define XS1_BOOT_CONFIG_PROCESSOR_SHIFT 0x10
#define XS1_BOOT_CONFIG_PROCESSOR_SIZE 0x8
#define XS1_BOOT_CONFIG_PROCESSOR_MASK (((1 << XS1_BOOT_CONFIG_PROCESSOR_SIZE) - 1) << XS1_BOOT_CONFIG_PROCESSOR_SHIFT)
/**
 * Extract the BOOT_CONFIG_PROCESSOR bitfield from a packed word x and return it.
 */
#define XS1_BOOT_CONFIG_PROCESSOR(x) (((x) & XS1_BOOT_CONFIG_PROCESSOR_MASK) >> XS1_BOOT_CONFIG_PROCESSOR_SHIFT)
/**
 * Pack the value (v) of the BOOT_CONFIG_PROCESSOR bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_CONFIG_PROCESSOR_SET(x, v) (((x) & ~XS1_BOOT_CONFIG_PROCESSOR_MASK) | (((v) << XS1_BOOT_CONFIG_PROCESSOR_SHIFT) & XS1_BOOT_CONFIG_PROCESSOR_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_XCORE_JTAG
 * \anchor SECUR_CFG_DISABLE_XCORE_JTAG
 * Disable access to XCore's JTAG debug TAP 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SHIFT 0x0
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG_MASK (((1 << XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_XCORE_JTAG bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG(x) (((x) & XS1_SECUR_CFG_DISABLE_XCORE_JTAG_MASK) >> XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_XCORE_JTAG bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_XCORE_JTAG_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_XCORE_JTAG_SHIFT) & XS1_SECUR_CFG_DISABLE_XCORE_JTAG_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_XCORE_PLINK
 * \anchor SECUR_CFG_DISABLE_XCORE_PLINK
 * Disable PLinks 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SHIFT 0x1
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK_MASK (((1 << XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_XCORE_PLINK bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK(x) (((x) & XS1_SECUR_CFG_DISABLE_XCORE_PLINK_MASK) >> XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_XCORE_PLINK bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_XCORE_PLINK_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_XCORE_PLINK_SHIFT) & XS1_SECUR_CFG_DISABLE_XCORE_PLINK_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_PLL_JTAG
 * \anchor SECUR_CFG_DISABLE_PLL_JTAG
 * Disable JTAG access to the PLL/BOOT configuration registers 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG_SHIFT 0x4
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG_MASK (((1 << XS1_SECUR_CFG_DISABLE_PLL_JTAG_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_PLL_JTAG_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_PLL_JTAG bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG(x) (((x) & XS1_SECUR_CFG_DISABLE_PLL_JTAG_MASK) >> XS1_SECUR_CFG_DISABLE_PLL_JTAG_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_PLL_JTAG bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_PLL_JTAG_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_PLL_JTAG_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_PLL_JTAG_SHIFT) & XS1_SECUR_CFG_DISABLE_PLL_JTAG_MASK))
///@}
/**
 * \name SECUR_CFG_SECURE_BOOT
 * \anchor SECUR_CFG_SECURE_BOOT
 * Override boot mode and read boot image from OTP 
 */
///@{
#define XS1_SECUR_CFG_SECURE_BOOT_SHIFT 0x5
#define XS1_SECUR_CFG_SECURE_BOOT_SIZE 0x1
#define XS1_SECUR_CFG_SECURE_BOOT_MASK (((1 << XS1_SECUR_CFG_SECURE_BOOT_SIZE) - 1) << XS1_SECUR_CFG_SECURE_BOOT_SHIFT)
/**
 * Extract the SECUR_CFG_SECURE_BOOT bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_SECURE_BOOT(x) (((x) & XS1_SECUR_CFG_SECURE_BOOT_MASK) >> XS1_SECUR_CFG_SECURE_BOOT_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_SECURE_BOOT bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_SECURE_BOOT_SET(x, v) (((x) & ~XS1_SECUR_CFG_SECURE_BOOT_MASK) | (((v) << XS1_SECUR_CFG_SECURE_BOOT_SHIFT) & XS1_SECUR_CFG_SECURE_BOOT_MASK))
///@}
/**
 * \name SECUR_CFG_OTP_COMBINED
 * \anchor SECUR_CFG_OTP_COMBINED
 * Combine OTP into a single address-space for reading.
 */
///@{
#define XS1_SECUR_CFG_OTP_COMBINED_SHIFT 0x7
#define XS1_SECUR_CFG_OTP_COMBINED_SIZE 0x1
#define XS1_SECUR_CFG_OTP_COMBINED_MASK (((1 << XS1_SECUR_CFG_OTP_COMBINED_SIZE) - 1) << XS1_SECUR_CFG_OTP_COMBINED_SHIFT)
/**
 * Extract the SECUR_CFG_OTP_COMBINED bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_OTP_COMBINED(x) (((x) & XS1_SECUR_CFG_OTP_COMBINED_MASK) >> XS1_SECUR_CFG_OTP_COMBINED_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_OTP_COMBINED bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_OTP_COMBINED_SET(x, v) (((x) & ~XS1_SECUR_CFG_OTP_COMBINED_MASK) | (((v) << XS1_SECUR_CFG_OTP_COMBINED_SHIFT) & XS1_SECUR_CFG_OTP_COMBINED_MASK))
///@}
/**
 * \name SECUR_CFG_OTP_PROGRAM_DISABLE
 * \anchor SECUR_CFG_OTP_PROGRAM_DISABLE
 * Prevent access to OTP SBPI interface to prevent programming and other functions. 
 */
///@{
#define XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_SHIFT 0x8
#define XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_SIZE 0x1
#define XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_MASK (((1 << XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_SIZE) - 1) << XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_SHIFT)
/**
 * Extract the SECUR_CFG_OTP_PROGRAM_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_OTP_PROGRAM_DISABLE(x) (((x) & XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_MASK) >> XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_OTP_PROGRAM_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_SET(x, v) (((x) & ~XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_MASK) | (((v) << XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_SHIFT) & XS1_SECUR_CFG_OTP_PROGRAM_DISABLE_MASK))
///@}
/**
 * \name SECUR_CFG_OTP_READ_LOCK
 * \anchor SECUR_CFG_OTP_READ_LOCK
 * Disable read access to OTP. 
 */
///@{
#define XS1_SECUR_CFG_OTP_READ_LOCK_SHIFT 0x9
#define XS1_SECUR_CFG_OTP_READ_LOCK_SIZE 0x1
#define XS1_SECUR_CFG_OTP_READ_LOCK_MASK (((1 << XS1_SECUR_CFG_OTP_READ_LOCK_SIZE) - 1) << XS1_SECUR_CFG_OTP_READ_LOCK_SHIFT)
/**
 * Extract the SECUR_CFG_OTP_READ_LOCK bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_OTP_READ_LOCK(x) (((x) & XS1_SECUR_CFG_OTP_READ_LOCK_MASK) >> XS1_SECUR_CFG_OTP_READ_LOCK_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_OTP_READ_LOCK bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_OTP_READ_LOCK_SET(x, v) (((x) & ~XS1_SECUR_CFG_OTP_READ_LOCK_MASK) | (((v) << XS1_SECUR_CFG_OTP_READ_LOCK_SHIFT) & XS1_SECUR_CFG_OTP_READ_LOCK_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_GLOBAL_DEBUG
 * \anchor SECUR_CFG_DISABLE_GLOBAL_DEBUG
 * Disable access to XCore's global debug 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SHIFT 0xe
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_MASK (((1 << XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_GLOBAL_DEBUG bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG(x) (((x) & XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_MASK) >> XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_GLOBAL_DEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_SHIFT) & XS1_SECUR_CFG_DISABLE_GLOBAL_DEBUG_MASK))
///@}
/**
 * \name SECUR_CFG_DISABLE_ACCESS
 * \anchor SECUR_CFG_DISABLE_ACCESS
 * Disables write permission on this register 
 */
///@{
#define XS1_SECUR_CFG_DISABLE_ACCESS_SHIFT 0x1f
#define XS1_SECUR_CFG_DISABLE_ACCESS_SIZE 0x1
#define XS1_SECUR_CFG_DISABLE_ACCESS_MASK (((1 << XS1_SECUR_CFG_DISABLE_ACCESS_SIZE) - 1) << XS1_SECUR_CFG_DISABLE_ACCESS_SHIFT)
/**
 * Extract the SECUR_CFG_DISABLE_ACCESS bitfield from a packed word x and return it.
 */
#define XS1_SECUR_CFG_DISABLE_ACCESS(x) (((x) & XS1_SECUR_CFG_DISABLE_ACCESS_MASK) >> XS1_SECUR_CFG_DISABLE_ACCESS_SHIFT)
/**
 * Pack the value (v) of the SECUR_CFG_DISABLE_ACCESS bitfield into a packed word x and return the packed field.
 */
#define XS1_SECUR_CFG_DISABLE_ACCESS_SET(x, v) (((x) & ~XS1_SECUR_CFG_DISABLE_ACCESS_MASK) | (((v) << XS1_SECUR_CFG_DISABLE_ACCESS_SHIFT) & XS1_SECUR_CFG_DISABLE_ACCESS_MASK))
///@}
/**
 * \name BOOT_STATUS_LEDS
 * \anchor BOOT_STATUS_LEDS
 * Boot status LED value.
 */
///@{
#define XS1_BOOT_STATUS_LEDS_SHIFT 0x0
#define XS1_BOOT_STATUS_LEDS_SIZE 0x4
#define XS1_BOOT_STATUS_LEDS_MASK (((1 << XS1_BOOT_STATUS_LEDS_SIZE) - 1) << XS1_BOOT_STATUS_LEDS_SHIFT)
/**
 * Extract the BOOT_STATUS_LEDS bitfield from a packed word x and return it.
 */
#define XS1_BOOT_STATUS_LEDS(x) (((x) & XS1_BOOT_STATUS_LEDS_MASK) >> XS1_BOOT_STATUS_LEDS_SHIFT)
/**
 * Pack the value (v) of the BOOT_STATUS_LEDS bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_STATUS_LEDS_SET(x, v) (((x) & ~XS1_BOOT_STATUS_LEDS_MASK) | (((v) << XS1_BOOT_STATUS_LEDS_SHIFT) & XS1_BOOT_STATUS_LEDS_MASK))
///@}
/**
 * \name BOOT_STATUS_BITS
 * \anchor BOOT_STATUS_BITS
 * Other boot status LED bits.
 */
///@{
#define XS1_BOOT_STATUS_BITS_SHIFT 0x4
#define XS1_BOOT_STATUS_BITS_SIZE 0x1c
#define XS1_BOOT_STATUS_BITS_MASK (((1 << XS1_BOOT_STATUS_BITS_SIZE) - 1) << XS1_BOOT_STATUS_BITS_SHIFT)
/**
 * Extract the BOOT_STATUS_BITS bitfield from a packed word x and return it.
 */
#define XS1_BOOT_STATUS_BITS(x) (((x) & XS1_BOOT_STATUS_BITS_MASK) >> XS1_BOOT_STATUS_BITS_SHIFT)
/**
 * Pack the value (v) of the BOOT_STATUS_BITS bitfield into a packed word x and return the packed field.
 */
#define XS1_BOOT_STATUS_BITS_SET(x, v) (((x) & ~XS1_BOOT_STATUS_BITS_MASK) | (((v) << XS1_BOOT_STATUS_BITS_SHIFT) & XS1_BOOT_STATUS_BITS_MASK))
///@}
/**
 * \name RING_OSC_PERPH_ENABLE
 * \anchor RING_OSC_PERPH_ENABLE
 * Set to 1 to enable the core peripheral ring oscillator.
 */
///@{
#define XS1_RING_OSC_PERPH_ENABLE_SHIFT 0x0
#define XS1_RING_OSC_PERPH_ENABLE_SIZE 0x1
#define XS1_RING_OSC_PERPH_ENABLE_MASK (((1 << XS1_RING_OSC_PERPH_ENABLE_SIZE) - 1) << XS1_RING_OSC_PERPH_ENABLE_SHIFT)
/**
 * Extract the RING_OSC_PERPH_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_RING_OSC_PERPH_ENABLE(x) (((x) & XS1_RING_OSC_PERPH_ENABLE_MASK) >> XS1_RING_OSC_PERPH_ENABLE_SHIFT)
/**
 * Pack the value (v) of the RING_OSC_PERPH_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_RING_OSC_PERPH_ENABLE_SET(x, v) (((x) & ~XS1_RING_OSC_PERPH_ENABLE_MASK) | (((v) << XS1_RING_OSC_PERPH_ENABLE_SHIFT) & XS1_RING_OSC_PERPH_ENABLE_MASK))
///@}
/**
 * \name RING_OSC_CORE_ENABLE
 * \anchor RING_OSC_CORE_ENABLE
 * Core ring oscillator enable.
 */
///@{
#define XS1_RING_OSC_CORE_ENABLE_SHIFT 0x1
#define XS1_RING_OSC_CORE_ENABLE_SIZE 0x1
#define XS1_RING_OSC_CORE_ENABLE_MASK (((1 << XS1_RING_OSC_CORE_ENABLE_SIZE) - 1) << XS1_RING_OSC_CORE_ENABLE_SHIFT)
/**
 * Extract the RING_OSC_CORE_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_RING_OSC_CORE_ENABLE(x) (((x) & XS1_RING_OSC_CORE_ENABLE_MASK) >> XS1_RING_OSC_CORE_ENABLE_SHIFT)
/**
 * Pack the value (v) of the RING_OSC_CORE_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_RING_OSC_CORE_ENABLE_SET(x, v) (((x) & ~XS1_RING_OSC_CORE_ENABLE_MASK) | (((v) << XS1_RING_OSC_CORE_ENABLE_SHIFT) & XS1_RING_OSC_CORE_ENABLE_MASK))
///@}
/**
 * \name RING_OSC_DATA
 * \anchor RING_OSC_DATA
 * Ring oscillator Counter data.
 */
///@{
#define XS1_RING_OSC_DATA_SHIFT 0x0
#define XS1_RING_OSC_DATA_SIZE 0x10
#define XS1_RING_OSC_DATA_MASK (((1 << XS1_RING_OSC_DATA_SIZE) - 1) << XS1_RING_OSC_DATA_SHIFT)
/**
 * Extract the RING_OSC_DATA bitfield from a packed word x and return it.
 */
#define XS1_RING_OSC_DATA(x) (((x) & XS1_RING_OSC_DATA_MASK) >> XS1_RING_OSC_DATA_SHIFT)
/**
 * Pack the value (v) of the RING_OSC_DATA bitfield into a packed word x and return the packed field.
 */
#define XS1_RING_OSC_DATA_SET(x, v) (((x) & ~XS1_RING_OSC_DATA_MASK) | (((v) << XS1_RING_OSC_DATA_SHIFT) & XS1_RING_OSC_DATA_MASK))
///@}
/**
 * \name PLL_CLK_DIVIDER
 * \anchor PLL_CLK_DIVIDER
 * Clock divider.
 */
///@{
#define XS1_PLL_CLK_DIVIDER_SHIFT 0x0
#define XS1_PLL_CLK_DIVIDER_SIZE 0x10
#define XS1_PLL_CLK_DIVIDER_MASK (((1 << XS1_PLL_CLK_DIVIDER_SIZE) - 1) << XS1_PLL_CLK_DIVIDER_SHIFT)
/**
 * Extract the PLL_CLK_DIVIDER bitfield from a packed word x and return it.
 */
#define XS1_PLL_CLK_DIVIDER(x) (((x) & XS1_PLL_CLK_DIVIDER_MASK) >> XS1_PLL_CLK_DIVIDER_SHIFT)
/**
 * Pack the value (v) of the PLL_CLK_DIVIDER bitfield into a packed word x and return the packed field.
 */
#define XS1_PLL_CLK_DIVIDER_SET(x, v) (((x) & ~XS1_PLL_CLK_DIVIDER_MASK) | (((v) << XS1_PLL_CLK_DIVIDER_SHIFT) & XS1_PLL_CLK_DIVIDER_MASK))
///@}
/**
 * \name PLL_CLK_DISABLE
 * \anchor PLL_CLK_DISABLE
 * Clock disable. Writing '1' will remove the clock to the tile.
 */
///@{
#define XS1_PLL_CLK_DISABLE_SHIFT 0x1f
#define XS1_PLL_CLK_DISABLE_SIZE 0x1
#define XS1_PLL_CLK_DISABLE_MASK (((1 << XS1_PLL_CLK_DISABLE_SIZE) - 1) << XS1_PLL_CLK_DISABLE_SHIFT)
/**
 * Extract the PLL_CLK_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_PLL_CLK_DISABLE(x) (((x) & XS1_PLL_CLK_DISABLE_MASK) >> XS1_PLL_CLK_DISABLE_SHIFT)
/**
 * Pack the value (v) of the PLL_CLK_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_PLL_CLK_DISABLE_SET(x, v) (((x) & ~XS1_PLL_CLK_DISABLE_MASK) | (((v) << XS1_PLL_CLK_DISABLE_SHIFT) & XS1_PLL_CLK_DISABLE_MASK))
///@}
/**
 * \name RTSEL
 * \anchor RTSEL
 * ROM debug timing adjust.
 */
///@{
#define XS1_RTSEL_SHIFT 0x0
#define XS1_RTSEL_SIZE 0x2
#define XS1_RTSEL_MASK (((1 << XS1_RTSEL_SIZE) - 1) << XS1_RTSEL_SHIFT)
/**
 * Extract the RTSEL bitfield from a packed word x and return it.
 */
#define XS1_RTSEL(x) (((x) & XS1_RTSEL_MASK) >> XS1_RTSEL_SHIFT)
/**
 * Pack the value (v) of the RTSEL bitfield into a packed word x and return the packed field.
 */
#define XS1_RTSEL_SET(x, v) (((x) & ~XS1_RTSEL_MASK) | (((v) << XS1_RTSEL_SHIFT) & XS1_RTSEL_MASK))
///@}
/**
 * \name PTSEL
 * \anchor PTSEL
 * ROM debug timing adjust.
 */
///@{
#define XS1_PTSEL_SHIFT 0x2
#define XS1_PTSEL_SIZE 0x2
#define XS1_PTSEL_MASK (((1 << XS1_PTSEL_SIZE) - 1) << XS1_PTSEL_SHIFT)
/**
 * Extract the PTSEL bitfield from a packed word x and return it.
 */
#define XS1_PTSEL(x) (((x) & XS1_PTSEL_MASK) >> XS1_PTSEL_SHIFT)
/**
 * Pack the value (v) of the PTSEL bitfield into a packed word x and return the packed field.
 */
#define XS1_PTSEL_SET(x, v) (((x) & ~XS1_PTSEL_MASK) | (((v) << XS1_PTSEL_SHIFT) & XS1_PTSEL_MASK))
///@}
/**
 * \name TRB
 * \anchor TRB
 * ROM debug timing adjust.
 */
///@{
#define XS1_TRB_SHIFT 0x4
#define XS1_TRB_SIZE 0x2
#define XS1_TRB_MASK (((1 << XS1_TRB_SIZE) - 1) << XS1_TRB_SHIFT)
/**
 * Extract the TRB bitfield from a packed word x and return it.
 */
#define XS1_TRB(x) (((x) & XS1_TRB_MASK) >> XS1_TRB_SHIFT)
/**
 * Pack the value (v) of the TRB bitfield into a packed word x and return the packed field.
 */
#define XS1_TRB_SET(x, v) (((x) & ~XS1_TRB_MASK) | (((v) << XS1_TRB_SHIFT) & XS1_TRB_MASK))
///@}
/**
 * \name RAM_MASK
 * \anchor RAM_MASK
 * Blocks of 64k rams unavailable
 */
///@{
#define XS1_RAM_MASK_SHIFT 0x0
#define XS1_RAM_MASK_SIZE 0x2
#define XS1_RAM_MASK_MASK (((1 << XS1_RAM_MASK_SIZE) - 1) << XS1_RAM_MASK_SHIFT)
/**
 * Extract the RAM_MASK bitfield from a packed word x and return it.
 */
#define XS1_RAM_MASK(x) (((x) & XS1_RAM_MASK_MASK) >> XS1_RAM_MASK_SHIFT)
/**
 * Pack the value (v) of the RAM_MASK bitfield into a packed word x and return the packed field.
 */
#define XS1_RAM_MASK_SET(x, v) (((x) & ~XS1_RAM_MASK_MASK) | (((v) << XS1_RAM_MASK_SHIFT) & XS1_RAM_MASK_MASK))
///@}
/**
 * \name CORE1_DISABLE
 * \anchor CORE1_DISABLE
 * Core 1's clock is gated off 
 */
///@{
#define XS1_CORE1_DISABLE_SHIFT 0x8
#define XS1_CORE1_DISABLE_SIZE 0x1
#define XS1_CORE1_DISABLE_MASK (((1 << XS1_CORE1_DISABLE_SIZE) - 1) << XS1_CORE1_DISABLE_SHIFT)
/**
 * Extract the CORE1_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_CORE1_DISABLE(x) (((x) & XS1_CORE1_DISABLE_MASK) >> XS1_CORE1_DISABLE_SHIFT)
/**
 * Pack the value (v) of the CORE1_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_CORE1_DISABLE_SET(x, v) (((x) & ~XS1_CORE1_DISABLE_MASK) | (((v) << XS1_CORE1_DISABLE_SHIFT) & XS1_CORE1_DISABLE_MASK))
///@}
/**
 * \name THREAD_MASK
 * \anchor THREAD_MASK
 * Threads unavailable
 */
///@{
#define XS1_THREAD_MASK_SHIFT 0x9
#define XS1_THREAD_MASK_SIZE 0x7
#define XS1_THREAD_MASK_MASK (((1 << XS1_THREAD_MASK_SIZE) - 1) << XS1_THREAD_MASK_SHIFT)
/**
 * Extract the THREAD_MASK bitfield from a packed word x and return it.
 */
#define XS1_THREAD_MASK(x) (((x) & XS1_THREAD_MASK_MASK) >> XS1_THREAD_MASK_SHIFT)
/**
 * Pack the value (v) of the THREAD_MASK bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_MASK_SET(x, v) (((x) & ~XS1_THREAD_MASK_MASK) | (((v) << XS1_THREAD_MASK_SHIFT) & XS1_THREAD_MASK_MASK))
///@}
/**
 * \name THREAD_CTRL0_INUSE
 * \anchor THREAD_CTRL0_INUSE
 * Returns 1 when the thread is in use, 0 otherwise.
 */
///@{
#define XS1_THREAD_CTRL0_INUSE_SHIFT 0x0
#define XS1_THREAD_CTRL0_INUSE_SIZE 0x1
#define XS1_THREAD_CTRL0_INUSE_MASK (((1 << XS1_THREAD_CTRL0_INUSE_SIZE) - 1) << XS1_THREAD_CTRL0_INUSE_SHIFT)
/**
 * Extract the THREAD_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_THREAD_CTRL0_INUSE(x) (((x) & XS1_THREAD_CTRL0_INUSE_MASK) >> XS1_THREAD_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the THREAD_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_THREAD_CTRL0_INUSE_MASK) | (((v) << XS1_THREAD_CTRL0_INUSE_SHIFT) & XS1_THREAD_CTRL0_INUSE_MASK))
///@}
/**
 * \name THREAD_CTRL0_MSYNC
 * \anchor THREAD_CTRL0_MSYNC
 * 1 when the thread is msyncing, 0 otherwise.
 */
///@{
#define XS1_THREAD_CTRL0_MSYNC_SHIFT 0x1
#define XS1_THREAD_CTRL0_MSYNC_SIZE 0x1
#define XS1_THREAD_CTRL0_MSYNC_MASK (((1 << XS1_THREAD_CTRL0_MSYNC_SIZE) - 1) << XS1_THREAD_CTRL0_MSYNC_SHIFT)
/**
 * Extract the THREAD_CTRL0_MSYNC bitfield from a packed word x and return it.
 */
#define XS1_THREAD_CTRL0_MSYNC(x) (((x) & XS1_THREAD_CTRL0_MSYNC_MASK) >> XS1_THREAD_CTRL0_MSYNC_SHIFT)
/**
 * Pack the value (v) of the THREAD_CTRL0_MSYNC bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_CTRL0_MSYNC_SET(x, v) (((x) & ~XS1_THREAD_CTRL0_MSYNC_MASK) | (((v) << XS1_THREAD_CTRL0_MSYNC_SHIFT) & XS1_THREAD_CTRL0_MSYNC_MASK))
///@}
/**
 * \name THREAD_CTRL0_SSYNC
 * \anchor THREAD_CTRL0_SSYNC
 * 1 when the thread is ssyncing, 0 otherwise.
 */
///@{
#define XS1_THREAD_CTRL0_SSYNC_SHIFT 0x2
#define XS1_THREAD_CTRL0_SSYNC_SIZE 0x1
#define XS1_THREAD_CTRL0_SSYNC_MASK (((1 << XS1_THREAD_CTRL0_SSYNC_SIZE) - 1) << XS1_THREAD_CTRL0_SSYNC_SHIFT)
/**
 * Extract the THREAD_CTRL0_SSYNC bitfield from a packed word x and return it.
 */
#define XS1_THREAD_CTRL0_SSYNC(x) (((x) & XS1_THREAD_CTRL0_SSYNC_MASK) >> XS1_THREAD_CTRL0_SSYNC_SHIFT)
/**
 * Pack the value (v) of the THREAD_CTRL0_SSYNC bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_CTRL0_SSYNC_SET(x, v) (((x) & ~XS1_THREAD_CTRL0_SSYNC_MASK) | (((v) << XS1_THREAD_CTRL0_SSYNC_SHIFT) & XS1_THREAD_CTRL0_SSYNC_MASK))
///@}
/**
 * \name THREAD_CTRL0_MASTER
 * \anchor THREAD_CTRL0_MASTER
 * Returns the ID of this thread's master.
 */
///@{
#define XS1_THREAD_CTRL0_MASTER_SHIFT 0x8
#define XS1_THREAD_CTRL0_MASTER_SIZE 0x8
#define XS1_THREAD_CTRL0_MASTER_MASK (((1 << XS1_THREAD_CTRL0_MASTER_SIZE) - 1) << XS1_THREAD_CTRL0_MASTER_SHIFT)
/**
 * Extract the THREAD_CTRL0_MASTER bitfield from a packed word x and return it.
 */
#define XS1_THREAD_CTRL0_MASTER(x) (((x) & XS1_THREAD_CTRL0_MASTER_MASK) >> XS1_THREAD_CTRL0_MASTER_SHIFT)
/**
 * Pack the value (v) of the THREAD_CTRL0_MASTER bitfield into a packed word x and return the packed field.
 */
#define XS1_THREAD_CTRL0_MASTER_SET(x, v) (((x) & ~XS1_THREAD_CTRL0_MASTER_MASK) | (((v) << XS1_THREAD_CTRL0_MASTER_SHIFT) & XS1_THREAD_CTRL0_MASTER_MASK))
///@}
/**
 * \name PORT_CTRL0_INUSE
 * \anchor PORT_CTRL0_INUSE
 * Returns 1 when the port is in use, 0 otherwise.
 */
///@{
#define XS1_PORT_CTRL0_INUSE_SHIFT 0x0
#define XS1_PORT_CTRL0_INUSE_SIZE 0x1
#define XS1_PORT_CTRL0_INUSE_MASK (((1 << XS1_PORT_CTRL0_INUSE_SIZE) - 1) << XS1_PORT_CTRL0_INUSE_SHIFT)
/**
 * Extract the PORT_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_INUSE(x) (((x) & XS1_PORT_CTRL0_INUSE_MASK) >> XS1_PORT_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_INUSE_MASK) | (((v) << XS1_PORT_CTRL0_INUSE_SHIFT) & XS1_PORT_CTRL0_INUSE_MASK))
///@}
/**
 * \name PORT_CTRL0_IE_MODE
 * \anchor PORT_CTRL0_IE_MODE
 * 0 when this port will cause events, 1 when it will raise interrupts. It is controlled using the ``SETC`` instruction.
 */
///@{
#define XS1_PORT_CTRL0_IE_MODE_SHIFT 0x1
#define XS1_PORT_CTRL0_IE_MODE_SIZE 0x1
#define XS1_PORT_CTRL0_IE_MODE_MASK (((1 << XS1_PORT_CTRL0_IE_MODE_SIZE) - 1) << XS1_PORT_CTRL0_IE_MODE_SHIFT)
/**
 * Extract the PORT_CTRL0_IE_MODE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_IE_MODE(x) (((x) & XS1_PORT_CTRL0_IE_MODE_MASK) >> XS1_PORT_CTRL0_IE_MODE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_IE_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_IE_MODE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_IE_MODE_MASK) | (((v) << XS1_PORT_CTRL0_IE_MODE_SHIFT) & XS1_PORT_CTRL0_IE_MODE_MASK))
///@}
/**
 * \name PORT_CTRL0_IE_ENABLED
 * \anchor PORT_CTRL0_IE_ENABLED
 * 1 when events or interrupts on this port are active. It is set when an  ``EEU`` is executed. It is cleared when a ``EDU`` or ``CLRE`` is executed. The ``EET`` and ``EEF`` will either set or clear the bit depending on the contents of the condition register.
 */
///@{
#define XS1_PORT_CTRL0_IE_ENABLED_SHIFT 0x2
#define XS1_PORT_CTRL0_IE_ENABLED_SIZE 0x1
#define XS1_PORT_CTRL0_IE_ENABLED_MASK (((1 << XS1_PORT_CTRL0_IE_ENABLED_SIZE) - 1) << XS1_PORT_CTRL0_IE_ENABLED_SHIFT)
/**
 * Extract the PORT_CTRL0_IE_ENABLED bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_IE_ENABLED(x) (((x) & XS1_PORT_CTRL0_IE_ENABLED_MASK) >> XS1_PORT_CTRL0_IE_ENABLED_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_IE_ENABLED bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_IE_ENABLED_SET(x, v) (((x) & ~XS1_PORT_CTRL0_IE_ENABLED_MASK) | (((v) << XS1_PORT_CTRL0_IE_ENABLED_SHIFT) & XS1_PORT_CTRL0_IE_ENABLED_MASK))
///@}
/**
 * \name PORT_CTRL0_DIRECTION
 * \anchor PORT_CTRL0_DIRECTION
 * 0 when it is in input mode, 1 when this port is in output mode.
 */
///@{
#define XS1_PORT_CTRL0_DIRECTION_SHIFT 0x3
#define XS1_PORT_CTRL0_DIRECTION_SIZE 0x1
#define XS1_PORT_CTRL0_DIRECTION_MASK (((1 << XS1_PORT_CTRL0_DIRECTION_SIZE) - 1) << XS1_PORT_CTRL0_DIRECTION_SHIFT)
/**
 * Extract the PORT_CTRL0_DIRECTION bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_DIRECTION(x) (((x) & XS1_PORT_CTRL0_DIRECTION_MASK) >> XS1_PORT_CTRL0_DIRECTION_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_DIRECTION bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_DIRECTION_SET(x, v) (((x) & ~XS1_PORT_CTRL0_DIRECTION_MASK) | (((v) << XS1_PORT_CTRL0_DIRECTION_SHIFT) & XS1_PORT_CTRL0_DIRECTION_MASK))
///@}
/**
 * \name PORT_CTRL0_COND
 * \anchor PORT_CTRL0_COND
 * Shows the current condition of the port. The condition is set using the ``SETC`` instruction.
 */
///@{
#define XS1_PORT_CTRL0_COND_SHIFT 0x4
#define XS1_PORT_CTRL0_COND_SIZE 0x4
#define XS1_PORT_CTRL0_COND_MASK (((1 << XS1_PORT_CTRL0_COND_SIZE) - 1) << XS1_PORT_CTRL0_COND_SHIFT)
/**
 * Extract the PORT_CTRL0_COND bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_COND(x) (((x) & XS1_PORT_CTRL0_COND_MASK) >> XS1_PORT_CTRL0_COND_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_COND bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_COND_SET(x, v) (((x) & ~XS1_PORT_CTRL0_COND_MASK) | (((v) << XS1_PORT_CTRL0_COND_SHIFT) & XS1_PORT_CTRL0_COND_MASK))
///@}
/**
 * \name PORT_CTRL0_MASTER_SLAVE
 * \anchor PORT_CTRL0_MASTER_SLAVE
 * 0 when the port is a master, 1 when it is a slave.
 */
///@{
#define XS1_PORT_CTRL0_MASTER_SLAVE_SHIFT 0x8
#define XS1_PORT_CTRL0_MASTER_SLAVE_SIZE 0x1
#define XS1_PORT_CTRL0_MASTER_SLAVE_MASK (((1 << XS1_PORT_CTRL0_MASTER_SLAVE_SIZE) - 1) << XS1_PORT_CTRL0_MASTER_SLAVE_SHIFT)
/**
 * Extract the PORT_CTRL0_MASTER_SLAVE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_MASTER_SLAVE(x) (((x) & XS1_PORT_CTRL0_MASTER_SLAVE_MASK) >> XS1_PORT_CTRL0_MASTER_SLAVE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_MASTER_SLAVE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_MASTER_SLAVE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_MASTER_SLAVE_MASK) | (((v) << XS1_PORT_CTRL0_MASTER_SLAVE_SHIFT) & XS1_PORT_CTRL0_MASTER_SLAVE_MASK))
///@}
/**
 * \name PORT_CTRL0_BUFFERS
 * \anchor PORT_CTRL0_BUFFERS
 * When 0 there is no buffering between the port and pins. When 1 there is buffering between the port and instructions.
 */
///@{
#define XS1_PORT_CTRL0_BUFFERS_SHIFT 0x9
#define XS1_PORT_CTRL0_BUFFERS_SIZE 0x1
#define XS1_PORT_CTRL0_BUFFERS_MASK (((1 << XS1_PORT_CTRL0_BUFFERS_SIZE) - 1) << XS1_PORT_CTRL0_BUFFERS_SHIFT)
/**
 * Extract the PORT_CTRL0_BUFFERS bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_BUFFERS(x) (((x) & XS1_PORT_CTRL0_BUFFERS_MASK) >> XS1_PORT_CTRL0_BUFFERS_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_BUFFERS bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_BUFFERS_SET(x, v) (((x) & ~XS1_PORT_CTRL0_BUFFERS_MASK) | (((v) << XS1_PORT_CTRL0_BUFFERS_SHIFT) & XS1_PORT_CTRL0_BUFFERS_MASK))
///@}
/**
 * \name PORT_CTRL0_READY_MODE
 * \anchor PORT_CTRL0_READY_MODE
 * 0 - no ready signals used, 1 - strobed port, 2 - handshaken port
 */
///@{
#define XS1_PORT_CTRL0_READY_MODE_SHIFT 0xa
#define XS1_PORT_CTRL0_READY_MODE_SIZE 0x2
#define XS1_PORT_CTRL0_READY_MODE_MASK (((1 << XS1_PORT_CTRL0_READY_MODE_SIZE) - 1) << XS1_PORT_CTRL0_READY_MODE_SHIFT)
/**
 * Extract the PORT_CTRL0_READY_MODE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_READY_MODE(x) (((x) & XS1_PORT_CTRL0_READY_MODE_MASK) >> XS1_PORT_CTRL0_READY_MODE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_READY_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_READY_MODE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_READY_MODE_MASK) | (((v) << XS1_PORT_CTRL0_READY_MODE_SHIFT) & XS1_PORT_CTRL0_READY_MODE_MASK))
///@}
/**
 * \name PORT_CTRL0_PORT_TYPE
 * \anchor PORT_CTRL0_PORT_TYPE
 * 0 - data port, 1 - clock port (1-bit ports only), 2 - ready port (1-bit ports only)
 */
///@{
#define XS1_PORT_CTRL0_PORT_TYPE_SHIFT 0xc
#define XS1_PORT_CTRL0_PORT_TYPE_SIZE 0x2
#define XS1_PORT_CTRL0_PORT_TYPE_MASK (((1 << XS1_PORT_CTRL0_PORT_TYPE_SIZE) - 1) << XS1_PORT_CTRL0_PORT_TYPE_SHIFT)
/**
 * Extract the PORT_CTRL0_PORT_TYPE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_PORT_TYPE(x) (((x) & XS1_PORT_CTRL0_PORT_TYPE_MASK) >> XS1_PORT_CTRL0_PORT_TYPE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_PORT_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_PORT_TYPE_SET(x, v) (((x) & ~XS1_PORT_CTRL0_PORT_TYPE_MASK) | (((v) << XS1_PORT_CTRL0_PORT_TYPE_SHIFT) & XS1_PORT_CTRL0_PORT_TYPE_MASK))
///@}
/**
 * \name PORT_CTRL0_INVERT
 * \anchor PORT_CTRL0_INVERT
 * When 1 the port is inverted, otherwise it is not inverted. Only possible on 1-bit ports.
 */
///@{
#define XS1_PORT_CTRL0_INVERT_SHIFT 0xe
#define XS1_PORT_CTRL0_INVERT_SIZE 0x1
#define XS1_PORT_CTRL0_INVERT_MASK (((1 << XS1_PORT_CTRL0_INVERT_SIZE) - 1) << XS1_PORT_CTRL0_INVERT_SHIFT)
/**
 * Extract the PORT_CTRL0_INVERT bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_INVERT(x) (((x) & XS1_PORT_CTRL0_INVERT_MASK) >> XS1_PORT_CTRL0_INVERT_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_INVERT bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_INVERT_SET(x, v) (((x) & ~XS1_PORT_CTRL0_INVERT_MASK) | (((v) << XS1_PORT_CTRL0_INVERT_SHIFT) & XS1_PORT_CTRL0_INVERT_MASK))
///@}
/**
 * \name PORT_CTRL0_SDELAY
 * \anchor PORT_CTRL0_SDELAY
 * 0 when the input uses the rising edge, 1 when it uses the falling edge of the clock.
 */
///@{
#define XS1_PORT_CTRL0_SDELAY_SHIFT 0xf
#define XS1_PORT_CTRL0_SDELAY_SIZE 0x1
#define XS1_PORT_CTRL0_SDELAY_MASK (((1 << XS1_PORT_CTRL0_SDELAY_SIZE) - 1) << XS1_PORT_CTRL0_SDELAY_SHIFT)
/**
 * Extract the PORT_CTRL0_SDELAY bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_SDELAY(x) (((x) & XS1_PORT_CTRL0_SDELAY_MASK) >> XS1_PORT_CTRL0_SDELAY_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_SDELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_SDELAY_SET(x, v) (((x) & ~XS1_PORT_CTRL0_SDELAY_MASK) | (((v) << XS1_PORT_CTRL0_SDELAY_SHIFT) & XS1_PORT_CTRL0_SDELAY_MASK))
///@}
/**
 * \name PORT_CTRL0_EV_VALID
 * \anchor PORT_CTRL0_EV_VALID
 * 1 when the Environment Vector is valid. When invalid, the resourceId is used as the environment vector. The environment vector is set using the ``SETEV`` instruction.
 */
///@{
#define XS1_PORT_CTRL0_EV_VALID_SHIFT 0x16
#define XS1_PORT_CTRL0_EV_VALID_SIZE 0x1
#define XS1_PORT_CTRL0_EV_VALID_MASK (((1 << XS1_PORT_CTRL0_EV_VALID_SIZE) - 1) << XS1_PORT_CTRL0_EV_VALID_SHIFT)
/**
 * Extract the PORT_CTRL0_EV_VALID bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_EV_VALID(x) (((x) & XS1_PORT_CTRL0_EV_VALID_MASK) >> XS1_PORT_CTRL0_EV_VALID_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_EV_VALID bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_EV_VALID_SET(x, v) (((x) & ~XS1_PORT_CTRL0_EV_VALID_MASK) | (((v) << XS1_PORT_CTRL0_EV_VALID_SHIFT) & XS1_PORT_CTRL0_EV_VALID_MASK))
///@}
/**
 * \name PORT_CTRL0_T_WAITING
 * \anchor PORT_CTRL0_T_WAITING
 * 1 when there is a thread waiting to be unblocked by this port.
 */
///@{
#define XS1_PORT_CTRL0_T_WAITING_SHIFT 0x17
#define XS1_PORT_CTRL0_T_WAITING_SIZE 0x1
#define XS1_PORT_CTRL0_T_WAITING_MASK (((1 << XS1_PORT_CTRL0_T_WAITING_SIZE) - 1) << XS1_PORT_CTRL0_T_WAITING_SHIFT)
/**
 * Extract the PORT_CTRL0_T_WAITING bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_T_WAITING(x) (((x) & XS1_PORT_CTRL0_T_WAITING_MASK) >> XS1_PORT_CTRL0_T_WAITING_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_T_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_T_WAITING_SET(x, v) (((x) & ~XS1_PORT_CTRL0_T_WAITING_MASK) | (((v) << XS1_PORT_CTRL0_T_WAITING_SHIFT) & XS1_PORT_CTRL0_T_WAITING_MASK))
///@}
/**
 * \name PORT_CTRL0_T_NUM
 * \anchor PORT_CTRL0_T_NUM
 * Number of the thread waiting for events or to be unblocked by this port.
 */
///@{
#define XS1_PORT_CTRL0_T_NUM_SHIFT 0x18
#define XS1_PORT_CTRL0_T_NUM_SIZE 0x8
#define XS1_PORT_CTRL0_T_NUM_MASK (((1 << XS1_PORT_CTRL0_T_NUM_SIZE) - 1) << XS1_PORT_CTRL0_T_NUM_SHIFT)
/**
 * Extract the PORT_CTRL0_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL0_T_NUM(x) (((x) & XS1_PORT_CTRL0_T_NUM_MASK) >> XS1_PORT_CTRL0_T_NUM_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL0_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL0_T_NUM_SET(x, v) (((x) & ~XS1_PORT_CTRL0_T_NUM_MASK) | (((v) << XS1_PORT_CTRL0_T_NUM_SHIFT) & XS1_PORT_CTRL0_T_NUM_MASK))
///@}
/**
 * \name PORT_CTRL1_DRIVE
 * \anchor PORT_CTRL1_DRIVE
 * Determines whether the output is driving, open drain or pull down.
 */
///@{
#define XS1_PORT_CTRL1_DRIVE_SHIFT 0x0
#define XS1_PORT_CTRL1_DRIVE_SIZE 0x8
#define XS1_PORT_CTRL1_DRIVE_MASK (((1 << XS1_PORT_CTRL1_DRIVE_SIZE) - 1) << XS1_PORT_CTRL1_DRIVE_SHIFT)
/**
 * Extract the PORT_CTRL1_DRIVE bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_DRIVE(x) (((x) & XS1_PORT_CTRL1_DRIVE_MASK) >> XS1_PORT_CTRL1_DRIVE_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_DRIVE bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_DRIVE_SET(x, v) (((x) & ~XS1_PORT_CTRL1_DRIVE_MASK) | (((v) << XS1_PORT_CTRL1_DRIVE_SHIFT) & XS1_PORT_CTRL1_DRIVE_MASK))
///@}
/**
 * \name PORT_CTRL1_TWIDTH
 * \anchor PORT_CTRL1_TWIDTH
 * The transfer width of the port in bits
 */
///@{
#define XS1_PORT_CTRL1_TWIDTH_SHIFT 0x8
#define XS1_PORT_CTRL1_TWIDTH_SIZE 0x8
#define XS1_PORT_CTRL1_TWIDTH_MASK (((1 << XS1_PORT_CTRL1_TWIDTH_SIZE) - 1) << XS1_PORT_CTRL1_TWIDTH_SHIFT)
/**
 * Extract the PORT_CTRL1_TWIDTH bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_TWIDTH(x) (((x) & XS1_PORT_CTRL1_TWIDTH_MASK) >> XS1_PORT_CTRL1_TWIDTH_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_TWIDTH bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_TWIDTH_SET(x, v) (((x) & ~XS1_PORT_CTRL1_TWIDTH_MASK) | (((v) << XS1_PORT_CTRL1_TWIDTH_SHIFT) & XS1_PORT_CTRL1_TWIDTH_MASK))
///@}
/**
 * \name PORT_CTRL1_SREG_COUNT
 * \anchor PORT_CTRL1_SREG_COUNT
 * The shift register count in port widths.
 */
///@{
#define XS1_PORT_CTRL1_SREG_COUNT_SHIFT 0x10
#define XS1_PORT_CTRL1_SREG_COUNT_SIZE 0x8
#define XS1_PORT_CTRL1_SREG_COUNT_MASK (((1 << XS1_PORT_CTRL1_SREG_COUNT_SIZE) - 1) << XS1_PORT_CTRL1_SREG_COUNT_SHIFT)
/**
 * Extract the PORT_CTRL1_SREG_COUNT bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_SREG_COUNT(x) (((x) & XS1_PORT_CTRL1_SREG_COUNT_MASK) >> XS1_PORT_CTRL1_SREG_COUNT_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_SREG_COUNT bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_SREG_COUNT_SET(x, v) (((x) & ~XS1_PORT_CTRL1_SREG_COUNT_MASK) | (((v) << XS1_PORT_CTRL1_SREG_COUNT_SHIFT) & XS1_PORT_CTRL1_SREG_COUNT_MASK))
///@}
/**
 * \name PORT_CTRL1_TREG_FULL
 * \anchor PORT_CTRL1_TREG_FULL
 * 1 when the transfer register is full.
 */
///@{
#define XS1_PORT_CTRL1_TREG_FULL_SHIFT 0x18
#define XS1_PORT_CTRL1_TREG_FULL_SIZE 0x1
#define XS1_PORT_CTRL1_TREG_FULL_MASK (((1 << XS1_PORT_CTRL1_TREG_FULL_SIZE) - 1) << XS1_PORT_CTRL1_TREG_FULL_SHIFT)
/**
 * Extract the PORT_CTRL1_TREG_FULL bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_TREG_FULL(x) (((x) & XS1_PORT_CTRL1_TREG_FULL_MASK) >> XS1_PORT_CTRL1_TREG_FULL_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_TREG_FULL bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_TREG_FULL_SET(x, v) (((x) & ~XS1_PORT_CTRL1_TREG_FULL_MASK) | (((v) << XS1_PORT_CTRL1_TREG_FULL_SHIFT) & XS1_PORT_CTRL1_TREG_FULL_MASK))
///@}
/**
 * \name PORT_CTRL1_CHANGE_DIR
 * \anchor PORT_CTRL1_CHANGE_DIR
 * 0 when the direction is fixed, 1 when it is going to change.
 */
///@{
#define XS1_PORT_CTRL1_CHANGE_DIR_SHIFT 0x19
#define XS1_PORT_CTRL1_CHANGE_DIR_SIZE 0x1
#define XS1_PORT_CTRL1_CHANGE_DIR_MASK (((1 << XS1_PORT_CTRL1_CHANGE_DIR_SIZE) - 1) << XS1_PORT_CTRL1_CHANGE_DIR_SHIFT)
/**
 * Extract the PORT_CTRL1_CHANGE_DIR bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_CHANGE_DIR(x) (((x) & XS1_PORT_CTRL1_CHANGE_DIR_MASK) >> XS1_PORT_CTRL1_CHANGE_DIR_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_CHANGE_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_CHANGE_DIR_SET(x, v) (((x) & ~XS1_PORT_CTRL1_CHANGE_DIR_MASK) | (((v) << XS1_PORT_CTRL1_CHANGE_DIR_SHIFT) & XS1_PORT_CTRL1_CHANGE_DIR_MASK))
///@}
/**
 * \name PORT_CTRL1_SYNCR
 * \anchor PORT_CTRL1_SYNCR
 * 1 when a SYNCR instruction is pending completion.
 */
///@{
#define XS1_PORT_CTRL1_SYNCR_SHIFT 0x1a
#define XS1_PORT_CTRL1_SYNCR_SIZE 0x1
#define XS1_PORT_CTRL1_SYNCR_MASK (((1 << XS1_PORT_CTRL1_SYNCR_SIZE) - 1) << XS1_PORT_CTRL1_SYNCR_SHIFT)
/**
 * Extract the PORT_CTRL1_SYNCR bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_SYNCR(x) (((x) & XS1_PORT_CTRL1_SYNCR_MASK) >> XS1_PORT_CTRL1_SYNCR_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_SYNCR bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_SYNCR_SET(x, v) (((x) & ~XS1_PORT_CTRL1_SYNCR_MASK) | (((v) << XS1_PORT_CTRL1_SYNCR_SHIFT) & XS1_PORT_CTRL1_SYNCR_MASK))
///@}
/**
 * \name PORT_CTRL1_INST_COMMITTED
 * \anchor PORT_CTRL1_INST_COMMITTED
 * 1 when an instruction has committed to operating on the port.
 */
///@{
#define XS1_PORT_CTRL1_INST_COMMITTED_SHIFT 0x1b
#define XS1_PORT_CTRL1_INST_COMMITTED_SIZE 0x1
#define XS1_PORT_CTRL1_INST_COMMITTED_MASK (((1 << XS1_PORT_CTRL1_INST_COMMITTED_SIZE) - 1) << XS1_PORT_CTRL1_INST_COMMITTED_SHIFT)
/**
 * Extract the PORT_CTRL1_INST_COMMITTED bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_INST_COMMITTED(x) (((x) & XS1_PORT_CTRL1_INST_COMMITTED_MASK) >> XS1_PORT_CTRL1_INST_COMMITTED_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_INST_COMMITTED bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_INST_COMMITTED_SET(x, v) (((x) & ~XS1_PORT_CTRL1_INST_COMMITTED_MASK) | (((v) << XS1_PORT_CTRL1_INST_COMMITTED_SHIFT) & XS1_PORT_CTRL1_INST_COMMITTED_MASK))
///@}
/**
 * \name PORT_CTRL1_HOLD_DATA
 * \anchor PORT_CTRL1_HOLD_DATA
 * 1 data has been captured for a condition and is being held.
 */
///@{
#define XS1_PORT_CTRL1_HOLD_DATA_SHIFT 0x1c
#define XS1_PORT_CTRL1_HOLD_DATA_SIZE 0x1
#define XS1_PORT_CTRL1_HOLD_DATA_MASK (((1 << XS1_PORT_CTRL1_HOLD_DATA_SIZE) - 1) << XS1_PORT_CTRL1_HOLD_DATA_SHIFT)
/**
 * Extract the PORT_CTRL1_HOLD_DATA bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_HOLD_DATA(x) (((x) & XS1_PORT_CTRL1_HOLD_DATA_MASK) >> XS1_PORT_CTRL1_HOLD_DATA_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_HOLD_DATA bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_HOLD_DATA_SET(x, v) (((x) & ~XS1_PORT_CTRL1_HOLD_DATA_MASK) | (((v) << XS1_PORT_CTRL1_HOLD_DATA_SHIFT) & XS1_PORT_CTRL1_HOLD_DATA_MASK))
///@}
/**
 * \name PORT_CTRL1_WAIT_FOR_TIME
 * \anchor PORT_CTRL1_WAIT_FOR_TIME
 * 1 when waiting for the port time to be met.
 */
///@{
#define XS1_PORT_CTRL1_WAIT_FOR_TIME_SHIFT 0x1d
#define XS1_PORT_CTRL1_WAIT_FOR_TIME_SIZE 0x1
#define XS1_PORT_CTRL1_WAIT_FOR_TIME_MASK (((1 << XS1_PORT_CTRL1_WAIT_FOR_TIME_SIZE) - 1) << XS1_PORT_CTRL1_WAIT_FOR_TIME_SHIFT)
/**
 * Extract the PORT_CTRL1_WAIT_FOR_TIME bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_WAIT_FOR_TIME(x) (((x) & XS1_PORT_CTRL1_WAIT_FOR_TIME_MASK) >> XS1_PORT_CTRL1_WAIT_FOR_TIME_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_WAIT_FOR_TIME bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_WAIT_FOR_TIME_SET(x, v) (((x) & ~XS1_PORT_CTRL1_WAIT_FOR_TIME_MASK) | (((v) << XS1_PORT_CTRL1_WAIT_FOR_TIME_SHIFT) & XS1_PORT_CTRL1_WAIT_FOR_TIME_MASK))
///@}
/**
 * \name PORT_CTRL1_TIMEMET
 * \anchor PORT_CTRL1_TIMEMET
 * 1 when a SETPT is used.
 */
///@{
#define XS1_PORT_CTRL1_TIMEMET_SHIFT 0x1e
#define XS1_PORT_CTRL1_TIMEMET_SIZE 0x1
#define XS1_PORT_CTRL1_TIMEMET_MASK (((1 << XS1_PORT_CTRL1_TIMEMET_SIZE) - 1) << XS1_PORT_CTRL1_TIMEMET_SHIFT)
/**
 * Extract the PORT_CTRL1_TIMEMET bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_TIMEMET(x) (((x) & XS1_PORT_CTRL1_TIMEMET_MASK) >> XS1_PORT_CTRL1_TIMEMET_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_TIMEMET bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_TIMEMET_SET(x, v) (((x) & ~XS1_PORT_CTRL1_TIMEMET_MASK) | (((v) << XS1_PORT_CTRL1_TIMEMET_SHIFT) & XS1_PORT_CTRL1_TIMEMET_MASK))
///@}
/**
 * \name PORT_CTRL1_ENDIN
 * \anchor PORT_CTRL1_ENDIN
 * 1 when an ENDIN is used on a BUFFERS port and the tReg was full.
 */
///@{
#define XS1_PORT_CTRL1_ENDIN_SHIFT 0x1f
#define XS1_PORT_CTRL1_ENDIN_SIZE 0x1
#define XS1_PORT_CTRL1_ENDIN_MASK (((1 << XS1_PORT_CTRL1_ENDIN_SIZE) - 1) << XS1_PORT_CTRL1_ENDIN_SHIFT)
/**
 * Extract the PORT_CTRL1_ENDIN bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL1_ENDIN(x) (((x) & XS1_PORT_CTRL1_ENDIN_MASK) >> XS1_PORT_CTRL1_ENDIN_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL1_ENDIN bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL1_ENDIN_SET(x, v) (((x) & ~XS1_PORT_CTRL1_ENDIN_MASK) | (((v) << XS1_PORT_CTRL1_ENDIN_SHIFT) & XS1_PORT_CTRL1_ENDIN_MASK))
///@}
/**
 * \name PORT_CTRL2_TIME
 * \anchor PORT_CTRL2_TIME
 * The port time value.
 */
///@{
#define XS1_PORT_CTRL2_TIME_SHIFT 0x0
#define XS1_PORT_CTRL2_TIME_SIZE 0x10
#define XS1_PORT_CTRL2_TIME_MASK (((1 << XS1_PORT_CTRL2_TIME_SIZE) - 1) << XS1_PORT_CTRL2_TIME_SHIFT)
/**
 * Extract the PORT_CTRL2_TIME bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL2_TIME(x) (((x) & XS1_PORT_CTRL2_TIME_MASK) >> XS1_PORT_CTRL2_TIME_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL2_TIME bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL2_TIME_SET(x, v) (((x) & ~XS1_PORT_CTRL2_TIME_MASK) | (((v) << XS1_PORT_CTRL2_TIME_SHIFT) & XS1_PORT_CTRL2_TIME_MASK))
///@}
/**
 * \name PORT_CTRL2_PIN_DELAY
 * \anchor PORT_CTRL2_PIN_DELAY
 * The port pin delay.
 */
///@{
#define XS1_PORT_CTRL2_PIN_DELAY_SHIFT 0x10
#define XS1_PORT_CTRL2_PIN_DELAY_SIZE 0x3
#define XS1_PORT_CTRL2_PIN_DELAY_MASK (((1 << XS1_PORT_CTRL2_PIN_DELAY_SIZE) - 1) << XS1_PORT_CTRL2_PIN_DELAY_SHIFT)
/**
 * Extract the PORT_CTRL2_PIN_DELAY bitfield from a packed word x and return it.
 */
#define XS1_PORT_CTRL2_PIN_DELAY(x) (((x) & XS1_PORT_CTRL2_PIN_DELAY_MASK) >> XS1_PORT_CTRL2_PIN_DELAY_SHIFT)
/**
 * Pack the value (v) of the PORT_CTRL2_PIN_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_CTRL2_PIN_DELAY_SET(x, v) (((x) & ~XS1_PORT_CTRL2_PIN_DELAY_MASK) | (((v) << XS1_PORT_CTRL2_PIN_DELAY_SHIFT) & XS1_PORT_CTRL2_PIN_DELAY_MASK))
///@}
/**
 * \name PORT_PAD_CTRL_OEN
 * \anchor PORT_PAD_CTRL_OEN
 * The pad control output enable.
 */
///@{
#define XS1_PORT_PAD_CTRL_OEN_SHIFT 0x0
#define XS1_PORT_PAD_CTRL_OEN_SIZE 0x1
#define XS1_PORT_PAD_CTRL_OEN_MASK (((1 << XS1_PORT_PAD_CTRL_OEN_SIZE) - 1) << XS1_PORT_PAD_CTRL_OEN_SHIFT)
/**
 * Extract the PORT_PAD_CTRL_OEN bitfield from a packed word x and return it.
 */
#define XS1_PORT_PAD_CTRL_OEN(x) (((x) & XS1_PORT_PAD_CTRL_OEN_MASK) >> XS1_PORT_PAD_CTRL_OEN_SHIFT)
/**
 * Pack the value (v) of the PORT_PAD_CTRL_OEN bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_PAD_CTRL_OEN_SET(x, v) (((x) & ~XS1_PORT_PAD_CTRL_OEN_MASK) | (((v) << XS1_PORT_PAD_CTRL_OEN_SHIFT) & XS1_PORT_PAD_CTRL_OEN_MASK))
///@}
/**
 * \name PORT_PAD_CTRL_REN
 * \anchor PORT_PAD_CTRL_REN
 * The pad control read enable.
 */
///@{
#define XS1_PORT_PAD_CTRL_REN_SHIFT 0x1
#define XS1_PORT_PAD_CTRL_REN_SIZE 0x1
#define XS1_PORT_PAD_CTRL_REN_MASK (((1 << XS1_PORT_PAD_CTRL_REN_SIZE) - 1) << XS1_PORT_PAD_CTRL_REN_SHIFT)
/**
 * Extract the PORT_PAD_CTRL_REN bitfield from a packed word x and return it.
 */
#define XS1_PORT_PAD_CTRL_REN(x) (((x) & XS1_PORT_PAD_CTRL_REN_MASK) >> XS1_PORT_PAD_CTRL_REN_SHIFT)
/**
 * Pack the value (v) of the PORT_PAD_CTRL_REN bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_PAD_CTRL_REN_SET(x, v) (((x) & ~XS1_PORT_PAD_CTRL_REN_MASK) | (((v) << XS1_PORT_PAD_CTRL_REN_SHIFT) & XS1_PORT_PAD_CTRL_REN_MASK))
///@}
/**
 * \name PORT_PAD_CTRL_P
 * \anchor PORT_PAD_CTRL_P
 * The pad control pull.
 */
///@{
#define XS1_PORT_PAD_CTRL_P_SHIFT 0x2
#define XS1_PORT_PAD_CTRL_P_SIZE 0x2
#define XS1_PORT_PAD_CTRL_P_MASK (((1 << XS1_PORT_PAD_CTRL_P_SIZE) - 1) << XS1_PORT_PAD_CTRL_P_SHIFT)
/**
 * Extract the PORT_PAD_CTRL_P bitfield from a packed word x and return it.
 */
#define XS1_PORT_PAD_CTRL_P(x) (((x) & XS1_PORT_PAD_CTRL_P_MASK) >> XS1_PORT_PAD_CTRL_P_SHIFT)
/**
 * Pack the value (v) of the PORT_PAD_CTRL_P bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_PAD_CTRL_P_SET(x, v) (((x) & ~XS1_PORT_PAD_CTRL_P_MASK) | (((v) << XS1_PORT_PAD_CTRL_P_SHIFT) & XS1_PORT_PAD_CTRL_P_MASK))
///@}
/**
 * \name PORT_PAD_CTRL_E
 * \anchor PORT_PAD_CTRL_E
 * The pad control drive strength.
 */
///@{
#define XS1_PORT_PAD_CTRL_E_SHIFT 0x4
#define XS1_PORT_PAD_CTRL_E_SIZE 0x2
#define XS1_PORT_PAD_CTRL_E_MASK (((1 << XS1_PORT_PAD_CTRL_E_SIZE) - 1) << XS1_PORT_PAD_CTRL_E_SHIFT)
/**
 * Extract the PORT_PAD_CTRL_E bitfield from a packed word x and return it.
 */
#define XS1_PORT_PAD_CTRL_E(x) (((x) & XS1_PORT_PAD_CTRL_E_MASK) >> XS1_PORT_PAD_CTRL_E_SHIFT)
/**
 * Pack the value (v) of the PORT_PAD_CTRL_E bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_PAD_CTRL_E_SET(x, v) (((x) & ~XS1_PORT_PAD_CTRL_E_MASK) | (((v) << XS1_PORT_PAD_CTRL_E_SHIFT) & XS1_PORT_PAD_CTRL_E_MASK))
///@}
/**
 * \name PORT_PAD_CTRL_SR
 * \anchor PORT_PAD_CTRL_SR
 * The pad control slew rate.
 */
///@{
#define XS1_PORT_PAD_CTRL_SR_SHIFT 0x6
#define XS1_PORT_PAD_CTRL_SR_SIZE 0x1
#define XS1_PORT_PAD_CTRL_SR_MASK (((1 << XS1_PORT_PAD_CTRL_SR_SIZE) - 1) << XS1_PORT_PAD_CTRL_SR_SHIFT)
/**
 * Extract the PORT_PAD_CTRL_SR bitfield from a packed word x and return it.
 */
#define XS1_PORT_PAD_CTRL_SR(x) (((x) & XS1_PORT_PAD_CTRL_SR_MASK) >> XS1_PORT_PAD_CTRL_SR_SHIFT)
/**
 * Pack the value (v) of the PORT_PAD_CTRL_SR bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_PAD_CTRL_SR_SET(x, v) (((x) & ~XS1_PORT_PAD_CTRL_SR_MASK) | (((v) << XS1_PORT_PAD_CTRL_SR_SHIFT) & XS1_PORT_PAD_CTRL_SR_MASK))
///@}
/**
 * \name PORT_PAD_CTRL_SMT
 * \anchor PORT_PAD_CTRL_SMT
 * The pad control Schmitt trigger enable.
 */
///@{
#define XS1_PORT_PAD_CTRL_SMT_SHIFT 0x7
#define XS1_PORT_PAD_CTRL_SMT_SIZE 0x1
#define XS1_PORT_PAD_CTRL_SMT_MASK (((1 << XS1_PORT_PAD_CTRL_SMT_SIZE) - 1) << XS1_PORT_PAD_CTRL_SMT_SHIFT)
/**
 * Extract the PORT_PAD_CTRL_SMT bitfield from a packed word x and return it.
 */
#define XS1_PORT_PAD_CTRL_SMT(x) (((x) & XS1_PORT_PAD_CTRL_SMT_MASK) >> XS1_PORT_PAD_CTRL_SMT_SHIFT)
/**
 * Pack the value (v) of the PORT_PAD_CTRL_SMT bitfield into a packed word x and return the packed field.
 */
#define XS1_PORT_PAD_CTRL_SMT_SET(x, v) (((x) & ~XS1_PORT_PAD_CTRL_SMT_MASK) | (((v) << XS1_PORT_PAD_CTRL_SMT_SHIFT) & XS1_PORT_PAD_CTRL_SMT_MASK))
///@}
/**
 * \name TIMER_CTRL0_INUSE
 * \anchor TIMER_CTRL0_INUSE
 * Returns 1 when it in use, 0 otherwise.
 */
///@{
#define XS1_TIMER_CTRL0_INUSE_SHIFT 0x0
#define XS1_TIMER_CTRL0_INUSE_SIZE 0x1
#define XS1_TIMER_CTRL0_INUSE_MASK (((1 << XS1_TIMER_CTRL0_INUSE_SIZE) - 1) << XS1_TIMER_CTRL0_INUSE_SHIFT)
/**
 * Extract the TIMER_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_INUSE(x) (((x) & XS1_TIMER_CTRL0_INUSE_MASK) >> XS1_TIMER_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_INUSE_MASK) | (((v) << XS1_TIMER_CTRL0_INUSE_SHIFT) & XS1_TIMER_CTRL0_INUSE_MASK))
///@}
/**
 * \name TIMER_CTRL0_IE_MODE
 * \anchor TIMER_CTRL0_IE_MODE
 * 0 when this timer will cause events, 1 when it will raise interrupts. It is controlled using the ``SETC`` instruction.
 */
///@{
#define XS1_TIMER_CTRL0_IE_MODE_SHIFT 0x1
#define XS1_TIMER_CTRL0_IE_MODE_SIZE 0x1
#define XS1_TIMER_CTRL0_IE_MODE_MASK (((1 << XS1_TIMER_CTRL0_IE_MODE_SIZE) - 1) << XS1_TIMER_CTRL0_IE_MODE_SHIFT)
/**
 * Extract the TIMER_CTRL0_IE_MODE bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_IE_MODE(x) (((x) & XS1_TIMER_CTRL0_IE_MODE_MASK) >> XS1_TIMER_CTRL0_IE_MODE_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_IE_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_IE_MODE_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_IE_MODE_MASK) | (((v) << XS1_TIMER_CTRL0_IE_MODE_SHIFT) & XS1_TIMER_CTRL0_IE_MODE_MASK))
///@}
/**
 * \name TIMER_CTRL0_IE_ENABLED
 * \anchor TIMER_CTRL0_IE_ENABLED
 * 1 when events or interrupts on this timer are active. It is set when an ``EEU`` is executed. It is cleared when a ``EDU`` or ``CLRE`` is executed. The ``EET`` and ``EEF`` will either set or clear the bit depending on the contents of the condition register.
 */
///@{
#define XS1_TIMER_CTRL0_IE_ENABLED_SHIFT 0x2
#define XS1_TIMER_CTRL0_IE_ENABLED_SIZE 0x1
#define XS1_TIMER_CTRL0_IE_ENABLED_MASK (((1 << XS1_TIMER_CTRL0_IE_ENABLED_SIZE) - 1) << XS1_TIMER_CTRL0_IE_ENABLED_SHIFT)
/**
 * Extract the TIMER_CTRL0_IE_ENABLED bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_IE_ENABLED(x) (((x) & XS1_TIMER_CTRL0_IE_ENABLED_MASK) >> XS1_TIMER_CTRL0_IE_ENABLED_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_IE_ENABLED bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_IE_ENABLED_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_IE_ENABLED_MASK) | (((v) << XS1_TIMER_CTRL0_IE_ENABLED_SHIFT) & XS1_TIMER_CTRL0_IE_ENABLED_MASK))
///@}
/**
 * \name TIMER_CTRL0_READY
 * \anchor TIMER_CTRL0_READY
 * 1 when the condition has been met. It is cleared when a ``SETC``, ``SETD``, ``SETV``, ``SETC`` or ``IN`` instruction is executed on the timer. 0 when the timer is not in use.
 */
///@{
#define XS1_TIMER_CTRL0_READY_SHIFT 0x3
#define XS1_TIMER_CTRL0_READY_SIZE 0x1
#define XS1_TIMER_CTRL0_READY_MASK (((1 << XS1_TIMER_CTRL0_READY_SIZE) - 1) << XS1_TIMER_CTRL0_READY_SHIFT)
/**
 * Extract the TIMER_CTRL0_READY bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_READY(x) (((x) & XS1_TIMER_CTRL0_READY_MASK) >> XS1_TIMER_CTRL0_READY_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_READY bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_READY_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_READY_MASK) | (((v) << XS1_TIMER_CTRL0_READY_SHIFT) & XS1_TIMER_CTRL0_READY_MASK))
///@}
/**
 * \name TIMER_CTRL0_COND
 * \anchor TIMER_CTRL0_COND
 * Shows the current condition of the timer. The condition is set using the ``SETC`` instruction.
 */
///@{
#define XS1_TIMER_CTRL0_COND_SHIFT 0x4
#define XS1_TIMER_CTRL0_COND_SIZE 0x1
#define XS1_TIMER_CTRL0_COND_MASK (((1 << XS1_TIMER_CTRL0_COND_SIZE) - 1) << XS1_TIMER_CTRL0_COND_SHIFT)
/**
 * Extract the TIMER_CTRL0_COND bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_COND(x) (((x) & XS1_TIMER_CTRL0_COND_MASK) >> XS1_TIMER_CTRL0_COND_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_COND bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_COND_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_COND_MASK) | (((v) << XS1_TIMER_CTRL0_COND_SHIFT) & XS1_TIMER_CTRL0_COND_MASK))
///@}
/**
 * \name TIMER_CTRL0_EV_VALID
 * \anchor TIMER_CTRL0_EV_VALID
 * 1 when the Environment Vector is valid. When invalid, the resourceId is used as the environment vector. The environment vector is set using the ``SETEV`` instruction.
 */
///@{
#define XS1_TIMER_CTRL0_EV_VALID_SHIFT 0x8
#define XS1_TIMER_CTRL0_EV_VALID_SIZE 0x1
#define XS1_TIMER_CTRL0_EV_VALID_MASK (((1 << XS1_TIMER_CTRL0_EV_VALID_SIZE) - 1) << XS1_TIMER_CTRL0_EV_VALID_SHIFT)
/**
 * Extract the TIMER_CTRL0_EV_VALID bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_EV_VALID(x) (((x) & XS1_TIMER_CTRL0_EV_VALID_MASK) >> XS1_TIMER_CTRL0_EV_VALID_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_EV_VALID bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_EV_VALID_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_EV_VALID_MASK) | (((v) << XS1_TIMER_CTRL0_EV_VALID_SHIFT) & XS1_TIMER_CTRL0_EV_VALID_MASK))
///@}
/**
 * \name TIMER_CTRL0_T_WAITING
 * \anchor TIMER_CTRL0_T_WAITING
 * 1 when there is a thread waiting to be unblocked by this timer.
 */
///@{
#define XS1_TIMER_CTRL0_T_WAITING_SHIFT 0x17
#define XS1_TIMER_CTRL0_T_WAITING_SIZE 0x1
#define XS1_TIMER_CTRL0_T_WAITING_MASK (((1 << XS1_TIMER_CTRL0_T_WAITING_SIZE) - 1) << XS1_TIMER_CTRL0_T_WAITING_SHIFT)
/**
 * Extract the TIMER_CTRL0_T_WAITING bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_T_WAITING(x) (((x) & XS1_TIMER_CTRL0_T_WAITING_MASK) >> XS1_TIMER_CTRL0_T_WAITING_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_T_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_T_WAITING_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_T_WAITING_MASK) | (((v) << XS1_TIMER_CTRL0_T_WAITING_SHIFT) & XS1_TIMER_CTRL0_T_WAITING_MASK))
///@}
/**
 * \name TIMER_CTRL0_T_NUM
 * \anchor TIMER_CTRL0_T_NUM
 * Number of the thread waiting for events or to be unblocked by this timer.
 */
///@{
#define XS1_TIMER_CTRL0_T_NUM_SHIFT 0x18
#define XS1_TIMER_CTRL0_T_NUM_SIZE 0x8
#define XS1_TIMER_CTRL0_T_NUM_MASK (((1 << XS1_TIMER_CTRL0_T_NUM_SIZE) - 1) << XS1_TIMER_CTRL0_T_NUM_SHIFT)
/**
 * Extract the TIMER_CTRL0_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_TIMER_CTRL0_T_NUM(x) (((x) & XS1_TIMER_CTRL0_T_NUM_MASK) >> XS1_TIMER_CTRL0_T_NUM_SHIFT)
/**
 * Pack the value (v) of the TIMER_CTRL0_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_TIMER_CTRL0_T_NUM_SET(x, v) (((x) & ~XS1_TIMER_CTRL0_T_NUM_MASK) | (((v) << XS1_TIMER_CTRL0_T_NUM_SHIFT) & XS1_TIMER_CTRL0_T_NUM_MASK))
///@}
/**
 * \name SWMEM_CTRL0_INUSE
 * \anchor SWMEM_CTRL0_INUSE
 * Returns 1 when it in use, 0 otherwise.
 */
///@{
#define XS1_SWMEM_CTRL0_INUSE_SHIFT 0x0
#define XS1_SWMEM_CTRL0_INUSE_SIZE 0x1
#define XS1_SWMEM_CTRL0_INUSE_MASK (((1 << XS1_SWMEM_CTRL0_INUSE_SIZE) - 1) << XS1_SWMEM_CTRL0_INUSE_SHIFT)
/**
 * Extract the SWMEM_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_SWMEM_CTRL0_INUSE(x) (((x) & XS1_SWMEM_CTRL0_INUSE_MASK) >> XS1_SWMEM_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the SWMEM_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_SWMEM_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_SWMEM_CTRL0_INUSE_MASK) | (((v) << XS1_SWMEM_CTRL0_INUSE_SHIFT) & XS1_SWMEM_CTRL0_INUSE_MASK))
///@}
/**
 * \name SWMEM_CTRL0_IE_MODE
 * \anchor SWMEM_CTRL0_IE_MODE
 * 0 when this SWMEM resource will cause events, 1 when it will raise interrupts. It is controlled using the ``SETC`` instruction.
 */
///@{
#define XS1_SWMEM_CTRL0_IE_MODE_SHIFT 0x1
#define XS1_SWMEM_CTRL0_IE_MODE_SIZE 0x1
#define XS1_SWMEM_CTRL0_IE_MODE_MASK (((1 << XS1_SWMEM_CTRL0_IE_MODE_SIZE) - 1) << XS1_SWMEM_CTRL0_IE_MODE_SHIFT)
/**
 * Extract the SWMEM_CTRL0_IE_MODE bitfield from a packed word x and return it.
 */
#define XS1_SWMEM_CTRL0_IE_MODE(x) (((x) & XS1_SWMEM_CTRL0_IE_MODE_MASK) >> XS1_SWMEM_CTRL0_IE_MODE_SHIFT)
/**
 * Pack the value (v) of the SWMEM_CTRL0_IE_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_SWMEM_CTRL0_IE_MODE_SET(x, v) (((x) & ~XS1_SWMEM_CTRL0_IE_MODE_MASK) | (((v) << XS1_SWMEM_CTRL0_IE_MODE_SHIFT) & XS1_SWMEM_CTRL0_IE_MODE_MASK))
///@}
/**
 * \name SWMEM_CTRL0_IE_ENABLED
 * \anchor SWMEM_CTRL0_IE_ENABLED
 * 1 when events or interrupts on this SWMEM are active. It is set when an ``EEU`` is executed. It is cleared when a ``EDU`` or ``CLRE`` is executed. The ``EET`` and ``EEF`` will either set or clear the bit depending on the contents of the condition register.
 */
///@{
#define XS1_SWMEM_CTRL0_IE_ENABLED_SHIFT 0x2
#define XS1_SWMEM_CTRL0_IE_ENABLED_SIZE 0x1
#define XS1_SWMEM_CTRL0_IE_ENABLED_MASK (((1 << XS1_SWMEM_CTRL0_IE_ENABLED_SIZE) - 1) << XS1_SWMEM_CTRL0_IE_ENABLED_SHIFT)
/**
 * Extract the SWMEM_CTRL0_IE_ENABLED bitfield from a packed word x and return it.
 */
#define XS1_SWMEM_CTRL0_IE_ENABLED(x) (((x) & XS1_SWMEM_CTRL0_IE_ENABLED_MASK) >> XS1_SWMEM_CTRL0_IE_ENABLED_SHIFT)
/**
 * Pack the value (v) of the SWMEM_CTRL0_IE_ENABLED bitfield into a packed word x and return the packed field.
 */
#define XS1_SWMEM_CTRL0_IE_ENABLED_SET(x, v) (((x) & ~XS1_SWMEM_CTRL0_IE_ENABLED_MASK) | (((v) << XS1_SWMEM_CTRL0_IE_ENABLED_SHIFT) & XS1_SWMEM_CTRL0_IE_ENABLED_MASK))
///@}
/**
 * \name SWMEM_CTRL0_READY
 * \anchor SWMEM_CTRL0_READY
 * 1 when the condition has been met. It is cleared when a ``SETC``, ``SETD``, ``SETV``, ``SETC`` or ``IN`` instruction is executed on the SWMEM. 0 when the SWMEM is not in use.
 */
///@{
#define XS1_SWMEM_CTRL0_READY_SHIFT 0x3
#define XS1_SWMEM_CTRL0_READY_SIZE 0x1
#define XS1_SWMEM_CTRL0_READY_MASK (((1 << XS1_SWMEM_CTRL0_READY_SIZE) - 1) << XS1_SWMEM_CTRL0_READY_SHIFT)
/**
 * Extract the SWMEM_CTRL0_READY bitfield from a packed word x and return it.
 */
#define XS1_SWMEM_CTRL0_READY(x) (((x) & XS1_SWMEM_CTRL0_READY_MASK) >> XS1_SWMEM_CTRL0_READY_SHIFT)
/**
 * Pack the value (v) of the SWMEM_CTRL0_READY bitfield into a packed word x and return the packed field.
 */
#define XS1_SWMEM_CTRL0_READY_SET(x, v) (((x) & ~XS1_SWMEM_CTRL0_READY_MASK) | (((v) << XS1_SWMEM_CTRL0_READY_SHIFT) & XS1_SWMEM_CTRL0_READY_MASK))
///@}
/**
 * \name SWMEM_CTRL0_COND
 * \anchor SWMEM_CTRL0_COND
 * Shows the current condition of the SWMEM. The condition is set using the ``SETC`` instruction.
 */
///@{
#define XS1_SWMEM_CTRL0_COND_SHIFT 0x4
#define XS1_SWMEM_CTRL0_COND_SIZE 0x1
#define XS1_SWMEM_CTRL0_COND_MASK (((1 << XS1_SWMEM_CTRL0_COND_SIZE) - 1) << XS1_SWMEM_CTRL0_COND_SHIFT)
/**
 * Extract the SWMEM_CTRL0_COND bitfield from a packed word x and return it.
 */
#define XS1_SWMEM_CTRL0_COND(x) (((x) & XS1_SWMEM_CTRL0_COND_MASK) >> XS1_SWMEM_CTRL0_COND_SHIFT)
/**
 * Pack the value (v) of the SWMEM_CTRL0_COND bitfield into a packed word x and return the packed field.
 */
#define XS1_SWMEM_CTRL0_COND_SET(x, v) (((x) & ~XS1_SWMEM_CTRL0_COND_MASK) | (((v) << XS1_SWMEM_CTRL0_COND_SHIFT) & XS1_SWMEM_CTRL0_COND_MASK))
///@}
/**
 * \name SWMEM_CTRL0_EV_VALID
 * \anchor SWMEM_CTRL0_EV_VALID
 * 1 when the Environment Vector is valid. When invalid, the resourceId is used as the environment vector. The environment vector is set using the ``SETEV`` instruction.
 */
///@{
#define XS1_SWMEM_CTRL0_EV_VALID_SHIFT 0x8
#define XS1_SWMEM_CTRL0_EV_VALID_SIZE 0x1
#define XS1_SWMEM_CTRL0_EV_VALID_MASK (((1 << XS1_SWMEM_CTRL0_EV_VALID_SIZE) - 1) << XS1_SWMEM_CTRL0_EV_VALID_SHIFT)
/**
 * Extract the SWMEM_CTRL0_EV_VALID bitfield from a packed word x and return it.
 */
#define XS1_SWMEM_CTRL0_EV_VALID(x) (((x) & XS1_SWMEM_CTRL0_EV_VALID_MASK) >> XS1_SWMEM_CTRL0_EV_VALID_SHIFT)
/**
 * Pack the value (v) of the SWMEM_CTRL0_EV_VALID bitfield into a packed word x and return the packed field.
 */
#define XS1_SWMEM_CTRL0_EV_VALID_SET(x, v) (((x) & ~XS1_SWMEM_CTRL0_EV_VALID_MASK) | (((v) << XS1_SWMEM_CTRL0_EV_VALID_SHIFT) & XS1_SWMEM_CTRL0_EV_VALID_MASK))
///@}
/**
 * \name SWMEM_CTRL0_T_WAITING
 * \anchor SWMEM_CTRL0_T_WAITING
 * 1 when there is a thread waiting to be unblocked by this SWMEM.
 */
///@{
#define XS1_SWMEM_CTRL0_T_WAITING_SHIFT 0x17
#define XS1_SWMEM_CTRL0_T_WAITING_SIZE 0x1
#define XS1_SWMEM_CTRL0_T_WAITING_MASK (((1 << XS1_SWMEM_CTRL0_T_WAITING_SIZE) - 1) << XS1_SWMEM_CTRL0_T_WAITING_SHIFT)
/**
 * Extract the SWMEM_CTRL0_T_WAITING bitfield from a packed word x and return it.
 */
#define XS1_SWMEM_CTRL0_T_WAITING(x) (((x) & XS1_SWMEM_CTRL0_T_WAITING_MASK) >> XS1_SWMEM_CTRL0_T_WAITING_SHIFT)
/**
 * Pack the value (v) of the SWMEM_CTRL0_T_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_SWMEM_CTRL0_T_WAITING_SET(x, v) (((x) & ~XS1_SWMEM_CTRL0_T_WAITING_MASK) | (((v) << XS1_SWMEM_CTRL0_T_WAITING_SHIFT) & XS1_SWMEM_CTRL0_T_WAITING_MASK))
///@}
/**
 * \name SWMEM_CTRL0_T_NUM
 * \anchor SWMEM_CTRL0_T_NUM
 * Number of the thread waiting for events or to be unblocked by this SWMEM resource.
 */
///@{
#define XS1_SWMEM_CTRL0_T_NUM_SHIFT 0x18
#define XS1_SWMEM_CTRL0_T_NUM_SIZE 0x8
#define XS1_SWMEM_CTRL0_T_NUM_MASK (((1 << XS1_SWMEM_CTRL0_T_NUM_SIZE) - 1) << XS1_SWMEM_CTRL0_T_NUM_SHIFT)
/**
 * Extract the SWMEM_CTRL0_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_SWMEM_CTRL0_T_NUM(x) (((x) & XS1_SWMEM_CTRL0_T_NUM_MASK) >> XS1_SWMEM_CTRL0_T_NUM_SHIFT)
/**
 * Pack the value (v) of the SWMEM_CTRL0_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_SWMEM_CTRL0_T_NUM_SET(x, v) (((x) & ~XS1_SWMEM_CTRL0_T_NUM_MASK) | (((v) << XS1_SWMEM_CTRL0_T_NUM_SHIFT) & XS1_SWMEM_CTRL0_T_NUM_MASK))
///@}
/**
 * \name OTPA_MOSI_LSB
 * \anchor OTPA_MOSI_LSB
 * OTP arbiter MOSI LSB.
 */
///@{
#define XS1_OTPA_MOSI_LSB_SHIFT 0x0
#define XS1_OTPA_MOSI_LSB_SIZE 0x1
#define XS1_OTPA_MOSI_LSB_MASK (((1 << XS1_OTPA_MOSI_LSB_SIZE) - 1) << XS1_OTPA_MOSI_LSB_SHIFT)
/**
 * Extract the OTPA_MOSI_LSB bitfield from a packed word x and return it.
 */
#define XS1_OTPA_MOSI_LSB(x) (((x) & XS1_OTPA_MOSI_LSB_MASK) >> XS1_OTPA_MOSI_LSB_SHIFT)
/**
 * Pack the value (v) of the OTPA_MOSI_LSB bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_MOSI_LSB_SET(x, v) (((x) & ~XS1_OTPA_MOSI_LSB_MASK) | (((v) << XS1_OTPA_MOSI_LSB_SHIFT) & XS1_OTPA_MOSI_LSB_MASK))
///@}
/**
 * \name OTPA_MOSI_MSB
 * \anchor OTPA_MOSI_MSB
 * OTP arbiter MOSI LSB.
 */
///@{
#define XS1_OTPA_MOSI_MSB_SHIFT 0x7
#define XS1_OTPA_MOSI_MSB_SIZE 0x1
#define XS1_OTPA_MOSI_MSB_MASK (((1 << XS1_OTPA_MOSI_MSB_SIZE) - 1) << XS1_OTPA_MOSI_MSB_SHIFT)
/**
 * Extract the OTPA_MOSI_MSB bitfield from a packed word x and return it.
 */
#define XS1_OTPA_MOSI_MSB(x) (((x) & XS1_OTPA_MOSI_MSB_MASK) >> XS1_OTPA_MOSI_MSB_SHIFT)
/**
 * Pack the value (v) of the OTPA_MOSI_MSB bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_MOSI_MSB_SET(x, v) (((x) & ~XS1_OTPA_MOSI_MSB_MASK) | (((v) << XS1_OTPA_MOSI_MSB_SHIFT) & XS1_OTPA_MOSI_MSB_MASK))
///@}
/**
 * \name OTPA_CLK_IDX
 * \anchor OTPA_CLK_IDX
 * OTP SBPI CLK input.
 */
///@{
#define XS1_OTPA_CLK_IDX_SHIFT 0x8
#define XS1_OTPA_CLK_IDX_SIZE 0x1
#define XS1_OTPA_CLK_IDX_MASK (((1 << XS1_OTPA_CLK_IDX_SIZE) - 1) << XS1_OTPA_CLK_IDX_SHIFT)
/**
 * Extract the OTPA_CLK_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_CLK_IDX(x) (((x) & XS1_OTPA_CLK_IDX_MASK) >> XS1_OTPA_CLK_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_CLK_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_CLK_IDX_SET(x, v) (((x) & ~XS1_OTPA_CLK_IDX_MASK) | (((v) << XS1_OTPA_CLK_IDX_SHIFT) & XS1_OTPA_CLK_IDX_MASK))
///@}
/**
 * \name OTPA_SP_IDX
 * \anchor OTPA_SP_IDX
 * OTP SBPI SP input.
 */
///@{
#define XS1_OTPA_SP_IDX_SHIFT 0x9
#define XS1_OTPA_SP_IDX_SIZE 0x1
#define XS1_OTPA_SP_IDX_MASK (((1 << XS1_OTPA_SP_IDX_SIZE) - 1) << XS1_OTPA_SP_IDX_SHIFT)
/**
 * Extract the OTPA_SP_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_SP_IDX(x) (((x) & XS1_OTPA_SP_IDX_MASK) >> XS1_OTPA_SP_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_SP_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_SP_IDX_SET(x, v) (((x) & ~XS1_OTPA_SP_IDX_MASK) | (((v) << XS1_OTPA_SP_IDX_SHIFT) & XS1_OTPA_SP_IDX_MASK))
///@}
/**
 * \name OTPA_CS_IDX
 * \anchor OTPA_CS_IDX
 * OTP SBPI CS (chip select) input.
 */
///@{
#define XS1_OTPA_CS_IDX_SHIFT 0xa
#define XS1_OTPA_CS_IDX_SIZE 0x1
#define XS1_OTPA_CS_IDX_MASK (((1 << XS1_OTPA_CS_IDX_SIZE) - 1) << XS1_OTPA_CS_IDX_SHIFT)
/**
 * Extract the OTPA_CS_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_CS_IDX(x) (((x) & XS1_OTPA_CS_IDX_MASK) >> XS1_OTPA_CS_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_CS_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_CS_IDX_SET(x, v) (((x) & ~XS1_OTPA_CS_IDX_MASK) | (((v) << XS1_OTPA_CS_IDX_SHIFT) & XS1_OTPA_CS_IDX_MASK))
///@}
/**
 * \name OTPA_CKE_IDX
 * \anchor OTPA_CKE_IDX
 * OTP SBPI CKE (clock enable) input.
 */
///@{
#define XS1_OTPA_CKE_IDX_SHIFT 0xb
#define XS1_OTPA_CKE_IDX_SIZE 0x1
#define XS1_OTPA_CKE_IDX_MASK (((1 << XS1_OTPA_CKE_IDX_SIZE) - 1) << XS1_OTPA_CKE_IDX_SHIFT)
/**
 * Extract the OTPA_CKE_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_CKE_IDX(x) (((x) & XS1_OTPA_CKE_IDX_MASK) >> XS1_OTPA_CKE_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_CKE_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_CKE_IDX_SET(x, v) (((x) & ~XS1_OTPA_CKE_IDX_MASK) | (((v) << XS1_OTPA_CKE_IDX_SHIFT) & XS1_OTPA_CKE_IDX_MASK))
///@}
/**
 * \name OTPA_DCTRL_IDX
 * \anchor OTPA_DCTRL_IDX
 * OTP USER DCTRL input.
 */
///@{
#define XS1_OTPA_DCTRL_IDX_SHIFT 0xc
#define XS1_OTPA_DCTRL_IDX_SIZE 0x1
#define XS1_OTPA_DCTRL_IDX_MASK (((1 << XS1_OTPA_DCTRL_IDX_SIZE) - 1) << XS1_OTPA_DCTRL_IDX_SHIFT)
/**
 * Extract the OTPA_DCTRL_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_DCTRL_IDX(x) (((x) & XS1_OTPA_DCTRL_IDX_MASK) >> XS1_OTPA_DCTRL_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_DCTRL_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_DCTRL_IDX_SET(x, v) (((x) & ~XS1_OTPA_DCTRL_IDX_MASK) | (((v) << XS1_OTPA_DCTRL_IDX_SHIFT) & XS1_OTPA_DCTRL_IDX_MASK))
///@}
/**
 * \name OTPA_PD_IDX
 * \anchor OTPA_PD_IDX
 * OTP USER PD input.
 */
///@{
#define XS1_OTPA_PD_IDX_SHIFT 0xd
#define XS1_OTPA_PD_IDX_SIZE 0x1
#define XS1_OTPA_PD_IDX_MASK (((1 << XS1_OTPA_PD_IDX_SIZE) - 1) << XS1_OTPA_PD_IDX_SHIFT)
/**
 * Extract the OTPA_PD_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_PD_IDX(x) (((x) & XS1_OTPA_PD_IDX_MASK) >> XS1_OTPA_PD_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_PD_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_PD_IDX_SET(x, v) (((x) & ~XS1_OTPA_PD_IDX_MASK) | (((v) << XS1_OTPA_PD_IDX_SHIFT) & XS1_OTPA_PD_IDX_MASK))
///@}
/**
 * \name OTPA_SEL_IDX
 * \anchor OTPA_SEL_IDX
 * OTP USER SEL input.
 */
///@{
#define XS1_OTPA_SEL_IDX_SHIFT 0xe
#define XS1_OTPA_SEL_IDX_SIZE 0x1
#define XS1_OTPA_SEL_IDX_MASK (((1 << XS1_OTPA_SEL_IDX_SIZE) - 1) << XS1_OTPA_SEL_IDX_SHIFT)
/**
 * Extract the OTPA_SEL_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_SEL_IDX(x) (((x) & XS1_OTPA_SEL_IDX_MASK) >> XS1_OTPA_SEL_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_SEL_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_SEL_IDX_SET(x, v) (((x) & ~XS1_OTPA_SEL_IDX_MASK) | (((v) << XS1_OTPA_SEL_IDX_SHIFT) & XS1_OTPA_SEL_IDX_MASK))
///@}
/**
 * \name OTPA_CK_IDX
 * \anchor OTPA_CK_IDX
 * OTP USER CK input.
 */
///@{
#define XS1_OTPA_CK_IDX_SHIFT 0xf
#define XS1_OTPA_CK_IDX_SIZE 0x1
#define XS1_OTPA_CK_IDX_MASK (((1 << XS1_OTPA_CK_IDX_SIZE) - 1) << XS1_OTPA_CK_IDX_SHIFT)
/**
 * Extract the OTPA_CK_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_CK_IDX(x) (((x) & XS1_OTPA_CK_IDX_MASK) >> XS1_OTPA_CK_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_CK_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_CK_IDX_SET(x, v) (((x) & ~XS1_OTPA_CK_IDX_MASK) | (((v) << XS1_OTPA_CK_IDX_SHIFT) & XS1_OTPA_CK_IDX_MASK))
///@}
/**
 * \name OTPA_A_LSB
 * \anchor OTPA_A_LSB
 * OTP USER A (address) LSB (bit 0).
 */
///@{
#define XS1_OTPA_A_LSB_SHIFT 0x10
#define XS1_OTPA_A_LSB_SIZE 0x1
#define XS1_OTPA_A_LSB_MASK (((1 << XS1_OTPA_A_LSB_SIZE) - 1) << XS1_OTPA_A_LSB_SHIFT)
/**
 * Extract the OTPA_A_LSB bitfield from a packed word x and return it.
 */
#define XS1_OTPA_A_LSB(x) (((x) & XS1_OTPA_A_LSB_MASK) >> XS1_OTPA_A_LSB_SHIFT)
/**
 * Pack the value (v) of the OTPA_A_LSB bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_A_LSB_SET(x, v) (((x) & ~XS1_OTPA_A_LSB_MASK) | (((v) << XS1_OTPA_A_LSB_SHIFT) & XS1_OTPA_A_LSB_MASK))
///@}
/**
 * \name OTPA_A_MSB
 * \anchor OTPA_A_MSB
 * OTP USER A (address) MSB (bit 10).
 */
///@{
#define XS1_OTPA_A_MSB_SHIFT 0x1a
#define XS1_OTPA_A_MSB_SIZE 0x1
#define XS1_OTPA_A_MSB_MASK (((1 << XS1_OTPA_A_MSB_SIZE) - 1) << XS1_OTPA_A_MSB_SHIFT)
/**
 * Extract the OTPA_A_MSB bitfield from a packed word x and return it.
 */
#define XS1_OTPA_A_MSB(x) (((x) & XS1_OTPA_A_MSB_MASK) >> XS1_OTPA_A_MSB_SHIFT)
/**
 * Pack the value (v) of the OTPA_A_MSB bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_A_MSB_SET(x, v) (((x) & ~XS1_OTPA_A_MSB_MASK) | (((v) << XS1_OTPA_A_MSB_SHIFT) & XS1_OTPA_A_MSB_MASK))
///@}
/**
 * \name OTPA_RST_IDX
 * \anchor OTPA_RST_IDX
 * OTP reset input (active high)
 */
///@{
#define XS1_OTPA_RST_IDX_SHIFT 0x1b
#define XS1_OTPA_RST_IDX_SIZE 0x1
#define XS1_OTPA_RST_IDX_MASK (((1 << XS1_OTPA_RST_IDX_SIZE) - 1) << XS1_OTPA_RST_IDX_SHIFT)
/**
 * Extract the OTPA_RST_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_RST_IDX(x) (((x) & XS1_OTPA_RST_IDX_MASK) >> XS1_OTPA_RST_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_RST_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_RST_IDX_SET(x, v) (((x) & ~XS1_OTPA_RST_IDX_MASK) | (((v) << XS1_OTPA_RST_IDX_SHIFT) & XS1_OTPA_RST_IDX_MASK))
///@}
/**
 * \name OTPA_ARB_REQ_IDX
 * \anchor OTPA_ARB_REQ_IDX
 * OTP arbiter request
 */
///@{
#define XS1_OTPA_ARB_REQ_IDX_SHIFT 0x1c
#define XS1_OTPA_ARB_REQ_IDX_SIZE 0x1
#define XS1_OTPA_ARB_REQ_IDX_MASK (((1 << XS1_OTPA_ARB_REQ_IDX_SIZE) - 1) << XS1_OTPA_ARB_REQ_IDX_SHIFT)
/**
 * Extract the OTPA_ARB_REQ_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_ARB_REQ_IDX(x) (((x) & XS1_OTPA_ARB_REQ_IDX_MASK) >> XS1_OTPA_ARB_REQ_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_ARB_REQ_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_ARB_REQ_IDX_SET(x, v) (((x) & ~XS1_OTPA_ARB_REQ_IDX_MASK) | (((v) << XS1_OTPA_ARB_REQ_IDX_SHIFT) & XS1_OTPA_ARB_REQ_IDX_MASK))
///@}
/**
 * \name OTPA_MUXSEL_LSB
 * \anchor OTPA_MUXSEL_LSB
 * OTP mux select LSB
 */
///@{
#define XS1_OTPA_MUXSEL_LSB_SHIFT 0x1d
#define XS1_OTPA_MUXSEL_LSB_SIZE 0x1
#define XS1_OTPA_MUXSEL_LSB_MASK (((1 << XS1_OTPA_MUXSEL_LSB_SIZE) - 1) << XS1_OTPA_MUXSEL_LSB_SHIFT)
/**
 * Extract the OTPA_MUXSEL_LSB bitfield from a packed word x and return it.
 */
#define XS1_OTPA_MUXSEL_LSB(x) (((x) & XS1_OTPA_MUXSEL_LSB_MASK) >> XS1_OTPA_MUXSEL_LSB_SHIFT)
/**
 * Pack the value (v) of the OTPA_MUXSEL_LSB bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_MUXSEL_LSB_SET(x, v) (((x) & ~XS1_OTPA_MUXSEL_LSB_MASK) | (((v) << XS1_OTPA_MUXSEL_LSB_SHIFT) & XS1_OTPA_MUXSEL_LSB_MASK))
///@}
/**
 * \name OTPA_MUXSEL_MSB
 * \anchor OTPA_MUXSEL_MSB
 * OTP mux select MSB
 */
///@{
#define XS1_OTPA_MUXSEL_MSB_SHIFT 0x1f
#define XS1_OTPA_MUXSEL_MSB_SIZE 0x1
#define XS1_OTPA_MUXSEL_MSB_MASK (((1 << XS1_OTPA_MUXSEL_MSB_SIZE) - 1) << XS1_OTPA_MUXSEL_MSB_SHIFT)
/**
 * Extract the OTPA_MUXSEL_MSB bitfield from a packed word x and return it.
 */
#define XS1_OTPA_MUXSEL_MSB(x) (((x) & XS1_OTPA_MUXSEL_MSB_MASK) >> XS1_OTPA_MUXSEL_MSB_SHIFT)
/**
 * Pack the value (v) of the OTPA_MUXSEL_MSB bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_MUXSEL_MSB_SET(x, v) (((x) & ~XS1_OTPA_MUXSEL_MSB_MASK) | (((v) << XS1_OTPA_MUXSEL_MSB_SHIFT) & XS1_OTPA_MUXSEL_MSB_MASK))
///@}
/**
 * \name OTPA_MISO_LSB
 * \anchor OTPA_MISO_LSB
 * OTP arbiter MISO LSB.
 */
///@{
#define XS1_OTPA_MISO_LSB_SHIFT 0x0
#define XS1_OTPA_MISO_LSB_SIZE 0x1
#define XS1_OTPA_MISO_LSB_MASK (((1 << XS1_OTPA_MISO_LSB_SIZE) - 1) << XS1_OTPA_MISO_LSB_SHIFT)
/**
 * Extract the OTPA_MISO_LSB bitfield from a packed word x and return it.
 */
#define XS1_OTPA_MISO_LSB(x) (((x) & XS1_OTPA_MISO_LSB_MASK) >> XS1_OTPA_MISO_LSB_SHIFT)
/**
 * Pack the value (v) of the OTPA_MISO_LSB bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_MISO_LSB_SET(x, v) (((x) & ~XS1_OTPA_MISO_LSB_MASK) | (((v) << XS1_OTPA_MISO_LSB_SHIFT) & XS1_OTPA_MISO_LSB_MASK))
///@}
/**
 * \name OTPA_MISO_MSB
 * \anchor OTPA_MISO_MSB
 * OTP arbiter MISO LSB.
 */
///@{
#define XS1_OTPA_MISO_MSB_SHIFT 0x7
#define XS1_OTPA_MISO_MSB_SIZE 0x1
#define XS1_OTPA_MISO_MSB_MASK (((1 << XS1_OTPA_MISO_MSB_SIZE) - 1) << XS1_OTPA_MISO_MSB_SHIFT)
/**
 * Extract the OTPA_MISO_MSB bitfield from a packed word x and return it.
 */
#define XS1_OTPA_MISO_MSB(x) (((x) & XS1_OTPA_MISO_MSB_MASK) >> XS1_OTPA_MISO_MSB_SHIFT)
/**
 * Pack the value (v) of the OTPA_MISO_MSB bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_MISO_MSB_SET(x, v) (((x) & ~XS1_OTPA_MISO_MSB_MASK) | (((v) << XS1_OTPA_MISO_MSB_SHIFT) & XS1_OTPA_MISO_MSB_MASK))
///@}
/**
 * \name OTPA_FLAG_IDX
 * \anchor OTPA_FLAG_IDX
 * OTP SBPI flag status.
 */
///@{
#define XS1_OTPA_FLAG_IDX_SHIFT 0x8
#define XS1_OTPA_FLAG_IDX_SIZE 0x1
#define XS1_OTPA_FLAG_IDX_MASK (((1 << XS1_OTPA_FLAG_IDX_SIZE) - 1) << XS1_OTPA_FLAG_IDX_SHIFT)
/**
 * Extract the OTPA_FLAG_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_FLAG_IDX(x) (((x) & XS1_OTPA_FLAG_IDX_MASK) >> XS1_OTPA_FLAG_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_FLAG_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_FLAG_IDX_SET(x, v) (((x) & ~XS1_OTPA_FLAG_IDX_MASK) | (((v) << XS1_OTPA_FLAG_IDX_SHIFT) & XS1_OTPA_FLAG_IDX_MASK))
///@}
/**
 * \name OTPA_ARB_GNT_IDX
 * \anchor OTPA_ARB_GNT_IDX
 * OTP arbiter granted.
 */
///@{
#define XS1_OTPA_ARB_GNT_IDX_SHIFT 0x9
#define XS1_OTPA_ARB_GNT_IDX_SIZE 0x1
#define XS1_OTPA_ARB_GNT_IDX_MASK (((1 << XS1_OTPA_ARB_GNT_IDX_SIZE) - 1) << XS1_OTPA_ARB_GNT_IDX_SHIFT)
/**
 * Extract the OTPA_ARB_GNT_IDX bitfield from a packed word x and return it.
 */
#define XS1_OTPA_ARB_GNT_IDX(x) (((x) & XS1_OTPA_ARB_GNT_IDX_MASK) >> XS1_OTPA_ARB_GNT_IDX_SHIFT)
/**
 * Pack the value (v) of the OTPA_ARB_GNT_IDX bitfield into a packed word x and return the packed field.
 */
#define XS1_OTPA_ARB_GNT_IDX_SET(x, v) (((x) & ~XS1_OTPA_ARB_GNT_IDX_MASK) | (((v) << XS1_OTPA_ARB_GNT_IDX_SHIFT) & XS1_OTPA_ARB_GNT_IDX_MASK))
///@}
/**
 * \name OTP_DAP_RFMR_MR_4
 * \anchor OTP_DAP_RFMR_MR_4
 * OTP DAP RFMR register MR_4 control.
 */
///@{
#define XS1_OTP_DAP_RFMR_MR_4_SHIFT 0x5
#define XS1_OTP_DAP_RFMR_MR_4_SIZE 0x1
#define XS1_OTP_DAP_RFMR_MR_4_MASK (((1 << XS1_OTP_DAP_RFMR_MR_4_SIZE) - 1) << XS1_OTP_DAP_RFMR_MR_4_SHIFT)
/**
 * Extract the OTP_DAP_RFMR_MR_4 bitfield from a packed word x and return it.
 */
#define XS1_OTP_DAP_RFMR_MR_4(x) (((x) & XS1_OTP_DAP_RFMR_MR_4_MASK) >> XS1_OTP_DAP_RFMR_MR_4_SHIFT)
/**
 * Pack the value (v) of the OTP_DAP_RFMR_MR_4 bitfield into a packed word x and return the packed field.
 */
#define XS1_OTP_DAP_RFMR_MR_4_SET(x, v) (((x) & ~XS1_OTP_DAP_RFMR_MR_4_MASK) | (((v) << XS1_OTP_DAP_RFMR_MR_4_SHIFT) & XS1_OTP_DAP_RFMR_MR_4_MASK))
///@}
/**
 * \name OTP_DAP_RFMR_MR_5
 * \anchor OTP_DAP_RFMR_MR_5
 * OTP DAP RFMR register MR_5 control.
 */
///@{
#define XS1_OTP_DAP_RFMR_MR_5_SHIFT 0x6
#define XS1_OTP_DAP_RFMR_MR_5_SIZE 0x1
#define XS1_OTP_DAP_RFMR_MR_5_MASK (((1 << XS1_OTP_DAP_RFMR_MR_5_SIZE) - 1) << XS1_OTP_DAP_RFMR_MR_5_SHIFT)
/**
 * Extract the OTP_DAP_RFMR_MR_5 bitfield from a packed word x and return it.
 */
#define XS1_OTP_DAP_RFMR_MR_5(x) (((x) & XS1_OTP_DAP_RFMR_MR_5_MASK) >> XS1_OTP_DAP_RFMR_MR_5_SHIFT)
/**
 * Pack the value (v) of the OTP_DAP_RFMR_MR_5 bitfield into a packed word x and return the packed field.
 */
#define XS1_OTP_DAP_RFMR_MR_5_SET(x, v) (((x) & ~XS1_OTP_DAP_RFMR_MR_5_MASK) | (((v) << XS1_OTP_DAP_RFMR_MR_5_SHIFT) & XS1_OTP_DAP_RFMR_MR_5_MASK))
///@}
/**
 * \name SYNC_CTRL0_INUSE
 * \anchor SYNC_CTRL0_INUSE
 * 1 when the synchroniser is in use.
 */
///@{
#define XS1_SYNC_CTRL0_INUSE_SHIFT 0x0
#define XS1_SYNC_CTRL0_INUSE_SIZE 0x1
#define XS1_SYNC_CTRL0_INUSE_MASK (((1 << XS1_SYNC_CTRL0_INUSE_SIZE) - 1) << XS1_SYNC_CTRL0_INUSE_SHIFT)
/**
 * Extract the SYNC_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_SYNC_CTRL0_INUSE(x) (((x) & XS1_SYNC_CTRL0_INUSE_MASK) >> XS1_SYNC_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the SYNC_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_SYNC_CTRL0_INUSE_MASK) | (((v) << XS1_SYNC_CTRL0_INUSE_SHIFT) & XS1_SYNC_CTRL0_INUSE_MASK))
///@}
/**
 * \name SYNC_CTRL0_MSYNCED
 * \anchor SYNC_CTRL0_MSYNCED
 * 1 when the master of this synchroniser has msynced on it.
 */
///@{
#define XS1_SYNC_CTRL0_MSYNCED_SHIFT 0x1
#define XS1_SYNC_CTRL0_MSYNCED_SIZE 0x1
#define XS1_SYNC_CTRL0_MSYNCED_MASK (((1 << XS1_SYNC_CTRL0_MSYNCED_SIZE) - 1) << XS1_SYNC_CTRL0_MSYNCED_SHIFT)
/**
 * Extract the SYNC_CTRL0_MSYNCED bitfield from a packed word x and return it.
 */
#define XS1_SYNC_CTRL0_MSYNCED(x) (((x) & XS1_SYNC_CTRL0_MSYNCED_MASK) >> XS1_SYNC_CTRL0_MSYNCED_SHIFT)
/**
 * Pack the value (v) of the SYNC_CTRL0_MSYNCED bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_CTRL0_MSYNCED_SET(x, v) (((x) & ~XS1_SYNC_CTRL0_MSYNCED_MASK) | (((v) << XS1_SYNC_CTRL0_MSYNCED_SHIFT) & XS1_SYNC_CTRL0_MSYNCED_MASK))
///@}
/**
 * \name SYNC_CTRL0_JOIN
 * \anchor SYNC_CTRL0_JOIN
 * 1 when the synchroniser will free the threads after synchronisation. 0 otherwise.
 */
///@{
#define XS1_SYNC_CTRL0_JOIN_SHIFT 0x2
#define XS1_SYNC_CTRL0_JOIN_SIZE 0x1
#define XS1_SYNC_CTRL0_JOIN_MASK (((1 << XS1_SYNC_CTRL0_JOIN_SIZE) - 1) << XS1_SYNC_CTRL0_JOIN_SHIFT)
/**
 * Extract the SYNC_CTRL0_JOIN bitfield from a packed word x and return it.
 */
#define XS1_SYNC_CTRL0_JOIN(x) (((x) & XS1_SYNC_CTRL0_JOIN_MASK) >> XS1_SYNC_CTRL0_JOIN_SHIFT)
/**
 * Pack the value (v) of the SYNC_CTRL0_JOIN bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_CTRL0_JOIN_SET(x, v) (((x) & ~XS1_SYNC_CTRL0_JOIN_MASK) | (((v) << XS1_SYNC_CTRL0_JOIN_SHIFT) & XS1_SYNC_CTRL0_JOIN_MASK))
///@}
/**
 * \name SYNC_CTRL0_MASTER
 * \anchor SYNC_CTRL0_MASTER
 * When synchroniser is in use it is the ID of the master thread. 0 when not in use.
 */
///@{
#define XS1_SYNC_CTRL0_MASTER_SHIFT 0x8
#define XS1_SYNC_CTRL0_MASTER_SIZE 0x8
#define XS1_SYNC_CTRL0_MASTER_MASK (((1 << XS1_SYNC_CTRL0_MASTER_SIZE) - 1) << XS1_SYNC_CTRL0_MASTER_SHIFT)
/**
 * Extract the SYNC_CTRL0_MASTER bitfield from a packed word x and return it.
 */
#define XS1_SYNC_CTRL0_MASTER(x) (((x) & XS1_SYNC_CTRL0_MASTER_MASK) >> XS1_SYNC_CTRL0_MASTER_SHIFT)
/**
 * Pack the value (v) of the SYNC_CTRL0_MASTER bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_CTRL0_MASTER_SET(x, v) (((x) & ~XS1_SYNC_CTRL0_MASTER_MASK) | (((v) << XS1_SYNC_CTRL0_MASTER_SHIFT) & XS1_SYNC_CTRL0_MASTER_MASK))
///@}
/**
 * \name SYNC_TBV0_SLAVES
 * \anchor SYNC_TBV0_SLAVES
 * 1 bit for each of the threads. When 1 indicates that the corresponding thread is attached to the synchroniser.
 */
///@{
#define XS1_SYNC_TBV0_SLAVES_SHIFT 0x0
#define XS1_SYNC_TBV0_SLAVES_SIZE 0x8
#define XS1_SYNC_TBV0_SLAVES_MASK (((1 << XS1_SYNC_TBV0_SLAVES_SIZE) - 1) << XS1_SYNC_TBV0_SLAVES_SHIFT)
/**
 * Extract the SYNC_TBV0_SLAVES bitfield from a packed word x and return it.
 */
#define XS1_SYNC_TBV0_SLAVES(x) (((x) & XS1_SYNC_TBV0_SLAVES_MASK) >> XS1_SYNC_TBV0_SLAVES_SHIFT)
/**
 * Pack the value (v) of the SYNC_TBV0_SLAVES bitfield into a packed word x and return the packed field.
 */
#define XS1_SYNC_TBV0_SLAVES_SET(x, v) (((x) & ~XS1_SYNC_TBV0_SLAVES_MASK) | (((v) << XS1_SYNC_TBV0_SLAVES_SHIFT) & XS1_SYNC_TBV0_SLAVES_MASK))
///@}
/**
 * \name LOCK_CTRL0_INUSE
 * \anchor LOCK_CTRL0_INUSE
 * 1 when the lock is in use.
 */
///@{
#define XS1_LOCK_CTRL0_INUSE_SHIFT 0x0
#define XS1_LOCK_CTRL0_INUSE_SIZE 0x1
#define XS1_LOCK_CTRL0_INUSE_MASK (((1 << XS1_LOCK_CTRL0_INUSE_SIZE) - 1) << XS1_LOCK_CTRL0_INUSE_SHIFT)
/**
 * Extract the LOCK_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_LOCK_CTRL0_INUSE(x) (((x) & XS1_LOCK_CTRL0_INUSE_MASK) >> XS1_LOCK_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the LOCK_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_LOCK_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_LOCK_CTRL0_INUSE_MASK) | (((v) << XS1_LOCK_CTRL0_INUSE_SHIFT) & XS1_LOCK_CTRL0_INUSE_MASK))
///@}
/**
 * \name LOCK_CTRL0_OWNT_V
 * \anchor LOCK_CTRL0_OWNT_V
 * Indicates that the lock's owner is known.
 */
///@{
#define XS1_LOCK_CTRL0_OWNT_V_SHIFT 0x1
#define XS1_LOCK_CTRL0_OWNT_V_SIZE 0x1
#define XS1_LOCK_CTRL0_OWNT_V_MASK (((1 << XS1_LOCK_CTRL0_OWNT_V_SIZE) - 1) << XS1_LOCK_CTRL0_OWNT_V_SHIFT)
/**
 * Extract the LOCK_CTRL0_OWNT_V bitfield from a packed word x and return it.
 */
#define XS1_LOCK_CTRL0_OWNT_V(x) (((x) & XS1_LOCK_CTRL0_OWNT_V_MASK) >> XS1_LOCK_CTRL0_OWNT_V_SHIFT)
/**
 * Pack the value (v) of the LOCK_CTRL0_OWNT_V bitfield into a packed word x and return the packed field.
 */
#define XS1_LOCK_CTRL0_OWNT_V_SET(x, v) (((x) & ~XS1_LOCK_CTRL0_OWNT_V_MASK) | (((v) << XS1_LOCK_CTRL0_OWNT_V_SHIFT) & XS1_LOCK_CTRL0_OWNT_V_MASK))
///@}
/**
 * \name LOCK_CTRL0_OWNT
 * \anchor LOCK_CTRL0_OWNT
 * When OWNT_V is true then this is the ID of the thread currently holding the lock.
 */
///@{
#define XS1_LOCK_CTRL0_OWNT_SHIFT 0x8
#define XS1_LOCK_CTRL0_OWNT_SIZE 0x8
#define XS1_LOCK_CTRL0_OWNT_MASK (((1 << XS1_LOCK_CTRL0_OWNT_SIZE) - 1) << XS1_LOCK_CTRL0_OWNT_SHIFT)
/**
 * Extract the LOCK_CTRL0_OWNT bitfield from a packed word x and return it.
 */
#define XS1_LOCK_CTRL0_OWNT(x) (((x) & XS1_LOCK_CTRL0_OWNT_MASK) >> XS1_LOCK_CTRL0_OWNT_SHIFT)
/**
 * Pack the value (v) of the LOCK_CTRL0_OWNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LOCK_CTRL0_OWNT_SET(x, v) (((x) & ~XS1_LOCK_CTRL0_OWNT_MASK) | (((v) << XS1_LOCK_CTRL0_OWNT_SHIFT) & XS1_LOCK_CTRL0_OWNT_MASK))
///@}
/**
 * \name LOCK_TBV0_WAITING
 * \anchor LOCK_TBV0_WAITING
 * 1 bit for each of the threads. When 1 indicates that the corresponding thread is waiting for the lock.
 */
///@{
#define XS1_LOCK_TBV0_WAITING_SHIFT 0x0
#define XS1_LOCK_TBV0_WAITING_SIZE 0x8
#define XS1_LOCK_TBV0_WAITING_MASK (((1 << XS1_LOCK_TBV0_WAITING_SIZE) - 1) << XS1_LOCK_TBV0_WAITING_SHIFT)
/**
 * Extract the LOCK_TBV0_WAITING bitfield from a packed word x and return it.
 */
#define XS1_LOCK_TBV0_WAITING(x) (((x) & XS1_LOCK_TBV0_WAITING_MASK) >> XS1_LOCK_TBV0_WAITING_SHIFT)
/**
 * Pack the value (v) of the LOCK_TBV0_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_LOCK_TBV0_WAITING_SET(x, v) (((x) & ~XS1_LOCK_TBV0_WAITING_MASK) | (((v) << XS1_LOCK_TBV0_WAITING_SHIFT) & XS1_LOCK_TBV0_WAITING_MASK))
///@}
/**
 * \name MMAP_CTRL0_INUSE
 * \anchor MMAP_CTRL0_INUSE
 * .
 */
///@{
#define XS1_MMAP_CTRL0_INUSE_SHIFT 0x0
#define XS1_MMAP_CTRL0_INUSE_SIZE 0x1
#define XS1_MMAP_CTRL0_INUSE_MASK (((1 << XS1_MMAP_CTRL0_INUSE_SIZE) - 1) << XS1_MMAP_CTRL0_INUSE_SHIFT)
/**
 * Extract the MMAP_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_INUSE(x) (((x) & XS1_MMAP_CTRL0_INUSE_MASK) >> XS1_MMAP_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_INUSE_MASK) | (((v) << XS1_MMAP_CTRL0_INUSE_SHIFT) & XS1_MMAP_CTRL0_INUSE_MASK))
///@}
/**
 * \name MMAP_CTRL0_RO
 * \anchor MMAP_CTRL0_RO
 * .
 */
///@{
#define XS1_MMAP_CTRL0_RO_SHIFT 0x1
#define XS1_MMAP_CTRL0_RO_SIZE 0x1
#define XS1_MMAP_CTRL0_RO_MASK (((1 << XS1_MMAP_CTRL0_RO_SIZE) - 1) << XS1_MMAP_CTRL0_RO_SHIFT)
/**
 * Extract the MMAP_CTRL0_RO bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_RO(x) (((x) & XS1_MMAP_CTRL0_RO_MASK) >> XS1_MMAP_CTRL0_RO_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_RO bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_RO_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_RO_MASK) | (((v) << XS1_MMAP_CTRL0_RO_SHIFT) & XS1_MMAP_CTRL0_RO_MASK))
///@}
/**
 * \name MMAP_CTRL0_LOCK
 * \anchor MMAP_CTRL0_LOCK
 * .
 */
///@{
#define XS1_MMAP_CTRL0_LOCK_SHIFT 0x2
#define XS1_MMAP_CTRL0_LOCK_SIZE 0x1
#define XS1_MMAP_CTRL0_LOCK_MASK (((1 << XS1_MMAP_CTRL0_LOCK_SIZE) - 1) << XS1_MMAP_CTRL0_LOCK_SHIFT)
/**
 * Extract the MMAP_CTRL0_LOCK bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_LOCK(x) (((x) & XS1_MMAP_CTRL0_LOCK_MASK) >> XS1_MMAP_CTRL0_LOCK_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_LOCK bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_LOCK_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_LOCK_MASK) | (((v) << XS1_MMAP_CTRL0_LOCK_SHIFT) & XS1_MMAP_CTRL0_LOCK_MASK))
///@}
/**
 * \name MMAP_CTRL0_GLOBAL
 * \anchor MMAP_CTRL0_GLOBAL
 * .
 */
///@{
#define XS1_MMAP_CTRL0_GLOBAL_SHIFT 0x3
#define XS1_MMAP_CTRL0_GLOBAL_SIZE 0x1
#define XS1_MMAP_CTRL0_GLOBAL_MASK (((1 << XS1_MMAP_CTRL0_GLOBAL_SIZE) - 1) << XS1_MMAP_CTRL0_GLOBAL_SHIFT)
/**
 * Extract the MMAP_CTRL0_GLOBAL bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_GLOBAL(x) (((x) & XS1_MMAP_CTRL0_GLOBAL_MASK) >> XS1_MMAP_CTRL0_GLOBAL_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_GLOBAL bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_GLOBAL_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_GLOBAL_MASK) | (((v) << XS1_MMAP_CTRL0_GLOBAL_SHIFT) & XS1_MMAP_CTRL0_GLOBAL_MASK))
///@}
/**
 * \name MMAP_CTRL0_ASID
 * \anchor MMAP_CTRL0_ASID
 * .
 */
///@{
#define XS1_MMAP_CTRL0_ASID_SHIFT 0x4
#define XS1_MMAP_CTRL0_ASID_SIZE 0x2
#define XS1_MMAP_CTRL0_ASID_MASK (((1 << XS1_MMAP_CTRL0_ASID_SIZE) - 1) << XS1_MMAP_CTRL0_ASID_SHIFT)
/**
 * Extract the MMAP_CTRL0_ASID bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_ASID(x) (((x) & XS1_MMAP_CTRL0_ASID_MASK) >> XS1_MMAP_CTRL0_ASID_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_ASID bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_ASID_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_ASID_MASK) | (((v) << XS1_MMAP_CTRL0_ASID_SHIFT) & XS1_MMAP_CTRL0_ASID_MASK))
///@}
/**
 * \name MMAP_CTRL0_LENGTH
 * \anchor MMAP_CTRL0_LENGTH
 * .
 */
///@{
#define XS1_MMAP_CTRL0_LENGTH_SHIFT 0x6
#define XS1_MMAP_CTRL0_LENGTH_SIZE 0x2
#define XS1_MMAP_CTRL0_LENGTH_MASK (((1 << XS1_MMAP_CTRL0_LENGTH_SIZE) - 1) << XS1_MMAP_CTRL0_LENGTH_SHIFT)
/**
 * Extract the MMAP_CTRL0_LENGTH bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_LENGTH(x) (((x) & XS1_MMAP_CTRL0_LENGTH_MASK) >> XS1_MMAP_CTRL0_LENGTH_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_LENGTH bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_LENGTH_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_LENGTH_MASK) | (((v) << XS1_MMAP_CTRL0_LENGTH_SHIFT) & XS1_MMAP_CTRL0_LENGTH_MASK))
///@}
/**
 * \name MMAP_CTRL0_PHY_ADDR
 * \anchor MMAP_CTRL0_PHY_ADDR
 * .
 */
///@{
#define XS1_MMAP_CTRL0_PHY_ADDR_SHIFT 0x8
#define XS1_MMAP_CTRL0_PHY_ADDR_SIZE 0x18
#define XS1_MMAP_CTRL0_PHY_ADDR_MASK (((1 << XS1_MMAP_CTRL0_PHY_ADDR_SIZE) - 1) << XS1_MMAP_CTRL0_PHY_ADDR_SHIFT)
/**
 * Extract the MMAP_CTRL0_PHY_ADDR bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL0_PHY_ADDR(x) (((x) & XS1_MMAP_CTRL0_PHY_ADDR_MASK) >> XS1_MMAP_CTRL0_PHY_ADDR_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL0_PHY_ADDR bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL0_PHY_ADDR_SET(x, v) (((x) & ~XS1_MMAP_CTRL0_PHY_ADDR_MASK) | (((v) << XS1_MMAP_CTRL0_PHY_ADDR_SHIFT) & XS1_MMAP_CTRL0_PHY_ADDR_MASK))
///@}
/**
 * \name MMAP_CTRL1_THREADS_EN
 * \anchor MMAP_CTRL1_THREADS_EN
 * .
 */
///@{
#define XS1_MMAP_CTRL1_THREADS_EN_SHIFT 0x0
#define XS1_MMAP_CTRL1_THREADS_EN_SIZE 0x8
#define XS1_MMAP_CTRL1_THREADS_EN_MASK (((1 << XS1_MMAP_CTRL1_THREADS_EN_SIZE) - 1) << XS1_MMAP_CTRL1_THREADS_EN_SHIFT)
/**
 * Extract the MMAP_CTRL1_THREADS_EN bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL1_THREADS_EN(x) (((x) & XS1_MMAP_CTRL1_THREADS_EN_MASK) >> XS1_MMAP_CTRL1_THREADS_EN_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL1_THREADS_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL1_THREADS_EN_SET(x, v) (((x) & ~XS1_MMAP_CTRL1_THREADS_EN_MASK) | (((v) << XS1_MMAP_CTRL1_THREADS_EN_SHIFT) & XS1_MMAP_CTRL1_THREADS_EN_MASK))
///@}
/**
 * \name MMAP_CTRL1_VIRT_ADDR
 * \anchor MMAP_CTRL1_VIRT_ADDR
 * .
 */
///@{
#define XS1_MMAP_CTRL1_VIRT_ADDR_SHIFT 0x8
#define XS1_MMAP_CTRL1_VIRT_ADDR_SIZE 0x18
#define XS1_MMAP_CTRL1_VIRT_ADDR_MASK (((1 << XS1_MMAP_CTRL1_VIRT_ADDR_SIZE) - 1) << XS1_MMAP_CTRL1_VIRT_ADDR_SHIFT)
/**
 * Extract the MMAP_CTRL1_VIRT_ADDR bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL1_VIRT_ADDR(x) (((x) & XS1_MMAP_CTRL1_VIRT_ADDR_MASK) >> XS1_MMAP_CTRL1_VIRT_ADDR_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL1_VIRT_ADDR bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL1_VIRT_ADDR_SET(x, v) (((x) & ~XS1_MMAP_CTRL1_VIRT_ADDR_MASK) | (((v) << XS1_MMAP_CTRL1_VIRT_ADDR_SHIFT) & XS1_MMAP_CTRL1_VIRT_ADDR_MASK))
///@}
/**
 * \name MMAP_CTRL2_AGE
 * \anchor MMAP_CTRL2_AGE
 * .
 */
///@{
#define XS1_MMAP_CTRL2_AGE_SHIFT 0x0
#define XS1_MMAP_CTRL2_AGE_SIZE 0x6
#define XS1_MMAP_CTRL2_AGE_MASK (((1 << XS1_MMAP_CTRL2_AGE_SIZE) - 1) << XS1_MMAP_CTRL2_AGE_SHIFT)
/**
 * Extract the MMAP_CTRL2_AGE bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL2_AGE(x) (((x) & XS1_MMAP_CTRL2_AGE_MASK) >> XS1_MMAP_CTRL2_AGE_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL2_AGE bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL2_AGE_SET(x, v) (((x) & ~XS1_MMAP_CTRL2_AGE_MASK) | (((v) << XS1_MMAP_CTRL2_AGE_SHIFT) & XS1_MMAP_CTRL2_AGE_MASK))
///@}
/**
 * \name MMAP_CTRL2_OWNER
 * \anchor MMAP_CTRL2_OWNER
 * .
 */
///@{
#define XS1_MMAP_CTRL2_OWNER_SHIFT 0x6
#define XS1_MMAP_CTRL2_OWNER_SIZE 0x8
#define XS1_MMAP_CTRL2_OWNER_MASK (((1 << XS1_MMAP_CTRL2_OWNER_SIZE) - 1) << XS1_MMAP_CTRL2_OWNER_SHIFT)
/**
 * Extract the MMAP_CTRL2_OWNER bitfield from a packed word x and return it.
 */
#define XS1_MMAP_CTRL2_OWNER(x) (((x) & XS1_MMAP_CTRL2_OWNER_MASK) >> XS1_MMAP_CTRL2_OWNER_SHIFT)
/**
 * Pack the value (v) of the MMAP_CTRL2_OWNER bitfield into a packed word x and return the packed field.
 */
#define XS1_MMAP_CTRL2_OWNER_SET(x, v) (((x) & ~XS1_MMAP_CTRL2_OWNER_MASK) | (((v) << XS1_MMAP_CTRL2_OWNER_SHIFT) & XS1_MMAP_CTRL2_OWNER_MASK))
///@}
/**
 * \name CHANEND_CTRL0_INUSE
 * \anchor CHANEND_CTRL0_INUSE
 * 1 when the channel end is in use.
 */
///@{
#define XS1_CHANEND_CTRL0_INUSE_SHIFT 0x0
#define XS1_CHANEND_CTRL0_INUSE_SIZE 0x1
#define XS1_CHANEND_CTRL0_INUSE_MASK (((1 << XS1_CHANEND_CTRL0_INUSE_SIZE) - 1) << XS1_CHANEND_CTRL0_INUSE_SHIFT)
/**
 * Extract the CHANEND_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_INUSE(x) (((x) & XS1_CHANEND_CTRL0_INUSE_MASK) >> XS1_CHANEND_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_INUSE_MASK) | (((v) << XS1_CHANEND_CTRL0_INUSE_SHIFT) & XS1_CHANEND_CTRL0_INUSE_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IE_MODE
 * \anchor CHANEND_CTRL0_IE_MODE
 * 0 when the channel end will cause events, 1 when in use and it will raise interrupts.
 */
///@{
#define XS1_CHANEND_CTRL0_IE_MODE_SHIFT 0x1
#define XS1_CHANEND_CTRL0_IE_MODE_SIZE 0x1
#define XS1_CHANEND_CTRL0_IE_MODE_MASK (((1 << XS1_CHANEND_CTRL0_IE_MODE_SIZE) - 1) << XS1_CHANEND_CTRL0_IE_MODE_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IE_MODE bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IE_MODE(x) (((x) & XS1_CHANEND_CTRL0_IE_MODE_MASK) >> XS1_CHANEND_CTRL0_IE_MODE_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IE_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IE_MODE_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IE_MODE_MASK) | (((v) << XS1_CHANEND_CTRL0_IE_MODE_SHIFT) & XS1_CHANEND_CTRL0_IE_MODE_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IE_ENABLED
 * \anchor CHANEND_CTRL0_IE_ENABLED
 * 1 when events or interrupts are enabled on the channel end.
 */
///@{
#define XS1_CHANEND_CTRL0_IE_ENABLED_SHIFT 0x2
#define XS1_CHANEND_CTRL0_IE_ENABLED_SIZE 0x1
#define XS1_CHANEND_CTRL0_IE_ENABLED_MASK (((1 << XS1_CHANEND_CTRL0_IE_ENABLED_SIZE) - 1) << XS1_CHANEND_CTRL0_IE_ENABLED_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IE_ENABLED bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IE_ENABLED(x) (((x) & XS1_CHANEND_CTRL0_IE_ENABLED_MASK) >> XS1_CHANEND_CTRL0_IE_ENABLED_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IE_ENABLED bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IE_ENABLED_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IE_ENABLED_MASK) | (((v) << XS1_CHANEND_CTRL0_IE_ENABLED_SHIFT) & XS1_CHANEND_CTRL0_IE_ENABLED_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IN_READY
 * \anchor CHANEND_CTRL0_IN_READY
 * 1 when in use and there is sufficient data in the channel end for a token to be input by a thread.
 */
///@{
#define XS1_CHANEND_CTRL0_IN_READY_SHIFT 0x4
#define XS1_CHANEND_CTRL0_IN_READY_SIZE 0x1
#define XS1_CHANEND_CTRL0_IN_READY_MASK (((1 << XS1_CHANEND_CTRL0_IN_READY_SIZE) - 1) << XS1_CHANEND_CTRL0_IN_READY_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IN_READY bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IN_READY(x) (((x) & XS1_CHANEND_CTRL0_IN_READY_MASK) >> XS1_CHANEND_CTRL0_IN_READY_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IN_READY bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IN_READY_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IN_READY_MASK) | (((v) << XS1_CHANEND_CTRL0_IN_READY_SHIFT) & XS1_CHANEND_CTRL0_IN_READY_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IN_WAITING
 * \anchor CHANEND_CTRL0_IN_WAITING
 * 1 when the input thread is waiting either for data or for an event.
 */
///@{
#define XS1_CHANEND_CTRL0_IN_WAITING_SHIFT 0x5
#define XS1_CHANEND_CTRL0_IN_WAITING_SIZE 0x1
#define XS1_CHANEND_CTRL0_IN_WAITING_MASK (((1 << XS1_CHANEND_CTRL0_IN_WAITING_SIZE) - 1) << XS1_CHANEND_CTRL0_IN_WAITING_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IN_WAITING bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IN_WAITING(x) (((x) & XS1_CHANEND_CTRL0_IN_WAITING_MASK) >> XS1_CHANEND_CTRL0_IN_WAITING_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IN_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IN_WAITING_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IN_WAITING_MASK) | (((v) << XS1_CHANEND_CTRL0_IN_WAITING_SHIFT) & XS1_CHANEND_CTRL0_IN_WAITING_MASK))
///@}
/**
 * \name CHANEND_CTRL0_OUT_READY
 * \anchor CHANEND_CTRL0_OUT_READY
 * 1 when in use and either not connected or there is sufficient room in the target channel end for a token to be ouptut by a thread. Will be 0 when requesting a link but not yet connected.
 */
///@{
#define XS1_CHANEND_CTRL0_OUT_READY_SHIFT 0x6
#define XS1_CHANEND_CTRL0_OUT_READY_SIZE 0x1
#define XS1_CHANEND_CTRL0_OUT_READY_MASK (((1 << XS1_CHANEND_CTRL0_OUT_READY_SIZE) - 1) << XS1_CHANEND_CTRL0_OUT_READY_SHIFT)
/**
 * Extract the CHANEND_CTRL0_OUT_READY bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_OUT_READY(x) (((x) & XS1_CHANEND_CTRL0_OUT_READY_MASK) >> XS1_CHANEND_CTRL0_OUT_READY_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_OUT_READY bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_OUT_READY_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_OUT_READY_MASK) | (((v) << XS1_CHANEND_CTRL0_OUT_READY_SHIFT) & XS1_CHANEND_CTRL0_OUT_READY_MASK))
///@}
/**
 * \name CHANEND_CTRL0_OUT_WAITING
 * \anchor CHANEND_CTRL0_OUT_WAITING
 * 1 when there is a thread waiting to write data to the channel end.
 */
///@{
#define XS1_CHANEND_CTRL0_OUT_WAITING_SHIFT 0x7
#define XS1_CHANEND_CTRL0_OUT_WAITING_SIZE 0x1
#define XS1_CHANEND_CTRL0_OUT_WAITING_MASK (((1 << XS1_CHANEND_CTRL0_OUT_WAITING_SIZE) - 1) << XS1_CHANEND_CTRL0_OUT_WAITING_SHIFT)
/**
 * Extract the CHANEND_CTRL0_OUT_WAITING bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_OUT_WAITING(x) (((x) & XS1_CHANEND_CTRL0_OUT_WAITING_MASK) >> XS1_CHANEND_CTRL0_OUT_WAITING_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_OUT_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_OUT_WAITING_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_OUT_WAITING_MASK) | (((v) << XS1_CHANEND_CTRL0_OUT_WAITING_SHIFT) & XS1_CHANEND_CTRL0_OUT_WAITING_MASK))
///@}
/**
 * \name CHANEND_CTRL0_EV_VALID
 * \anchor CHANEND_CTRL0_EV_VALID
 * 1 when the Environment Vector is valid. When invalid, the resourceId is used as the environment vector. The environment vector is set using the ``SETEV`` instruction.
 */
///@{
#define XS1_CHANEND_CTRL0_EV_VALID_SHIFT 0x8
#define XS1_CHANEND_CTRL0_EV_VALID_SIZE 0x1
#define XS1_CHANEND_CTRL0_EV_VALID_MASK (((1 << XS1_CHANEND_CTRL0_EV_VALID_SIZE) - 1) << XS1_CHANEND_CTRL0_EV_VALID_SHIFT)
/**
 * Extract the CHANEND_CTRL0_EV_VALID bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_EV_VALID(x) (((x) & XS1_CHANEND_CTRL0_EV_VALID_MASK) >> XS1_CHANEND_CTRL0_EV_VALID_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_EV_VALID bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_EV_VALID_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_EV_VALID_MASK) | (((v) << XS1_CHANEND_CTRL0_EV_VALID_SHIFT) & XS1_CHANEND_CTRL0_EV_VALID_MASK))
///@}
/**
 * \name CHANEND_CTRL0_IN_T_NUM
 * \anchor CHANEND_CTRL0_IN_T_NUM
 * Number of the input thread waiting for data or an event on this channel end.
 */
///@{
#define XS1_CHANEND_CTRL0_IN_T_NUM_SHIFT 0x10
#define XS1_CHANEND_CTRL0_IN_T_NUM_SIZE 0x8
#define XS1_CHANEND_CTRL0_IN_T_NUM_MASK (((1 << XS1_CHANEND_CTRL0_IN_T_NUM_SIZE) - 1) << XS1_CHANEND_CTRL0_IN_T_NUM_SHIFT)
/**
 * Extract the CHANEND_CTRL0_IN_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_IN_T_NUM(x) (((x) & XS1_CHANEND_CTRL0_IN_T_NUM_MASK) >> XS1_CHANEND_CTRL0_IN_T_NUM_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_IN_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_IN_T_NUM_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_IN_T_NUM_MASK) | (((v) << XS1_CHANEND_CTRL0_IN_T_NUM_SHIFT) & XS1_CHANEND_CTRL0_IN_T_NUM_MASK))
///@}
/**
 * \name CHANEND_CTRL0_OUT_T_NUM
 * \anchor CHANEND_CTRL0_OUT_T_NUM
 * Number of the last thread to attempt to write data to this channel end.
 */
///@{
#define XS1_CHANEND_CTRL0_OUT_T_NUM_SHIFT 0x18
#define XS1_CHANEND_CTRL0_OUT_T_NUM_SIZE 0x8
#define XS1_CHANEND_CTRL0_OUT_T_NUM_MASK (((1 << XS1_CHANEND_CTRL0_OUT_T_NUM_SIZE) - 1) << XS1_CHANEND_CTRL0_OUT_T_NUM_SHIFT)
/**
 * Extract the CHANEND_CTRL0_OUT_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_CHANEND_CTRL0_OUT_T_NUM(x) (((x) & XS1_CHANEND_CTRL0_OUT_T_NUM_MASK) >> XS1_CHANEND_CTRL0_OUT_T_NUM_SHIFT)
/**
 * Pack the value (v) of the CHANEND_CTRL0_OUT_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_CHANEND_CTRL0_OUT_T_NUM_SET(x, v) (((x) & ~XS1_CHANEND_CTRL0_OUT_T_NUM_MASK) | (((v) << XS1_CHANEND_CTRL0_OUT_T_NUM_SHIFT) & XS1_CHANEND_CTRL0_OUT_T_NUM_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_INUSE
 * \anchor CLKBLK_CTRL0_INUSE
 * 1 when the clock source is in use.
 */
///@{
#define XS1_CLKBLK_CTRL0_INUSE_SHIFT 0x0
#define XS1_CLKBLK_CTRL0_INUSE_SIZE 0x1
#define XS1_CLKBLK_CTRL0_INUSE_MASK (((1 << XS1_CLKBLK_CTRL0_INUSE_SIZE) - 1) << XS1_CLKBLK_CTRL0_INUSE_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_INUSE(x) (((x) & XS1_CLKBLK_CTRL0_INUSE_MASK) >> XS1_CLKBLK_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_INUSE_MASK) | (((v) << XS1_CLKBLK_CTRL0_INUSE_SHIFT) & XS1_CLKBLK_CTRL0_INUSE_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_STARTED
 * \anchor CLKBLK_CTRL0_STARTED
 * 1 when the clock source has been started.
 */
///@{
#define XS1_CLKBLK_CTRL0_STARTED_SHIFT 0x1
#define XS1_CLKBLK_CTRL0_STARTED_SIZE 0x1
#define XS1_CLKBLK_CTRL0_STARTED_MASK (((1 << XS1_CLKBLK_CTRL0_STARTED_SIZE) - 1) << XS1_CLKBLK_CTRL0_STARTED_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_STARTED bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_STARTED(x) (((x) & XS1_CLKBLK_CTRL0_STARTED_MASK) >> XS1_CLKBLK_CTRL0_STARTED_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_STARTED bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_STARTED_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_STARTED_MASK) | (((v) << XS1_CLKBLK_CTRL0_STARTED_SHIFT) & XS1_CLKBLK_CTRL0_STARTED_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_STOPPING
 * \anchor CLKBLK_CTRL0_STOPPING
 * 1 when the clock source is in the process of stopping.
 */
///@{
#define XS1_CLKBLK_CTRL0_STOPPING_SHIFT 0x2
#define XS1_CLKBLK_CTRL0_STOPPING_SIZE 0x1
#define XS1_CLKBLK_CTRL0_STOPPING_MASK (((1 << XS1_CLKBLK_CTRL0_STOPPING_SIZE) - 1) << XS1_CLKBLK_CTRL0_STOPPING_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_STOPPING bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_STOPPING(x) (((x) & XS1_CLKBLK_CTRL0_STOPPING_MASK) >> XS1_CLKBLK_CTRL0_STOPPING_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_STOPPING bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_STOPPING_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_STOPPING_MASK) | (((v) << XS1_CLKBLK_CTRL0_STOPPING_SHIFT) & XS1_CLKBLK_CTRL0_STOPPING_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_T_WAITING
 * \anchor CLKBLK_CTRL0_T_WAITING
 * 1 when there is a thread waiting for synchronisation with the clock block.
 */
///@{
#define XS1_CLKBLK_CTRL0_T_WAITING_SHIFT 0x17
#define XS1_CLKBLK_CTRL0_T_WAITING_SIZE 0x1
#define XS1_CLKBLK_CTRL0_T_WAITING_MASK (((1 << XS1_CLKBLK_CTRL0_T_WAITING_SIZE) - 1) << XS1_CLKBLK_CTRL0_T_WAITING_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_T_WAITING bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_T_WAITING(x) (((x) & XS1_CLKBLK_CTRL0_T_WAITING_MASK) >> XS1_CLKBLK_CTRL0_T_WAITING_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_T_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_T_WAITING_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_T_WAITING_MASK) | (((v) << XS1_CLKBLK_CTRL0_T_WAITING_SHIFT) & XS1_CLKBLK_CTRL0_T_WAITING_MASK))
///@}
/**
 * \name CLKBLK_CTRL0_T_NUM
 * \anchor CLKBLK_CTRL0_T_NUM
 * Number of the thread waiting for the clock block.
 */
///@{
#define XS1_CLKBLK_CTRL0_T_NUM_SHIFT 0x18
#define XS1_CLKBLK_CTRL0_T_NUM_SIZE 0x8
#define XS1_CLKBLK_CTRL0_T_NUM_MASK (((1 << XS1_CLKBLK_CTRL0_T_NUM_SIZE) - 1) << XS1_CLKBLK_CTRL0_T_NUM_SHIFT)
/**
 * Extract the CLKBLK_CTRL0_T_NUM bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL0_T_NUM(x) (((x) & XS1_CLKBLK_CTRL0_T_NUM_MASK) >> XS1_CLKBLK_CTRL0_T_NUM_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL0_T_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL0_T_NUM_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL0_T_NUM_MASK) | (((v) << XS1_CLKBLK_CTRL0_T_NUM_SHIFT) & XS1_CLKBLK_CTRL0_T_NUM_MASK))
///@}
/**
 * \name CLKBLK_CTRL1_FALL_DELAY
 * \anchor CLKBLK_CTRL1_FALL_DELAY
 * Falling edge delay counter.
 */
///@{
#define XS1_CLKBLK_CTRL1_FALL_DELAY_SHIFT 0x0
#define XS1_CLKBLK_CTRL1_FALL_DELAY_SIZE 0x9
#define XS1_CLKBLK_CTRL1_FALL_DELAY_MASK (((1 << XS1_CLKBLK_CTRL1_FALL_DELAY_SIZE) - 1) << XS1_CLKBLK_CTRL1_FALL_DELAY_SHIFT)
/**
 * Extract the CLKBLK_CTRL1_FALL_DELAY bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL1_FALL_DELAY(x) (((x) & XS1_CLKBLK_CTRL1_FALL_DELAY_MASK) >> XS1_CLKBLK_CTRL1_FALL_DELAY_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL1_FALL_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL1_FALL_DELAY_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL1_FALL_DELAY_MASK) | (((v) << XS1_CLKBLK_CTRL1_FALL_DELAY_SHIFT) & XS1_CLKBLK_CTRL1_FALL_DELAY_MASK))
///@}
/**
 * \name CLKBLK_CTRL1_RISE_DELAY
 * \anchor CLKBLK_CTRL1_RISE_DELAY
 * Rising edge delay counter.
 */
///@{
#define XS1_CLKBLK_CTRL1_RISE_DELAY_SHIFT 0x10
#define XS1_CLKBLK_CTRL1_RISE_DELAY_SIZE 0x9
#define XS1_CLKBLK_CTRL1_RISE_DELAY_MASK (((1 << XS1_CLKBLK_CTRL1_RISE_DELAY_SIZE) - 1) << XS1_CLKBLK_CTRL1_RISE_DELAY_SHIFT)
/**
 * Extract the CLKBLK_CTRL1_RISE_DELAY bitfield from a packed word x and return it.
 */
#define XS1_CLKBLK_CTRL1_RISE_DELAY(x) (((x) & XS1_CLKBLK_CTRL1_RISE_DELAY_MASK) >> XS1_CLKBLK_CTRL1_RISE_DELAY_SHIFT)
/**
 * Pack the value (v) of the CLKBLK_CTRL1_RISE_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_CLKBLK_CTRL1_RISE_DELAY_SET(x, v) (((x) & ~XS1_CLKBLK_CTRL1_RISE_DELAY_MASK) | (((v) << XS1_CLKBLK_CTRL1_RISE_DELAY_SHIFT) & XS1_CLKBLK_CTRL1_RISE_DELAY_MASK))
///@}
/**
 * \name COPROC_CTRL0_INUSE
 * \anchor COPROC_CTRL0_INUSE
 * 1 when the coprocessor is in use.
 */
///@{
#define XS1_COPROC_CTRL0_INUSE_SHIFT 0x0
#define XS1_COPROC_CTRL0_INUSE_SIZE 0x1
#define XS1_COPROC_CTRL0_INUSE_MASK (((1 << XS1_COPROC_CTRL0_INUSE_SIZE) - 1) << XS1_COPROC_CTRL0_INUSE_SHIFT)
/**
 * Extract the COPROC_CTRL0_INUSE bitfield from a packed word x and return it.
 */
#define XS1_COPROC_CTRL0_INUSE(x) (((x) & XS1_COPROC_CTRL0_INUSE_MASK) >> XS1_COPROC_CTRL0_INUSE_SHIFT)
/**
 * Pack the value (v) of the COPROC_CTRL0_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_COPROC_CTRL0_INUSE_SET(x, v) (((x) & ~XS1_COPROC_CTRL0_INUSE_MASK) | (((v) << XS1_COPROC_CTRL0_INUSE_SHIFT) & XS1_COPROC_CTRL0_INUSE_MASK))
///@}
/**
 * \name COPROC_CTRL0_OWNT_V
 * \anchor COPROC_CTRL0_OWNT_V
 * Indicates that the coprocessor's owner is known.
 */
///@{
#define XS1_COPROC_CTRL0_OWNT_V_SHIFT 0x1
#define XS1_COPROC_CTRL0_OWNT_V_SIZE 0x1
#define XS1_COPROC_CTRL0_OWNT_V_MASK (((1 << XS1_COPROC_CTRL0_OWNT_V_SIZE) - 1) << XS1_COPROC_CTRL0_OWNT_V_SHIFT)
/**
 * Extract the COPROC_CTRL0_OWNT_V bitfield from a packed word x and return it.
 */
#define XS1_COPROC_CTRL0_OWNT_V(x) (((x) & XS1_COPROC_CTRL0_OWNT_V_MASK) >> XS1_COPROC_CTRL0_OWNT_V_SHIFT)
/**
 * Pack the value (v) of the COPROC_CTRL0_OWNT_V bitfield into a packed word x and return the packed field.
 */
#define XS1_COPROC_CTRL0_OWNT_V_SET(x, v) (((x) & ~XS1_COPROC_CTRL0_OWNT_V_MASK) | (((v) << XS1_COPROC_CTRL0_OWNT_V_SHIFT) & XS1_COPROC_CTRL0_OWNT_V_MASK))
///@}
/**
 * \name COPROC_CTRL0_OWNT
 * \anchor COPROC_CTRL0_OWNT
 * When OWNT_V is true then this is the ID of the thread currently using the coprocessor.
 */
///@{
#define XS1_COPROC_CTRL0_OWNT_SHIFT 0x8
#define XS1_COPROC_CTRL0_OWNT_SIZE 0x8
#define XS1_COPROC_CTRL0_OWNT_MASK (((1 << XS1_COPROC_CTRL0_OWNT_SIZE) - 1) << XS1_COPROC_CTRL0_OWNT_SHIFT)
/**
 * Extract the COPROC_CTRL0_OWNT bitfield from a packed word x and return it.
 */
#define XS1_COPROC_CTRL0_OWNT(x) (((x) & XS1_COPROC_CTRL0_OWNT_MASK) >> XS1_COPROC_CTRL0_OWNT_SHIFT)
/**
 * Pack the value (v) of the COPROC_CTRL0_OWNT bitfield into a packed word x and return the packed field.
 */
#define XS1_COPROC_CTRL0_OWNT_SET(x, v) (((x) & ~XS1_COPROC_CTRL0_OWNT_MASK) | (((v) << XS1_COPROC_CTRL0_OWNT_SHIFT) & XS1_COPROC_CTRL0_OWNT_MASK))
///@}
/**
 * \name COPROC_TBV0_WAITING
 * \anchor COPROC_TBV0_WAITING
 * 1 bit for each of the threads. When 1 indicates that the corresponding thread is waiting for the coprocessor.
 */
///@{
#define XS1_COPROC_TBV0_WAITING_SHIFT 0x0
#define XS1_COPROC_TBV0_WAITING_SIZE 0x8
#define XS1_COPROC_TBV0_WAITING_MASK (((1 << XS1_COPROC_TBV0_WAITING_SIZE) - 1) << XS1_COPROC_TBV0_WAITING_SHIFT)
/**
 * Extract the COPROC_TBV0_WAITING bitfield from a packed word x and return it.
 */
#define XS1_COPROC_TBV0_WAITING(x) (((x) & XS1_COPROC_TBV0_WAITING_MASK) >> XS1_COPROC_TBV0_WAITING_SHIFT)
/**
 * Pack the value (v) of the COPROC_TBV0_WAITING bitfield into a packed word x and return the packed field.
 */
#define XS1_COPROC_TBV0_WAITING_SET(x, v) (((x) & ~XS1_COPROC_TBV0_WAITING_MASK) | (((v) << XS1_COPROC_TBV0_WAITING_SHIFT) & XS1_COPROC_TBV0_WAITING_MASK))
///@}
/**
 * \name RES_ID_TYPE
 * \anchor RES_ID_TYPE
 * The type of a resource.
 */
///@{
#define XS1_RES_ID_TYPE_SHIFT 0x0
#define XS1_RES_ID_TYPE_SIZE 0x4
#define XS1_RES_ID_TYPE_MASK (((1 << XS1_RES_ID_TYPE_SIZE) - 1) << XS1_RES_ID_TYPE_SHIFT)
/**
 * Extract the RES_ID_TYPE bitfield from a packed word x and return it.
 */
#define XS1_RES_ID_TYPE(x) (((x) & XS1_RES_ID_TYPE_MASK) >> XS1_RES_ID_TYPE_SHIFT)
/**
 * Pack the value (v) of the RES_ID_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_RES_ID_TYPE_SET(x, v) (((x) & ~XS1_RES_ID_TYPE_MASK) | (((v) << XS1_RES_ID_TYPE_SHIFT) & XS1_RES_ID_TYPE_MASK))
///@}
/**
 * \name RES_ID_REGID
 * \anchor RES_ID_REGID
 * The register ID for resource ``GETPS`` / ``SETPS`` accesses. Must be 0 otherwise.
 */
///@{
#define XS1_RES_ID_REGID_SHIFT 0x4
#define XS1_RES_ID_REGID_SIZE 0x4
#define XS1_RES_ID_REGID_MASK (((1 << XS1_RES_ID_REGID_SIZE) - 1) << XS1_RES_ID_REGID_SHIFT)
/**
 * Extract the RES_ID_REGID bitfield from a packed word x and return it.
 */
#define XS1_RES_ID_REGID(x) (((x) & XS1_RES_ID_REGID_MASK) >> XS1_RES_ID_REGID_SHIFT)
/**
 * Pack the value (v) of the RES_ID_REGID bitfield into a packed word x and return the packed field.
 */
#define XS1_RES_ID_REGID_SET(x, v) (((x) & ~XS1_RES_ID_REGID_MASK) | (((v) << XS1_RES_ID_REGID_SHIFT) & XS1_RES_ID_REGID_MASK))
///@}
/**
 * \name RES_ID_RESNUM
 * \anchor RES_ID_RESNUM
 * The resource number of a resource.
 */
///@{
#define XS1_RES_ID_RESNUM_SHIFT 0x8
#define XS1_RES_ID_RESNUM_SIZE 0x8
#define XS1_RES_ID_RESNUM_MASK (((1 << XS1_RES_ID_RESNUM_SIZE) - 1) << XS1_RES_ID_RESNUM_SHIFT)
/**
 * Extract the RES_ID_RESNUM bitfield from a packed word x and return it.
 */
#define XS1_RES_ID_RESNUM(x) (((x) & XS1_RES_ID_RESNUM_MASK) >> XS1_RES_ID_RESNUM_SHIFT)
/**
 * Pack the value (v) of the RES_ID_RESNUM bitfield into a packed word x and return the packed field.
 */
#define XS1_RES_ID_RESNUM_SET(x, v) (((x) & ~XS1_RES_ID_RESNUM_MASK) | (((v) << XS1_RES_ID_RESNUM_SHIFT) & XS1_RES_ID_RESNUM_MASK))
///@}
/**
 * \name RES_ID_PORTWIDTH
 * \anchor RES_ID_PORTWIDTH
 * The size of a port - zero for all resources which are not ports.
 */
///@{
#define XS1_RES_ID_PORTWIDTH_SHIFT 0x10
#define XS1_RES_ID_PORTWIDTH_SIZE 0x6
#define XS1_RES_ID_PORTWIDTH_MASK (((1 << XS1_RES_ID_PORTWIDTH_SIZE) - 1) << XS1_RES_ID_PORTWIDTH_SHIFT)
/**
 * Extract the RES_ID_PORTWIDTH bitfield from a packed word x and return it.
 */
#define XS1_RES_ID_PORTWIDTH(x) (((x) & XS1_RES_ID_PORTWIDTH_MASK) >> XS1_RES_ID_PORTWIDTH_SHIFT)
/**
 * Pack the value (v) of the RES_ID_PORTWIDTH bitfield into a packed word x and return the packed field.
 */
#define XS1_RES_ID_PORTWIDTH_SET(x, v) (((x) & ~XS1_RES_ID_PORTWIDTH_MASK) | (((v) << XS1_RES_ID_PORTWIDTH_SHIFT) & XS1_RES_ID_PORTWIDTH_MASK))
///@}
/**
 * \name CHAN_ID_CHANNUM
 * \anchor CHAN_ID_CHANNUM
 * The channel end number.
 */
///@{
#define XS1_CHAN_ID_CHANNUM_SHIFT 0x8
#define XS1_CHAN_ID_CHANNUM_SIZE 0x8
#define XS1_CHAN_ID_CHANNUM_MASK (((1 << XS1_CHAN_ID_CHANNUM_SIZE) - 1) << XS1_CHAN_ID_CHANNUM_SHIFT)
/**
 * Extract the CHAN_ID_CHANNUM bitfield from a packed word x and return it.
 */
#define XS1_CHAN_ID_CHANNUM(x) (((x) & XS1_CHAN_ID_CHANNUM_MASK) >> XS1_CHAN_ID_CHANNUM_SHIFT)
/**
 * Pack the value (v) of the CHAN_ID_CHANNUM bitfield into a packed word x and return the packed field.
 */
#define XS1_CHAN_ID_CHANNUM_SET(x, v) (((x) & ~XS1_CHAN_ID_CHANNUM_MASK) | (((v) << XS1_CHAN_ID_CHANNUM_SHIFT) & XS1_CHAN_ID_CHANNUM_MASK))
///@}
/**
 * \name CHAN_ID_PROCESSOR
 * \anchor CHAN_ID_PROCESSOR
 * The processor to which this resource belongs.
 */
///@{
#define XS1_CHAN_ID_PROCESSOR_SHIFT 0x10
#define XS1_CHAN_ID_PROCESSOR_SIZE 0x8
#define XS1_CHAN_ID_PROCESSOR_MASK (((1 << XS1_CHAN_ID_PROCESSOR_SIZE) - 1) << XS1_CHAN_ID_PROCESSOR_SHIFT)
/**
 * Extract the CHAN_ID_PROCESSOR bitfield from a packed word x and return it.
 */
#define XS1_CHAN_ID_PROCESSOR(x) (((x) & XS1_CHAN_ID_PROCESSOR_MASK) >> XS1_CHAN_ID_PROCESSOR_SHIFT)
/**
 * Pack the value (v) of the CHAN_ID_PROCESSOR bitfield into a packed word x and return the packed field.
 */
#define XS1_CHAN_ID_PROCESSOR_SET(x, v) (((x) & ~XS1_CHAN_ID_PROCESSOR_MASK) | (((v) << XS1_CHAN_ID_PROCESSOR_SHIFT) & XS1_CHAN_ID_PROCESSOR_MASK))
///@}
/**
 * \name CHAN_ID_NODE
 * \anchor CHAN_ID_NODE
 * The node in which this resource is found.
 */
///@{
#define XS1_CHAN_ID_NODE_SHIFT 0x18
#define XS1_CHAN_ID_NODE_SIZE 0x8
#define XS1_CHAN_ID_NODE_MASK (((1 << XS1_CHAN_ID_NODE_SIZE) - 1) << XS1_CHAN_ID_NODE_SHIFT)
/**
 * Extract the CHAN_ID_NODE bitfield from a packed word x and return it.
 */
#define XS1_CHAN_ID_NODE(x) (((x) & XS1_CHAN_ID_NODE_MASK) >> XS1_CHAN_ID_NODE_SHIFT)
/**
 * Pack the value (v) of the CHAN_ID_NODE bitfield into a packed word x and return the packed field.
 */
#define XS1_CHAN_ID_NODE_SET(x, v) (((x) & ~XS1_CHAN_ID_NODE_MASK) | (((v) << XS1_CHAN_ID_NODE_SHIFT) & XS1_CHAN_ID_NODE_MASK))
///@}
/**
 * \name HEADER_1BYTE_CHANNUM
 * \anchor HEADER_1BYTE_CHANNUM
 * The channel end number.
 */
///@{
#define XS1_HEADER_1BYTE_CHANNUM_SHIFT 0x0
#define XS1_HEADER_1BYTE_CHANNUM_SIZE 0x5
#define XS1_HEADER_1BYTE_CHANNUM_MASK (((1 << XS1_HEADER_1BYTE_CHANNUM_SIZE) - 1) << XS1_HEADER_1BYTE_CHANNUM_SHIFT)
/**
 * Extract the HEADER_1BYTE_CHANNUM bitfield from a packed word x and return it.
 */
#define XS1_HEADER_1BYTE_CHANNUM(x) (((x) & XS1_HEADER_1BYTE_CHANNUM_MASK) >> XS1_HEADER_1BYTE_CHANNUM_SHIFT)
/**
 * Pack the value (v) of the HEADER_1BYTE_CHANNUM bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_1BYTE_CHANNUM_SET(x, v) (((x) & ~XS1_HEADER_1BYTE_CHANNUM_MASK) | (((v) << XS1_HEADER_1BYTE_CHANNUM_SHIFT) & XS1_HEADER_1BYTE_CHANNUM_MASK))
///@}
/**
 * \name HEADER_1BYTE_PROCESSOR
 * \anchor HEADER_1BYTE_PROCESSOR
 * The processor to which this resource belongs.
 */
///@{
#define XS1_HEADER_1BYTE_PROCESSOR_SHIFT 0x5
#define XS1_HEADER_1BYTE_PROCESSOR_SIZE 0x2
#define XS1_HEADER_1BYTE_PROCESSOR_MASK (((1 << XS1_HEADER_1BYTE_PROCESSOR_SIZE) - 1) << XS1_HEADER_1BYTE_PROCESSOR_SHIFT)
/**
 * Extract the HEADER_1BYTE_PROCESSOR bitfield from a packed word x and return it.
 */
#define XS1_HEADER_1BYTE_PROCESSOR(x) (((x) & XS1_HEADER_1BYTE_PROCESSOR_MASK) >> XS1_HEADER_1BYTE_PROCESSOR_SHIFT)
/**
 * Pack the value (v) of the HEADER_1BYTE_PROCESSOR bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_1BYTE_PROCESSOR_SET(x, v) (((x) & ~XS1_HEADER_1BYTE_PROCESSOR_MASK) | (((v) << XS1_HEADER_1BYTE_PROCESSOR_SHIFT) & XS1_HEADER_1BYTE_PROCESSOR_MASK))
///@}
/**
 * \name HEADER_1BYTE_NODE
 * \anchor HEADER_1BYTE_NODE
 * The node in which this resource is found.
 */
///@{
#define XS1_HEADER_1BYTE_NODE_SHIFT 0x7
#define XS1_HEADER_1BYTE_NODE_SIZE 0x1
#define XS1_HEADER_1BYTE_NODE_MASK (((1 << XS1_HEADER_1BYTE_NODE_SIZE) - 1) << XS1_HEADER_1BYTE_NODE_SHIFT)
/**
 * Extract the HEADER_1BYTE_NODE bitfield from a packed word x and return it.
 */
#define XS1_HEADER_1BYTE_NODE(x) (((x) & XS1_HEADER_1BYTE_NODE_MASK) >> XS1_HEADER_1BYTE_NODE_SHIFT)
/**
 * Pack the value (v) of the HEADER_1BYTE_NODE bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_1BYTE_NODE_SET(x, v) (((x) & ~XS1_HEADER_1BYTE_NODE_MASK) | (((v) << XS1_HEADER_1BYTE_NODE_SHIFT) & XS1_HEADER_1BYTE_NODE_MASK))
///@}
/**
 * \name HEADER_3BYTE_CHANNUM
 * \anchor HEADER_3BYTE_CHANNUM
 * The channel end number.
 */
///@{
#define XS1_HEADER_3BYTE_CHANNUM_SHIFT 0x0
#define XS1_HEADER_3BYTE_CHANNUM_SIZE 0x8
#define XS1_HEADER_3BYTE_CHANNUM_MASK (((1 << XS1_HEADER_3BYTE_CHANNUM_SIZE) - 1) << XS1_HEADER_3BYTE_CHANNUM_SHIFT)
/**
 * Extract the HEADER_3BYTE_CHANNUM bitfield from a packed word x and return it.
 */
#define XS1_HEADER_3BYTE_CHANNUM(x) (((x) & XS1_HEADER_3BYTE_CHANNUM_MASK) >> XS1_HEADER_3BYTE_CHANNUM_SHIFT)
/**
 * Pack the value (v) of the HEADER_3BYTE_CHANNUM bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_3BYTE_CHANNUM_SET(x, v) (((x) & ~XS1_HEADER_3BYTE_CHANNUM_MASK) | (((v) << XS1_HEADER_3BYTE_CHANNUM_SHIFT) & XS1_HEADER_3BYTE_CHANNUM_MASK))
///@}
/**
 * \name HEADER_3BYTE_PROCESSOR
 * \anchor HEADER_3BYTE_PROCESSOR
 * The processor to which this resource belongs.
 */
///@{
#define XS1_HEADER_3BYTE_PROCESSOR_SHIFT 0x8
#define XS1_HEADER_3BYTE_PROCESSOR_SIZE 0x8
#define XS1_HEADER_3BYTE_PROCESSOR_MASK (((1 << XS1_HEADER_3BYTE_PROCESSOR_SIZE) - 1) << XS1_HEADER_3BYTE_PROCESSOR_SHIFT)
/**
 * Extract the HEADER_3BYTE_PROCESSOR bitfield from a packed word x and return it.
 */
#define XS1_HEADER_3BYTE_PROCESSOR(x) (((x) & XS1_HEADER_3BYTE_PROCESSOR_MASK) >> XS1_HEADER_3BYTE_PROCESSOR_SHIFT)
/**
 * Pack the value (v) of the HEADER_3BYTE_PROCESSOR bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_3BYTE_PROCESSOR_SET(x, v) (((x) & ~XS1_HEADER_3BYTE_PROCESSOR_MASK) | (((v) << XS1_HEADER_3BYTE_PROCESSOR_SHIFT) & XS1_HEADER_3BYTE_PROCESSOR_MASK))
///@}
/**
 * \name HEADER_3BYTE_NODE
 * \anchor HEADER_3BYTE_NODE
 * The node in which this resource is found.
 */
///@{
#define XS1_HEADER_3BYTE_NODE_SHIFT 0x10
#define XS1_HEADER_3BYTE_NODE_SIZE 0x8
#define XS1_HEADER_3BYTE_NODE_MASK (((1 << XS1_HEADER_3BYTE_NODE_SIZE) - 1) << XS1_HEADER_3BYTE_NODE_SHIFT)
/**
 * Extract the HEADER_3BYTE_NODE bitfield from a packed word x and return it.
 */
#define XS1_HEADER_3BYTE_NODE(x) (((x) & XS1_HEADER_3BYTE_NODE_MASK) >> XS1_HEADER_3BYTE_NODE_SHIFT)
/**
 * Pack the value (v) of the HEADER_3BYTE_NODE bitfield into a packed word x and return the packed field.
 */
#define XS1_HEADER_3BYTE_NODE_SET(x, v) (((x) & ~XS1_HEADER_3BYTE_NODE_MASK) | (((v) << XS1_HEADER_3BYTE_NODE_SHIFT) & XS1_HEADER_3BYTE_NODE_MASK))
///@}
/**
 * \name SETCTRL_MODE
 * \anchor SETCTRL_MODE
 * Select mode to change.
 */
///@{
#define XS1_SETC_MODE_SHIFT 0x0
#define XS1_SETC_MODE_SIZE 0x3
#define XS1_SETC_MODE_MASK (((1 << XS1_SETC_MODE_SIZE) - 1) << XS1_SETC_MODE_SHIFT)
/**
 * Extract the SETCTRL_MODE bitfield from a packed word x and return it.
 */
#define XS1_SETC_MODE(x) (((x) & XS1_SETC_MODE_MASK) >> XS1_SETC_MODE_SHIFT)
/**
 * Pack the value (v) of the SETCTRL_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_MODE_SET(x, v) (((x) & ~XS1_SETC_MODE_MASK) | (((v) << XS1_SETC_MODE_SHIFT) & XS1_SETC_MODE_MASK))
///@}
/**
 * \name SETCTRL_VALUE
 * \anchor SETCTRL_VALUE
 * Value for mode change.
 */
///@{
#define XS1_SETC_VALUE_SHIFT 0x3
#define XS1_SETC_VALUE_SIZE 0x9
#define XS1_SETC_VALUE_MASK (((1 << XS1_SETC_VALUE_SIZE) - 1) << XS1_SETC_VALUE_SHIFT)
/**
 * Extract the SETCTRL_VALUE bitfield from a packed word x and return it.
 */
#define XS1_SETC_VALUE(x) (((x) & XS1_SETC_VALUE_MASK) >> XS1_SETC_VALUE_SHIFT)
/**
 * Pack the value (v) of the SETCTRL_VALUE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_VALUE_SET(x, v) (((x) & ~XS1_SETC_VALUE_MASK) | (((v) << XS1_SETC_VALUE_SHIFT) & XS1_SETC_VALUE_MASK))
///@}
/**
 * \name SETCTRL_LMODE
 * \anchor SETCTRL_LMODE
 * Long mode bits.
 */
///@{
#define XS1_SETC_LMODE_SHIFT 0xc
#define XS1_SETC_LMODE_SIZE 0x4
#define XS1_SETC_LMODE_MASK (((1 << XS1_SETC_LMODE_SIZE) - 1) << XS1_SETC_LMODE_SHIFT)
/**
 * Extract the SETCTRL_LMODE bitfield from a packed word x and return it.
 */
#define XS1_SETC_LMODE(x) (((x) & XS1_SETC_LMODE_MASK) >> XS1_SETC_LMODE_SHIFT)
/**
 * Pack the value (v) of the SETCTRL_LMODE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_LMODE_SET(x, v) (((x) & ~XS1_SETC_LMODE_MASK) | (((v) << XS1_SETC_LMODE_SHIFT) & XS1_SETC_LMODE_MASK))
///@}
/**
 * \name MMAPCTRL_MODE
 * \anchor MMAPCTRL_MODE
 * Select mode to change.
 */
///@{
#define XS1_SETC_MMAP_MODE_SHIFT 0x0
#define XS1_SETC_MMAP_MODE_SIZE 0x8
#define XS1_SETC_MMAP_MODE_MASK (((1 << XS1_SETC_MMAP_MODE_SIZE) - 1) << XS1_SETC_MMAP_MODE_SHIFT)
/**
 * Extract the MMAPCTRL_MODE bitfield from a packed word x and return it.
 */
#define XS1_SETC_MMAP_MODE(x) (((x) & XS1_SETC_MMAP_MODE_MASK) >> XS1_SETC_MMAP_MODE_SHIFT)
/**
 * Pack the value (v) of the MMAPCTRL_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_MMAP_MODE_SET(x, v) (((x) & ~XS1_SETC_MMAP_MODE_MASK) | (((v) << XS1_SETC_MMAP_MODE_SHIFT) & XS1_SETC_MMAP_MODE_MASK))
///@}
/**
 * \name MMAPCTRL_VALUE
 * \anchor MMAPCTRL_VALUE
 * Value for mode change.
 */
///@{
#define XS1_SETC_MMAP_VALUE_SHIFT 0x8
#define XS1_SETC_MMAP_VALUE_SIZE 0x18
#define XS1_SETC_MMAP_VALUE_MASK (((1 << XS1_SETC_MMAP_VALUE_SIZE) - 1) << XS1_SETC_MMAP_VALUE_SHIFT)
/**
 * Extract the MMAPCTRL_VALUE bitfield from a packed word x and return it.
 */
#define XS1_SETC_MMAP_VALUE(x) (((x) & XS1_SETC_MMAP_VALUE_MASK) >> XS1_SETC_MMAP_VALUE_SHIFT)
/**
 * Pack the value (v) of the MMAPCTRL_VALUE bitfield into a packed word x and return the packed field.
 */
#define XS1_SETC_MMAP_VALUE_SET(x, v) (((x) & ~XS1_SETC_MMAP_VALUE_MASK) | (((v) << XS1_SETC_MMAP_VALUE_SHIFT) & XS1_SETC_MMAP_VALUE_MASK))
///@}
/**
 * \name DBG_INT_REQ_DBG
 * \anchor DBG_INT_REQ_DBG
 * Request a debug interrupt on the processor.
 */
///@{
#define XS1_DBG_INT_REQ_DBG_SHIFT 0x0
#define XS1_DBG_INT_REQ_DBG_SIZE 0x1
#define XS1_DBG_INT_REQ_DBG_MASK (((1 << XS1_DBG_INT_REQ_DBG_SIZE) - 1) << XS1_DBG_INT_REQ_DBG_SHIFT)
/**
 * Extract the DBG_INT_REQ_DBG bitfield from a packed word x and return it.
 */
#define XS1_DBG_INT_REQ_DBG(x) (((x) & XS1_DBG_INT_REQ_DBG_MASK) >> XS1_DBG_INT_REQ_DBG_SHIFT)
/**
 * Pack the value (v) of the DBG_INT_REQ_DBG bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_INT_REQ_DBG_SET(x, v) (((x) & ~XS1_DBG_INT_REQ_DBG_MASK) | (((v) << XS1_DBG_INT_REQ_DBG_SHIFT) & XS1_DBG_INT_REQ_DBG_MASK))
///@}
/**
 * \name DBG_INT_IN_DBG
 * \anchor DBG_INT_IN_DBG
 * 1 when the processor is in debug mode.
 */
///@{
#define XS1_DBG_INT_IN_DBG_SHIFT 0x1
#define XS1_DBG_INT_IN_DBG_SIZE 0x1
#define XS1_DBG_INT_IN_DBG_MASK (((1 << XS1_DBG_INT_IN_DBG_SIZE) - 1) << XS1_DBG_INT_IN_DBG_SHIFT)
/**
 * Extract the DBG_INT_IN_DBG bitfield from a packed word x and return it.
 */
#define XS1_DBG_INT_IN_DBG(x) (((x) & XS1_DBG_INT_IN_DBG_MASK) >> XS1_DBG_INT_IN_DBG_SHIFT)
/**
 * Pack the value (v) of the DBG_INT_IN_DBG bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_INT_IN_DBG_SET(x, v) (((x) & ~XS1_DBG_INT_IN_DBG_MASK) | (((v) << XS1_DBG_INT_IN_DBG_SHIFT) & XS1_DBG_INT_IN_DBG_MASK))
///@}
/**
 * \name DBG_CTRL_PSWITCH_RO_EXT
 * \anchor DBG_CTRL_PSWITCH_RO_EXT
 * When 1 the PSwitch is restricted to RO access to all CRW registers from SSwitch 
 */
///@{
#define XS1_DBG_CTRL_PSWITCH_RO_EXT_SHIFT 0x0
#define XS1_DBG_CTRL_PSWITCH_RO_EXT_SIZE 0x1
#define XS1_DBG_CTRL_PSWITCH_RO_EXT_MASK (((1 << XS1_DBG_CTRL_PSWITCH_RO_EXT_SIZE) - 1) << XS1_DBG_CTRL_PSWITCH_RO_EXT_SHIFT)
/**
 * Extract the DBG_CTRL_PSWITCH_RO_EXT bitfield from a packed word x and return it.
 */
#define XS1_DBG_CTRL_PSWITCH_RO_EXT(x) (((x) & XS1_DBG_CTRL_PSWITCH_RO_EXT_MASK) >> XS1_DBG_CTRL_PSWITCH_RO_EXT_SHIFT)
/**
 * Pack the value (v) of the DBG_CTRL_PSWITCH_RO_EXT bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_CTRL_PSWITCH_RO_EXT_SET(x, v) (((x) & ~XS1_DBG_CTRL_PSWITCH_RO_EXT_MASK) | (((v) << XS1_DBG_CTRL_PSWITCH_RO_EXT_SHIFT) & XS1_DBG_CTRL_PSWITCH_RO_EXT_MASK))
///@}
/**
 * \name DBG_CTRL_PSWITCH_RO
 * \anchor DBG_CTRL_PSWITCH_RO
 * When 1 the PSwitch is restricted to RO access to all CRW registers from SSwitch, XCore(PS_DBG_Scratch) and JTAG 
 */
///@{
#define XS1_DBG_CTRL_PSWITCH_RO_SHIFT 0x1f
#define XS1_DBG_CTRL_PSWITCH_RO_SIZE 0x1
#define XS1_DBG_CTRL_PSWITCH_RO_MASK (((1 << XS1_DBG_CTRL_PSWITCH_RO_SIZE) - 1) << XS1_DBG_CTRL_PSWITCH_RO_SHIFT)
/**
 * Extract the DBG_CTRL_PSWITCH_RO bitfield from a packed word x and return it.
 */
#define XS1_DBG_CTRL_PSWITCH_RO(x) (((x) & XS1_DBG_CTRL_PSWITCH_RO_MASK) >> XS1_DBG_CTRL_PSWITCH_RO_SHIFT)
/**
 * Pack the value (v) of the DBG_CTRL_PSWITCH_RO bitfield into a packed word x and return the packed field.
 */
#define XS1_DBG_CTRL_PSWITCH_RO_SET(x, v) (((x) & ~XS1_DBG_CTRL_PSWITCH_RO_MASK) | (((v) << XS1_DBG_CTRL_PSWITCH_RO_SHIFT) & XS1_DBG_CTRL_PSWITCH_RO_MASK))
///@}
/**
 * \name DEVICE_ID0_VERSION
 * \anchor DEVICE_ID0_VERSION
 * XCore version.
 */
///@{
#define XS1_DEVICE_ID0_VERSION_SHIFT 0x0
#define XS1_DEVICE_ID0_VERSION_SIZE 0x8
#define XS1_DEVICE_ID0_VERSION_MASK (((1 << XS1_DEVICE_ID0_VERSION_SIZE) - 1) << XS1_DEVICE_ID0_VERSION_SHIFT)
/**
 * Extract the DEVICE_ID0_VERSION bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID0_VERSION(x) (((x) & XS1_DEVICE_ID0_VERSION_MASK) >> XS1_DEVICE_ID0_VERSION_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID0_VERSION bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID0_VERSION_SET(x, v) (((x) & ~XS1_DEVICE_ID0_VERSION_MASK) | (((v) << XS1_DEVICE_ID0_VERSION_SHIFT) & XS1_DEVICE_ID0_VERSION_MASK))
///@}
/**
 * \name DEVICE_ID0_REVISION
 * \anchor DEVICE_ID0_REVISION
 * XCore revision.
 */
///@{
#define XS1_DEVICE_ID0_REVISION_SHIFT 0x8
#define XS1_DEVICE_ID0_REVISION_SIZE 0x8
#define XS1_DEVICE_ID0_REVISION_MASK (((1 << XS1_DEVICE_ID0_REVISION_SIZE) - 1) << XS1_DEVICE_ID0_REVISION_SHIFT)
/**
 * Extract the DEVICE_ID0_REVISION bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID0_REVISION(x) (((x) & XS1_DEVICE_ID0_REVISION_MASK) >> XS1_DEVICE_ID0_REVISION_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID0_REVISION bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID0_REVISION_SET(x, v) (((x) & ~XS1_DEVICE_ID0_REVISION_MASK) | (((v) << XS1_DEVICE_ID0_REVISION_SHIFT) & XS1_DEVICE_ID0_REVISION_MASK))
///@}
/**
 * \name DEVICE_ID0_NODE
 * \anchor DEVICE_ID0_NODE
 * Number of the node in which this XCore is located.
 */
///@{
#define XS1_DEVICE_ID0_NODE_SHIFT 0x10
#define XS1_DEVICE_ID0_NODE_SIZE 0x8
#define XS1_DEVICE_ID0_NODE_MASK (((1 << XS1_DEVICE_ID0_NODE_SIZE) - 1) << XS1_DEVICE_ID0_NODE_SHIFT)
/**
 * Extract the DEVICE_ID0_NODE bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID0_NODE(x) (((x) & XS1_DEVICE_ID0_NODE_MASK) >> XS1_DEVICE_ID0_NODE_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID0_NODE bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID0_NODE_SET(x, v) (((x) & ~XS1_DEVICE_ID0_NODE_MASK) | (((v) << XS1_DEVICE_ID0_NODE_SHIFT) & XS1_DEVICE_ID0_NODE_MASK))
///@}
/**
 * \name DEVICE_ID0_PID
 * \anchor DEVICE_ID0_PID
 * Processor ID of this XCore.
 */
///@{
#define XS1_DEVICE_ID0_PID_SHIFT 0x18
#define XS1_DEVICE_ID0_PID_SIZE 0x8
#define XS1_DEVICE_ID0_PID_MASK (((1 << XS1_DEVICE_ID0_PID_SIZE) - 1) << XS1_DEVICE_ID0_PID_SHIFT)
/**
 * Extract the DEVICE_ID0_PID bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID0_PID(x) (((x) & XS1_DEVICE_ID0_PID_MASK) >> XS1_DEVICE_ID0_PID_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID0_PID bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID0_PID_SET(x, v) (((x) & ~XS1_DEVICE_ID0_PID_MASK) | (((v) << XS1_DEVICE_ID0_PID_SHIFT) & XS1_DEVICE_ID0_PID_MASK))
///@}
/**
 * \name DEVICE_ID1_NUM_THREADS
 * \anchor DEVICE_ID1_NUM_THREADS
 * Number of threads.
 */
///@{
#define XS1_DEVICE_ID1_NUM_THREADS_SHIFT 0x0
#define XS1_DEVICE_ID1_NUM_THREADS_SIZE 0x8
#define XS1_DEVICE_ID1_NUM_THREADS_MASK (((1 << XS1_DEVICE_ID1_NUM_THREADS_SIZE) - 1) << XS1_DEVICE_ID1_NUM_THREADS_SHIFT)
/**
 * Extract the DEVICE_ID1_NUM_THREADS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID1_NUM_THREADS(x) (((x) & XS1_DEVICE_ID1_NUM_THREADS_MASK) >> XS1_DEVICE_ID1_NUM_THREADS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID1_NUM_THREADS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID1_NUM_THREADS_SET(x, v) (((x) & ~XS1_DEVICE_ID1_NUM_THREADS_MASK) | (((v) << XS1_DEVICE_ID1_NUM_THREADS_SHIFT) & XS1_DEVICE_ID1_NUM_THREADS_MASK))
///@}
/**
 * \name DEVICE_ID1_NUM_SYNCS
 * \anchor DEVICE_ID1_NUM_SYNCS
 * Number of synchronisers.
 */
///@{
#define XS1_DEVICE_ID1_NUM_SYNCS_SHIFT 0x8
#define XS1_DEVICE_ID1_NUM_SYNCS_SIZE 0x8
#define XS1_DEVICE_ID1_NUM_SYNCS_MASK (((1 << XS1_DEVICE_ID1_NUM_SYNCS_SIZE) - 1) << XS1_DEVICE_ID1_NUM_SYNCS_SHIFT)
/**
 * Extract the DEVICE_ID1_NUM_SYNCS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID1_NUM_SYNCS(x) (((x) & XS1_DEVICE_ID1_NUM_SYNCS_MASK) >> XS1_DEVICE_ID1_NUM_SYNCS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID1_NUM_SYNCS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID1_NUM_SYNCS_SET(x, v) (((x) & ~XS1_DEVICE_ID1_NUM_SYNCS_MASK) | (((v) << XS1_DEVICE_ID1_NUM_SYNCS_SHIFT) & XS1_DEVICE_ID1_NUM_SYNCS_MASK))
///@}
/**
 * \name DEVICE_ID1_NUM_LOCKS
 * \anchor DEVICE_ID1_NUM_LOCKS
 * Number of the locks.
 */
///@{
#define XS1_DEVICE_ID1_NUM_LOCKS_SHIFT 0x10
#define XS1_DEVICE_ID1_NUM_LOCKS_SIZE 0x8
#define XS1_DEVICE_ID1_NUM_LOCKS_MASK (((1 << XS1_DEVICE_ID1_NUM_LOCKS_SIZE) - 1) << XS1_DEVICE_ID1_NUM_LOCKS_SHIFT)
/**
 * Extract the DEVICE_ID1_NUM_LOCKS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID1_NUM_LOCKS(x) (((x) & XS1_DEVICE_ID1_NUM_LOCKS_MASK) >> XS1_DEVICE_ID1_NUM_LOCKS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID1_NUM_LOCKS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID1_NUM_LOCKS_SET(x, v) (((x) & ~XS1_DEVICE_ID1_NUM_LOCKS_MASK) | (((v) << XS1_DEVICE_ID1_NUM_LOCKS_SHIFT) & XS1_DEVICE_ID1_NUM_LOCKS_MASK))
///@}
/**
 * \name DEVICE_ID1_NUM_CHANENDS
 * \anchor DEVICE_ID1_NUM_CHANENDS
 * Number of channel ends.
 */
///@{
#define XS1_DEVICE_ID1_NUM_CHANENDS_SHIFT 0x18
#define XS1_DEVICE_ID1_NUM_CHANENDS_SIZE 0x8
#define XS1_DEVICE_ID1_NUM_CHANENDS_MASK (((1 << XS1_DEVICE_ID1_NUM_CHANENDS_SIZE) - 1) << XS1_DEVICE_ID1_NUM_CHANENDS_SHIFT)
/**
 * Extract the DEVICE_ID1_NUM_CHANENDS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID1_NUM_CHANENDS(x) (((x) & XS1_DEVICE_ID1_NUM_CHANENDS_MASK) >> XS1_DEVICE_ID1_NUM_CHANENDS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID1_NUM_CHANENDS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID1_NUM_CHANENDS_SET(x, v) (((x) & ~XS1_DEVICE_ID1_NUM_CHANENDS_MASK) | (((v) << XS1_DEVICE_ID1_NUM_CHANENDS_SHIFT) & XS1_DEVICE_ID1_NUM_CHANENDS_MASK))
///@}
/**
 * \name DEVICE_ID2_NUM_TIMERS
 * \anchor DEVICE_ID2_NUM_TIMERS
 * Number of timers.
 */
///@{
#define XS1_DEVICE_ID2_NUM_TIMERS_SHIFT 0x0
#define XS1_DEVICE_ID2_NUM_TIMERS_SIZE 0x8
#define XS1_DEVICE_ID2_NUM_TIMERS_MASK (((1 << XS1_DEVICE_ID2_NUM_TIMERS_SIZE) - 1) << XS1_DEVICE_ID2_NUM_TIMERS_SHIFT)
/**
 * Extract the DEVICE_ID2_NUM_TIMERS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID2_NUM_TIMERS(x) (((x) & XS1_DEVICE_ID2_NUM_TIMERS_MASK) >> XS1_DEVICE_ID2_NUM_TIMERS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID2_NUM_TIMERS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID2_NUM_TIMERS_SET(x, v) (((x) & ~XS1_DEVICE_ID2_NUM_TIMERS_MASK) | (((v) << XS1_DEVICE_ID2_NUM_TIMERS_SHIFT) & XS1_DEVICE_ID2_NUM_TIMERS_MASK))
///@}
/**
 * \name DEVICE_ID2_NUM_CLKBLKS
 * \anchor DEVICE_ID2_NUM_CLKBLKS
 * Number of clock blocks.
 */
///@{
#define XS1_DEVICE_ID2_NUM_CLKBLKS_SHIFT 0x8
#define XS1_DEVICE_ID2_NUM_CLKBLKS_SIZE 0x8
#define XS1_DEVICE_ID2_NUM_CLKBLKS_MASK (((1 << XS1_DEVICE_ID2_NUM_CLKBLKS_SIZE) - 1) << XS1_DEVICE_ID2_NUM_CLKBLKS_SHIFT)
/**
 * Extract the DEVICE_ID2_NUM_CLKBLKS bitfield from a packed word x and return it.
 */
#define XS1_DEVICE_ID2_NUM_CLKBLKS(x) (((x) & XS1_DEVICE_ID2_NUM_CLKBLKS_MASK) >> XS1_DEVICE_ID2_NUM_CLKBLKS_SHIFT)
/**
 * Pack the value (v) of the DEVICE_ID2_NUM_CLKBLKS bitfield into a packed word x and return the packed field.
 */
#define XS1_DEVICE_ID2_NUM_CLKBLKS_SET(x, v) (((x) & ~XS1_DEVICE_ID2_NUM_CLKBLKS_MASK) | (((v) << XS1_DEVICE_ID2_NUM_CLKBLKS_SHIFT) & XS1_DEVICE_ID2_NUM_CLKBLKS_MASK))
///@}
/**
 * \name JUNK
 * \anchor JUNK
 * 1 when the current packet is considered junk and will be thrown away.
 */
///@{
#define XS1_JUNK_SHIFT 0x2
#define XS1_JUNK_SIZE 0x1
#define XS1_JUNK_MASK (((1 << XS1_JUNK_SIZE) - 1) << XS1_JUNK_SHIFT)
/**
 * Extract the JUNK bitfield from a packed word x and return it.
 */
#define XS1_JUNK(x) (((x) & XS1_JUNK_MASK) >> XS1_JUNK_SHIFT)
/**
 * Pack the value (v) of the JUNK bitfield into a packed word x and return the packed field.
 */
#define XS1_JUNK_SET(x, v) (((x) & ~XS1_JUNK_MASK) | (((v) << XS1_JUNK_SHIFT) & XS1_JUNK_MASK))
///@}
/**
 * \name NETWORK
 * \anchor NETWORK
 * Network ID for the PLink.
 */
///@{
#define XS1_NETWORK_SHIFT 0x4
#define XS1_NETWORK_SIZE 0x2
#define XS1_NETWORK_MASK (((1 << XS1_NETWORK_SIZE) - 1) << XS1_NETWORK_SHIFT)
/**
 * Extract the NETWORK bitfield from a packed word x and return it.
 */
#define XS1_NETWORK(x) (((x) & XS1_NETWORK_MASK) >> XS1_NETWORK_SHIFT)
/**
 * Pack the value (v) of the NETWORK bitfield into a packed word x and return the packed field.
 */
#define XS1_NETWORK_SET(x, v) (((x) & ~XS1_NETWORK_MASK) | (((v) << XS1_NETWORK_SHIFT) & XS1_NETWORK_MASK))
///@}
/**
 * \name SRC_TARGET_ID
 * \anchor SRC_TARGET_ID
 * Based on SRC_TARGET_TYPE value, it represents channelEnd ID or Idle status.
 */
///@{
#define XS1_SRC_TARGET_ID_SHIFT 0x10
#define XS1_SRC_TARGET_ID_SIZE 0x8
#define XS1_SRC_TARGET_ID_MASK (((1 << XS1_SRC_TARGET_ID_SIZE) - 1) << XS1_SRC_TARGET_ID_SHIFT)
/**
 * Extract the SRC_TARGET_ID bitfield from a packed word x and return it.
 */
#define XS1_SRC_TARGET_ID(x) (((x) & XS1_SRC_TARGET_ID_MASK) >> XS1_SRC_TARGET_ID_SHIFT)
/**
 * Pack the value (v) of the SRC_TARGET_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_SRC_TARGET_ID_SET(x, v) (((x) & ~XS1_SRC_TARGET_ID_MASK) | (((v) << XS1_SRC_TARGET_ID_SHIFT) & XS1_SRC_TARGET_ID_MASK))
///@}
/**
 * \name SRC_TARGET_TYPE
 * \anchor SRC_TARGET_TYPE
 * 00 - ChannelEnd, 01 - ERROR, 10 - PSCTL, 11 - Idle.
 */
///@{
#define XS1_SRC_TARGET_TYPE_SHIFT 0x18
#define XS1_SRC_TARGET_TYPE_SIZE 0x2
#define XS1_SRC_TARGET_TYPE_MASK (((1 << XS1_SRC_TARGET_TYPE_SIZE) - 1) << XS1_SRC_TARGET_TYPE_SHIFT)
/**
 * Extract the SRC_TARGET_TYPE bitfield from a packed word x and return it.
 */
#define XS1_SRC_TARGET_TYPE(x) (((x) & XS1_SRC_TARGET_TYPE_MASK) >> XS1_SRC_TARGET_TYPE_SHIFT)
/**
 * Pack the value (v) of the SRC_TARGET_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_SRC_TARGET_TYPE_SET(x, v) (((x) & ~XS1_SRC_TARGET_TYPE_MASK) | (((v) << XS1_SRC_TARGET_TYPE_SHIFT) & XS1_SRC_TARGET_TYPE_MASK))
///@}
/**
 * \name SS_DEVICE_ID0_VERSION
 * \anchor SS_DEVICE_ID0_VERSION
 * SSwitch version.
 */
///@{
#define XS1_SS_DEVICE_ID0_VERSION_SHIFT 0x0
#define XS1_SS_DEVICE_ID0_VERSION_SIZE 0x8
#define XS1_SS_DEVICE_ID0_VERSION_MASK (((1 << XS1_SS_DEVICE_ID0_VERSION_SIZE) - 1) << XS1_SS_DEVICE_ID0_VERSION_SHIFT)
/**
 * Extract the SS_DEVICE_ID0_VERSION bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID0_VERSION(x) (((x) & XS1_SS_DEVICE_ID0_VERSION_MASK) >> XS1_SS_DEVICE_ID0_VERSION_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID0_VERSION bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID0_VERSION_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID0_VERSION_MASK) | (((v) << XS1_SS_DEVICE_ID0_VERSION_SHIFT) & XS1_SS_DEVICE_ID0_VERSION_MASK))
///@}
/**
 * \name SS_DEVICE_ID0_REVISION
 * \anchor SS_DEVICE_ID0_REVISION
 * SSwitch revision.
 */
///@{
#define XS1_SS_DEVICE_ID0_REVISION_SHIFT 0x8
#define XS1_SS_DEVICE_ID0_REVISION_SIZE 0x8
#define XS1_SS_DEVICE_ID0_REVISION_MASK (((1 << XS1_SS_DEVICE_ID0_REVISION_SIZE) - 1) << XS1_SS_DEVICE_ID0_REVISION_SHIFT)
/**
 * Extract the SS_DEVICE_ID0_REVISION bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID0_REVISION(x) (((x) & XS1_SS_DEVICE_ID0_REVISION_MASK) >> XS1_SS_DEVICE_ID0_REVISION_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID0_REVISION bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID0_REVISION_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID0_REVISION_MASK) | (((v) << XS1_SS_DEVICE_ID0_REVISION_SHIFT) & XS1_SS_DEVICE_ID0_REVISION_MASK))
///@}
/**
 * \name SS_DEVICE_ID0_BOOT_CTRL
 * \anchor SS_DEVICE_ID0_BOOT_CTRL
 * Sampled values of BootCtl pins on Power On Reset.
 */
///@{
#define XS1_SS_DEVICE_ID0_BOOT_CTRL_SHIFT 0x10
#define XS1_SS_DEVICE_ID0_BOOT_CTRL_SIZE 0x8
#define XS1_SS_DEVICE_ID0_BOOT_CTRL_MASK (((1 << XS1_SS_DEVICE_ID0_BOOT_CTRL_SIZE) - 1) << XS1_SS_DEVICE_ID0_BOOT_CTRL_SHIFT)
/**
 * Extract the SS_DEVICE_ID0_BOOT_CTRL bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID0_BOOT_CTRL(x) (((x) & XS1_SS_DEVICE_ID0_BOOT_CTRL_MASK) >> XS1_SS_DEVICE_ID0_BOOT_CTRL_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID0_BOOT_CTRL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID0_BOOT_CTRL_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID0_BOOT_CTRL_MASK) | (((v) << XS1_SS_DEVICE_ID0_BOOT_CTRL_SHIFT) & XS1_SS_DEVICE_ID0_BOOT_CTRL_MASK))
///@}
/**
 * \name SS_DEVICE_ID1_NUM_PLINKS_PER_PROC
 * \anchor SS_DEVICE_ID1_NUM_PLINKS_PER_PROC
 * Number of processors on the device.
 */
///@{
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SHIFT 0x0
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SIZE 0x8
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_MASK (((1 << XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SIZE) - 1) << XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SHIFT)
/**
 * Extract the SS_DEVICE_ID1_NUM_PLINKS_PER_PROC bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC(x) (((x) & XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_MASK) >> XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID1_NUM_PLINKS_PER_PROC bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_MASK) | (((v) << XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_SHIFT) & XS1_SS_DEVICE_ID1_NUM_PLINKS_PER_PROC_MASK))
///@}
/**
 * \name SS_DEVICE_ID1_NUM_PROCESSORS
 * \anchor SS_DEVICE_ID1_NUM_PROCESSORS
 * Number of processors on the SSwitch.
 */
///@{
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SHIFT 0x8
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SIZE 0x8
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS_MASK (((1 << XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SIZE) - 1) << XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SHIFT)
/**
 * Extract the SS_DEVICE_ID1_NUM_PROCESSORS bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS(x) (((x) & XS1_SS_DEVICE_ID1_NUM_PROCESSORS_MASK) >> XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID1_NUM_PROCESSORS bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID1_NUM_PROCESSORS_MASK) | (((v) << XS1_SS_DEVICE_ID1_NUM_PROCESSORS_SHIFT) & XS1_SS_DEVICE_ID1_NUM_PROCESSORS_MASK))
///@}
/**
 * \name SS_DEVICE_ID1_NUM_SLINKS
 * \anchor SS_DEVICE_ID1_NUM_SLINKS
 * Number of SLinks on the SSwitch.
 */
///@{
#define XS1_SS_DEVICE_ID1_NUM_SLINKS_SHIFT 0x10
#define XS1_SS_DEVICE_ID1_NUM_SLINKS_SIZE 0x8
#define XS1_SS_DEVICE_ID1_NUM_SLINKS_MASK (((1 << XS1_SS_DEVICE_ID1_NUM_SLINKS_SIZE) - 1) << XS1_SS_DEVICE_ID1_NUM_SLINKS_SHIFT)
/**
 * Extract the SS_DEVICE_ID1_NUM_SLINKS bitfield from a packed word x and return it.
 */
#define XS1_SS_DEVICE_ID1_NUM_SLINKS(x) (((x) & XS1_SS_DEVICE_ID1_NUM_SLINKS_MASK) >> XS1_SS_DEVICE_ID1_NUM_SLINKS_SHIFT)
/**
 * Pack the value (v) of the SS_DEVICE_ID1_NUM_SLINKS bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DEVICE_ID1_NUM_SLINKS_SET(x, v) (((x) & ~XS1_SS_DEVICE_ID1_NUM_SLINKS_MASK) | (((v) << XS1_SS_DEVICE_ID1_NUM_SLINKS_SHIFT) & XS1_SS_DEVICE_ID1_NUM_SLINKS_MASK))
///@}
/**
 * \name SS_NODE_CONFIG_HEADERS
 * \anchor SS_NODE_CONFIG_HEADERS
 * 0 = 2-byte headers, 1 = 1-byte headers (reset as 0).
 */
///@{
#define XS1_SS_NODE_CONFIG_HEADERS_SHIFT 0x0
#define XS1_SS_NODE_CONFIG_HEADERS_SIZE 0x1
#define XS1_SS_NODE_CONFIG_HEADERS_MASK (((1 << XS1_SS_NODE_CONFIG_HEADERS_SIZE) - 1) << XS1_SS_NODE_CONFIG_HEADERS_SHIFT)
/**
 * Extract the SS_NODE_CONFIG_HEADERS bitfield from a packed word x and return it.
 */
#define XS1_SS_NODE_CONFIG_HEADERS(x) (((x) & XS1_SS_NODE_CONFIG_HEADERS_MASK) >> XS1_SS_NODE_CONFIG_HEADERS_SHIFT)
/**
 * Pack the value (v) of the SS_NODE_CONFIG_HEADERS bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_NODE_CONFIG_HEADERS_SET(x, v) (((x) & ~XS1_SS_NODE_CONFIG_HEADERS_MASK) | (((v) << XS1_SS_NODE_CONFIG_HEADERS_SHIFT) & XS1_SS_NODE_CONFIG_HEADERS_MASK))
///@}
/**
 * \name SS_NODE_CONFIG_DISABLE_PLL_CTL_REG
 * \anchor SS_NODE_CONFIG_DISABLE_PLL_CTL_REG
 * 0 = PLL_CTL_REG has write access. 1 = PLL_CTL_REG can not be written to.
 */
///@{
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SHIFT 0x8
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SIZE 0x1
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_MASK (((1 << XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SIZE) - 1) << XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SHIFT)
/**
 * Extract the SS_NODE_CONFIG_DISABLE_PLL_CTL_REG bitfield from a packed word x and return it.
 */
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG(x) (((x) & XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_MASK) >> XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SHIFT)
/**
 * Pack the value (v) of the SS_NODE_CONFIG_DISABLE_PLL_CTL_REG bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SET(x, v) (((x) & ~XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_MASK) | (((v) << XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_SHIFT) & XS1_SS_NODE_CONFIG_DISABLE_PLL_CTL_REG_MASK))
///@}
/**
 * \name SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE
 * \anchor SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE
 * 0 = SSCTL registers have write access. 1 = SSCTL registers can not be written to.
 */
///@{
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SHIFT 0x1f
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SIZE 0x1
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_MASK (((1 << XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SIZE) - 1) << XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SHIFT)
/**
 * Extract the SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE bitfield from a packed word x and return it.
 */
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE(x) (((x) & XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_MASK) >> XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SHIFT)
/**
 * Pack the value (v) of the SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SET(x, v) (((x) & ~XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_MASK) | (((v) << XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_SHIFT) & XS1_SS_NODE_CONFIG_DISABLE_SSCTL_UPDATE_MASK))
///@}
/**
 * \name SS_NODE_ID_ID
 * \anchor SS_NODE_ID_ID
 * The unique ID of this node.
 */
///@{
#define XS1_SS_NODE_ID_ID_SHIFT 0x0
#define XS1_SS_NODE_ID_ID_SIZE 0x10
#define XS1_SS_NODE_ID_ID_MASK (((1 << XS1_SS_NODE_ID_ID_SIZE) - 1) << XS1_SS_NODE_ID_ID_SHIFT)
/**
 * Extract the SS_NODE_ID_ID bitfield from a packed word x and return it.
 */
#define XS1_SS_NODE_ID_ID(x) (((x) & XS1_SS_NODE_ID_ID_MASK) >> XS1_SS_NODE_ID_ID_SHIFT)
/**
 * Pack the value (v) of the SS_NODE_ID_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_NODE_ID_ID_SET(x, v) (((x) & ~XS1_SS_NODE_ID_ID_MASK) | (((v) << XS1_SS_NODE_ID_ID_SHIFT) & XS1_SS_NODE_ID_ID_MASK))
///@}
/**
 * \name SS_PLL_CTL_INPUT_DIVISOR
 * \anchor SS_PLL_CTL_INPUT_DIVISOR
 * Oscilator input divider value range from 0 (0x00) to 63 (0x3F). R value.
 */
///@{
#define XS1_SS_PLL_CTL_INPUT_DIVISOR_SHIFT 0x0
#define XS1_SS_PLL_CTL_INPUT_DIVISOR_SIZE 0x6
#define XS1_SS_PLL_CTL_INPUT_DIVISOR_MASK (((1 << XS1_SS_PLL_CTL_INPUT_DIVISOR_SIZE) - 1) << XS1_SS_PLL_CTL_INPUT_DIVISOR_SHIFT)
/**
 * Extract the SS_PLL_CTL_INPUT_DIVISOR bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_INPUT_DIVISOR(x) (((x) & XS1_SS_PLL_CTL_INPUT_DIVISOR_MASK) >> XS1_SS_PLL_CTL_INPUT_DIVISOR_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_INPUT_DIVISOR bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_INPUT_DIVISOR_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_INPUT_DIVISOR_MASK) | (((v) << XS1_SS_PLL_CTL_INPUT_DIVISOR_SHIFT) & XS1_SS_PLL_CTL_INPUT_DIVISOR_MASK))
///@}
/**
 * \name SS_PLL_CTL_FEEDBACK_MUL
 * \anchor SS_PLL_CTL_FEEDBACK_MUL
 * Feedback multiplication ratio, range from 1 (0x0001) to 8191 (0x1FFF). F value.
 */
///@{
#define XS1_SS_PLL_CTL_FEEDBACK_MUL_SHIFT 0x8
#define XS1_SS_PLL_CTL_FEEDBACK_MUL_SIZE 0xd
#define XS1_SS_PLL_CTL_FEEDBACK_MUL_MASK (((1 << XS1_SS_PLL_CTL_FEEDBACK_MUL_SIZE) - 1) << XS1_SS_PLL_CTL_FEEDBACK_MUL_SHIFT)
/**
 * Extract the SS_PLL_CTL_FEEDBACK_MUL bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_FEEDBACK_MUL(x) (((x) & XS1_SS_PLL_CTL_FEEDBACK_MUL_MASK) >> XS1_SS_PLL_CTL_FEEDBACK_MUL_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_FEEDBACK_MUL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_FEEDBACK_MUL_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_FEEDBACK_MUL_MASK) | (((v) << XS1_SS_PLL_CTL_FEEDBACK_MUL_SHIFT) & XS1_SS_PLL_CTL_FEEDBACK_MUL_MASK))
///@}
/**
 * \name SS_PLL_CTL_POST_DIVISOR
 * \anchor SS_PLL_CTL_POST_DIVISOR
 * Output divider value range from 0 to 7. OD value.
 */
///@{
#define XS1_SS_PLL_CTL_POST_DIVISOR_SHIFT 0x17
#define XS1_SS_PLL_CTL_POST_DIVISOR_SIZE 0x3
#define XS1_SS_PLL_CTL_POST_DIVISOR_MASK (((1 << XS1_SS_PLL_CTL_POST_DIVISOR_SIZE) - 1) << XS1_SS_PLL_CTL_POST_DIVISOR_SHIFT)
/**
 * Extract the SS_PLL_CTL_POST_DIVISOR bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_POST_DIVISOR(x) (((x) & XS1_SS_PLL_CTL_POST_DIVISOR_MASK) >> XS1_SS_PLL_CTL_POST_DIVISOR_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_POST_DIVISOR bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_POST_DIVISOR_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_POST_DIVISOR_MASK) | (((v) << XS1_SS_PLL_CTL_POST_DIVISOR_SHIFT) & XS1_SS_PLL_CTL_POST_DIVISOR_MASK))
///@}
/**
 * \name SS_TEST_MODE_BOOT_RAM
 * \anchor SS_TEST_MODE_BOOT_RAM
 * If set to 1, set the boot mode to jump to RAM
 */
///@{
#define XS1_SS_TEST_MODE_BOOT_RAM_SHIFT 0x1b
#define XS1_SS_TEST_MODE_BOOT_RAM_SIZE 0x1
#define XS1_SS_TEST_MODE_BOOT_RAM_MASK (((1 << XS1_SS_TEST_MODE_BOOT_RAM_SIZE) - 1) << XS1_SS_TEST_MODE_BOOT_RAM_SHIFT)
/**
 * Extract the SS_TEST_MODE_BOOT_RAM bitfield from a packed word x and return it.
 */
#define XS1_SS_TEST_MODE_BOOT_RAM(x) (((x) & XS1_SS_TEST_MODE_BOOT_RAM_MASK) >> XS1_SS_TEST_MODE_BOOT_RAM_SHIFT)
/**
 * Pack the value (v) of the SS_TEST_MODE_BOOT_RAM bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_TEST_MODE_BOOT_RAM_SET(x, v) (((x) & ~XS1_SS_TEST_MODE_BOOT_RAM_MASK) | (((v) << XS1_SS_TEST_MODE_BOOT_RAM_SHIFT) & XS1_SS_TEST_MODE_BOOT_RAM_MASK))
///@}
/**
 * \name SS_APP_PLL_ENABLE
 * \anchor SS_APP_PLL_ENABLE
 * If set to 1, enable the secondary PLL
 */
///@{
#define XS1_SS_APP_PLL_ENABLE_SHIFT 0x1b
#define XS1_SS_APP_PLL_ENABLE_SIZE 0x1
#define XS1_SS_APP_PLL_ENABLE_MASK (((1 << XS1_SS_APP_PLL_ENABLE_SIZE) - 1) << XS1_SS_APP_PLL_ENABLE_SHIFT)
/**
 * Extract the SS_APP_PLL_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_SS_APP_PLL_ENABLE(x) (((x) & XS1_SS_APP_PLL_ENABLE_MASK) >> XS1_SS_APP_PLL_ENABLE_SHIFT)
/**
 * Pack the value (v) of the SS_APP_PLL_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_APP_PLL_ENABLE_SET(x, v) (((x) & ~XS1_SS_APP_PLL_ENABLE_MASK) | (((v) << XS1_SS_APP_PLL_ENABLE_SHIFT) & XS1_SS_APP_PLL_ENABLE_MASK))
///@}
/**
 * \name SS_FRAC_N_PERIOD_CYC_CNT
 * \anchor SS_FRAC_N_PERIOD_CYC_CNT
 * The ``p`` value for the fractional divider. The period
 *       over which the fractional N divider
 *       oscillates between ``F`` and ``F+1`` is ``p+1``
 */
///@{
#define XS1_SS_FRAC_N_PERIOD_CYC_CNT_SHIFT 0x0
#define XS1_SS_FRAC_N_PERIOD_CYC_CNT_SIZE 0x8
#define XS1_SS_FRAC_N_PERIOD_CYC_CNT_MASK (((1 << XS1_SS_FRAC_N_PERIOD_CYC_CNT_SIZE) - 1) << XS1_SS_FRAC_N_PERIOD_CYC_CNT_SHIFT)
/**
 * Extract the SS_FRAC_N_PERIOD_CYC_CNT bitfield from a packed word x and return it.
 */
#define XS1_SS_FRAC_N_PERIOD_CYC_CNT(x) (((x) & XS1_SS_FRAC_N_PERIOD_CYC_CNT_MASK) >> XS1_SS_FRAC_N_PERIOD_CYC_CNT_SHIFT)
/**
 * Pack the value (v) of the SS_FRAC_N_PERIOD_CYC_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_FRAC_N_PERIOD_CYC_CNT_SET(x, v) (((x) & ~XS1_SS_FRAC_N_PERIOD_CYC_CNT_MASK) | (((v) << XS1_SS_FRAC_N_PERIOD_CYC_CNT_SHIFT) & XS1_SS_FRAC_N_PERIOD_CYC_CNT_MASK))
///@}
/**
 * \name SS_FRAC_N_F_HIGH_CYC_CNT
 * \anchor SS_FRAC_N_F_HIGH_CYC_CNT
 * The ``f`` value for the fractional divider.
 *       The number of clock cycles in the period that a divider ``F+1`` is used
 *       is ``f+1``.
 */
///@{
#define XS1_SS_FRAC_N_F_HIGH_CYC_CNT_SHIFT 0x8
#define XS1_SS_FRAC_N_F_HIGH_CYC_CNT_SIZE 0x8
#define XS1_SS_FRAC_N_F_HIGH_CYC_CNT_MASK (((1 << XS1_SS_FRAC_N_F_HIGH_CYC_CNT_SIZE) - 1) << XS1_SS_FRAC_N_F_HIGH_CYC_CNT_SHIFT)
/**
 * Extract the SS_FRAC_N_F_HIGH_CYC_CNT bitfield from a packed word x and return it.
 */
#define XS1_SS_FRAC_N_F_HIGH_CYC_CNT(x) (((x) & XS1_SS_FRAC_N_F_HIGH_CYC_CNT_MASK) >> XS1_SS_FRAC_N_F_HIGH_CYC_CNT_SHIFT)
/**
 * Pack the value (v) of the SS_FRAC_N_F_HIGH_CYC_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_FRAC_N_F_HIGH_CYC_CNT_SET(x, v) (((x) & ~XS1_SS_FRAC_N_F_HIGH_CYC_CNT_MASK) | (((v) << XS1_SS_FRAC_N_F_HIGH_CYC_CNT_SHIFT) & XS1_SS_FRAC_N_F_HIGH_CYC_CNT_MASK))
///@}
/**
 * \name SS_FRAC_N_ENABLE
 * \anchor SS_FRAC_N_ENABLE
 * When set to 1, the secondary PLL will be a fractional
 *       ``N`` divided PLL
 */
///@{
#define XS1_SS_FRAC_N_ENABLE_SHIFT 0x1f
#define XS1_SS_FRAC_N_ENABLE_SIZE 0x1
#define XS1_SS_FRAC_N_ENABLE_MASK (((1 << XS1_SS_FRAC_N_ENABLE_SIZE) - 1) << XS1_SS_FRAC_N_ENABLE_SHIFT)
/**
 * Extract the SS_FRAC_N_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_SS_FRAC_N_ENABLE(x) (((x) & XS1_SS_FRAC_N_ENABLE_MASK) >> XS1_SS_FRAC_N_ENABLE_SHIFT)
/**
 * Pack the value (v) of the SS_FRAC_N_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_FRAC_N_ENABLE_SET(x, v) (((x) & ~XS1_SS_FRAC_N_ENABLE_MASK) | (((v) << XS1_SS_FRAC_N_ENABLE_SHIFT) & XS1_SS_FRAC_N_ENABLE_MASK))
///@}
/**
 * \name SS_LPDDR_ENABLE
 * \anchor SS_LPDDR_ENABLE
 * When set to 1 this will allow the LPDDR controller to access the pads
 */
///@{
#define XS1_SS_LPDDR_ENABLE_SHIFT 0x0
#define XS1_SS_LPDDR_ENABLE_SIZE 0x1
#define XS1_SS_LPDDR_ENABLE_MASK (((1 << XS1_SS_LPDDR_ENABLE_SIZE) - 1) << XS1_SS_LPDDR_ENABLE_SHIFT)
/**
 * Extract the SS_LPDDR_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_SS_LPDDR_ENABLE(x) (((x) & XS1_SS_LPDDR_ENABLE_MASK) >> XS1_SS_LPDDR_ENABLE_SHIFT)
/**
 * Pack the value (v) of the SS_LPDDR_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_LPDDR_ENABLE_SET(x, v) (((x) & ~XS1_SS_LPDDR_ENABLE_MASK) | (((v) << XS1_SS_LPDDR_ENABLE_SHIFT) & XS1_SS_LPDDR_ENABLE_MASK))
///@}
/**
 * \name SS_LPDDR_MUXTO_CORE1
 * \anchor SS_LPDDR_MUXTO_CORE1
 * Defines which xCORE has access to the LPDDR controller via the mux
 */
///@{
#define XS1_SS_LPDDR_MUXTO_CORE1_SHIFT 0x1
#define XS1_SS_LPDDR_MUXTO_CORE1_SIZE 0x1
#define XS1_SS_LPDDR_MUXTO_CORE1_MASK (((1 << XS1_SS_LPDDR_MUXTO_CORE1_SIZE) - 1) << XS1_SS_LPDDR_MUXTO_CORE1_SHIFT)
/**
 * Extract the SS_LPDDR_MUXTO_CORE1 bitfield from a packed word x and return it.
 */
#define XS1_SS_LPDDR_MUXTO_CORE1(x) (((x) & XS1_SS_LPDDR_MUXTO_CORE1_MASK) >> XS1_SS_LPDDR_MUXTO_CORE1_SHIFT)
/**
 * Pack the value (v) of the SS_LPDDR_MUXTO_CORE1 bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_LPDDR_MUXTO_CORE1_SET(x, v) (((x) & ~XS1_SS_LPDDR_MUXTO_CORE1_MASK) | (((v) << XS1_SS_LPDDR_MUXTO_CORE1_SHIFT) & XS1_SS_LPDDR_MUXTO_CORE1_MASK))
///@}
/**
 * \name SS_TEST_MODE_BOOT_JTAG
 * \anchor SS_TEST_MODE_BOOT_JTAG
 * If set to 1, set the boot mode to boot from JTAG
 */
///@{
#define XS1_SS_TEST_MODE_BOOT_JTAG_SHIFT 0x1d
#define XS1_SS_TEST_MODE_BOOT_JTAG_SIZE 0x1
#define XS1_SS_TEST_MODE_BOOT_JTAG_MASK (((1 << XS1_SS_TEST_MODE_BOOT_JTAG_SIZE) - 1) << XS1_SS_TEST_MODE_BOOT_JTAG_SHIFT)
/**
 * Extract the SS_TEST_MODE_BOOT_JTAG bitfield from a packed word x and return it.
 */
#define XS1_SS_TEST_MODE_BOOT_JTAG(x) (((x) & XS1_SS_TEST_MODE_BOOT_JTAG_MASK) >> XS1_SS_TEST_MODE_BOOT_JTAG_SHIFT)
/**
 * Pack the value (v) of the SS_TEST_MODE_BOOT_JTAG bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_TEST_MODE_BOOT_JTAG_SET(x, v) (((x) & ~XS1_SS_TEST_MODE_BOOT_JTAG_MASK) | (((v) << XS1_SS_TEST_MODE_BOOT_JTAG_SHIFT) & XS1_SS_TEST_MODE_BOOT_JTAG_MASK))
///@}
/**
 * \name SS_APP_PLL_INPUT_FROM_SYS_PLL
 * \anchor SS_APP_PLL_INPUT_FROM_SYS_PLL
 * If set to 1, use the output of the core PLL as input,
 *       otherwise use the crystal oscillator as input.
 */
///@{
#define XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_SHIFT 0x1c
#define XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_SIZE 0x1
#define XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_MASK (((1 << XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_SIZE) - 1) << XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_SHIFT)
/**
 * Extract the SS_APP_PLL_INPUT_FROM_SYS_PLL bitfield from a packed word x and return it.
 */
#define XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL(x) (((x) & XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_MASK) >> XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_SHIFT)
/**
 * Pack the value (v) of the SS_APP_PLL_INPUT_FROM_SYS_PLL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_SET(x, v) (((x) & ~XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_MASK) | (((v) << XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_SHIFT) & XS1_SS_APP_PLL_INPUT_FROM_SYS_PLL_MASK))
///@}
/**
 * \name SS_APP_PLL_TO_DDR
 * \anchor SS_APP_PLL_TO_DDR
 * If set to 1, route the output clock for the Application PLL to the DDR divider and DDR clock, else route it to the APP divider and APP clock
 */
///@{
#define XS1_SS_APP_PLL_TO_DDR_SHIFT 0x1f
#define XS1_SS_APP_PLL_TO_DDR_SIZE 0x1
#define XS1_SS_APP_PLL_TO_DDR_MASK (((1 << XS1_SS_APP_PLL_TO_DDR_SIZE) - 1) << XS1_SS_APP_PLL_TO_DDR_SHIFT)
/**
 * Extract the SS_APP_PLL_TO_DDR bitfield from a packed word x and return it.
 */
#define XS1_SS_APP_PLL_TO_DDR(x) (((x) & XS1_SS_APP_PLL_TO_DDR_MASK) >> XS1_SS_APP_PLL_TO_DDR_SHIFT)
/**
 * Pack the value (v) of the SS_APP_PLL_TO_DDR bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_APP_PLL_TO_DDR_SET(x, v) (((x) & ~XS1_SS_APP_PLL_TO_DDR_MASK) | (((v) << XS1_SS_APP_PLL_TO_DDR_SHIFT) & XS1_SS_APP_PLL_TO_DDR_MASK))
///@}
/**
 * \name SS_TEST_MODE_PLL_BYPASS
 * \anchor SS_TEST_MODE_PLL_BYPASS
 * If set to 1, set the PLL to be bypassed
 */
///@{
#define XS1_SS_TEST_MODE_PLL_BYPASS_SHIFT 0x1c
#define XS1_SS_TEST_MODE_PLL_BYPASS_SIZE 0x1
#define XS1_SS_TEST_MODE_PLL_BYPASS_MASK (((1 << XS1_SS_TEST_MODE_PLL_BYPASS_SIZE) - 1) << XS1_SS_TEST_MODE_PLL_BYPASS_SHIFT)
/**
 * Extract the SS_TEST_MODE_PLL_BYPASS bitfield from a packed word x and return it.
 */
#define XS1_SS_TEST_MODE_PLL_BYPASS(x) (((x) & XS1_SS_TEST_MODE_PLL_BYPASS_MASK) >> XS1_SS_TEST_MODE_PLL_BYPASS_SHIFT)
/**
 * Pack the value (v) of the SS_TEST_MODE_PLL_BYPASS bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_TEST_MODE_PLL_BYPASS_SET(x, v) (((x) & ~XS1_SS_TEST_MODE_PLL_BYPASS_MASK) | (((v) << XS1_SS_TEST_MODE_PLL_BYPASS_SHIFT) & XS1_SS_TEST_MODE_PLL_BYPASS_MASK))
///@}
/**
 * \name SS_PLL_CTL_DISABLE
 * \anchor SS_PLL_CTL_DISABLE
 * If set to 1, the PLL is disabled.
 */
///@{
#define XS1_SS_PLL_CTL_DISABLE_SHIFT 0x1a
#define XS1_SS_PLL_CTL_DISABLE_SIZE 0x1
#define XS1_SS_PLL_CTL_DISABLE_MASK (((1 << XS1_SS_PLL_CTL_DISABLE_SIZE) - 1) << XS1_SS_PLL_CTL_DISABLE_SHIFT)
/**
 * Extract the SS_PLL_CTL_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_DISABLE(x) (((x) & XS1_SS_PLL_CTL_DISABLE_MASK) >> XS1_SS_PLL_CTL_DISABLE_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_DISABLE_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_DISABLE_MASK) | (((v) << XS1_SS_PLL_CTL_DISABLE_SHIFT) & XS1_SS_PLL_CTL_DISABLE_MASK))
///@}
/**
 * \name SS_APP_PLL_BYPASS
 * \anchor SS_APP_PLL_BYPASS
 * If set to 1, set the APP PLL to be bypassed
 */
///@{
#define XS1_SS_APP_PLL_BYPASS_SHIFT 0x1d
#define XS1_SS_APP_PLL_BYPASS_SIZE 0x1
#define XS1_SS_APP_PLL_BYPASS_MASK (((1 << XS1_SS_APP_PLL_BYPASS_SIZE) - 1) << XS1_SS_APP_PLL_BYPASS_SHIFT)
/**
 * Extract the SS_APP_PLL_BYPASS bitfield from a packed word x and return it.
 */
#define XS1_SS_APP_PLL_BYPASS(x) (((x) & XS1_SS_APP_PLL_BYPASS_MASK) >> XS1_SS_APP_PLL_BYPASS_SHIFT)
/**
 * Pack the value (v) of the SS_APP_PLL_BYPASS bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_APP_PLL_BYPASS_SET(x, v) (((x) & ~XS1_SS_APP_PLL_BYPASS_MASK) | (((v) << XS1_SS_APP_PLL_BYPASS_SHIFT) & XS1_SS_APP_PLL_BYPASS_MASK))
///@}
/**
 * \name SS_PLL_CTL_NLOCK
 * \anchor SS_PLL_CTL_NLOCK
 * If set to 1, the chip will not wait for the PLL to re-lock. Only use this
 *       if a gradual change is made to the PLL
 */
///@{
#define XS1_SS_PLL_CTL_NLOCK_SHIFT 0x1e
#define XS1_SS_PLL_CTL_NLOCK_SIZE 0x1
#define XS1_SS_PLL_CTL_NLOCK_MASK (((1 << XS1_SS_PLL_CTL_NLOCK_SIZE) - 1) << XS1_SS_PLL_CTL_NLOCK_SHIFT)
/**
 * Extract the SS_PLL_CTL_NLOCK bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_NLOCK(x) (((x) & XS1_SS_PLL_CTL_NLOCK_MASK) >> XS1_SS_PLL_CTL_NLOCK_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_NLOCK bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_NLOCK_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_NLOCK_MASK) | (((v) << XS1_SS_PLL_CTL_NLOCK_SHIFT) & XS1_SS_PLL_CTL_NLOCK_MASK))
///@}
/**
 * \name SS_PLL_CTL_NRESET
 * \anchor SS_PLL_CTL_NRESET
 * If set to 1, the chip will not be reset
 */
///@{
#define XS1_SS_PLL_CTL_NRESET_SHIFT 0x1f
#define XS1_SS_PLL_CTL_NRESET_SIZE 0x1
#define XS1_SS_PLL_CTL_NRESET_MASK (((1 << XS1_SS_PLL_CTL_NRESET_SIZE) - 1) << XS1_SS_PLL_CTL_NRESET_SHIFT)
/**
 * Extract the SS_PLL_CTL_NRESET bitfield from a packed word x and return it.
 */
#define XS1_SS_PLL_CTL_NRESET(x) (((x) & XS1_SS_PLL_CTL_NRESET_MASK) >> XS1_SS_PLL_CTL_NRESET_SHIFT)
/**
 * Pack the value (v) of the SS_PLL_CTL_NRESET bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_PLL_CTL_NRESET_SET(x, v) (((x) & ~XS1_SS_PLL_CTL_NRESET_MASK) | (((v) << XS1_SS_PLL_CTL_NRESET_SHIFT) & XS1_SS_PLL_CTL_NRESET_MASK))
///@}
/**
 * \name SS_APP_PLL_SEL_OUT_DDR
 * \anchor SS_APP_PLL_SEL_OUT_DDR
 * If set to 1, the Application PLL output will be sent to the DDR rather than the IO
 */
///@{
#define XS1_SS_APP_PLL_SEL_OUT_DDR_SHIFT 0x1f
#define XS1_SS_APP_PLL_SEL_OUT_DDR_SIZE 0x1
#define XS1_SS_APP_PLL_SEL_OUT_DDR_MASK (((1 << XS1_SS_APP_PLL_SEL_OUT_DDR_SIZE) - 1) << XS1_SS_APP_PLL_SEL_OUT_DDR_SHIFT)
/**
 * Extract the SS_APP_PLL_SEL_OUT_DDR bitfield from a packed word x and return it.
 */
#define XS1_SS_APP_PLL_SEL_OUT_DDR(x) (((x) & XS1_SS_APP_PLL_SEL_OUT_DDR_MASK) >> XS1_SS_APP_PLL_SEL_OUT_DDR_SHIFT)
/**
 * Pack the value (v) of the SS_APP_PLL_SEL_OUT_DDR bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_APP_PLL_SEL_OUT_DDR_SET(x, v) (((x) & ~XS1_SS_APP_PLL_SEL_OUT_DDR_MASK) | (((v) << XS1_SS_APP_PLL_SEL_OUT_DDR_SHIFT) & XS1_SS_APP_PLL_SEL_OUT_DDR_MASK))
///@}
/**
 * \name SS_CLK_DIVIDER_CLK_DIV
 * \anchor SS_CLK_DIVIDER_CLK_DIV
 * SSwitch clock divider
 */
///@{
#define XS1_SS_CLK_DIVIDER_CLK_DIV_SHIFT 0x0
#define XS1_SS_CLK_DIVIDER_CLK_DIV_SIZE 0x10
#define XS1_SS_CLK_DIVIDER_CLK_DIV_MASK (((1 << XS1_SS_CLK_DIVIDER_CLK_DIV_SIZE) - 1) << XS1_SS_CLK_DIVIDER_CLK_DIV_SHIFT)
/**
 * Extract the SS_CLK_DIVIDER_CLK_DIV bitfield from a packed word x and return it.
 */
#define XS1_SS_CLK_DIVIDER_CLK_DIV(x) (((x) & XS1_SS_CLK_DIVIDER_CLK_DIV_MASK) >> XS1_SS_CLK_DIVIDER_CLK_DIV_SHIFT)
/**
 * Pack the value (v) of the SS_CLK_DIVIDER_CLK_DIV bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_CLK_DIVIDER_CLK_DIV_SET(x, v) (((x) & ~XS1_SS_CLK_DIVIDER_CLK_DIV_MASK) | (((v) << XS1_SS_CLK_DIVIDER_CLK_DIV_SHIFT) & XS1_SS_CLK_DIVIDER_CLK_DIV_MASK))
///@}
/**
 * \name SS_SSWITCH_REF_CLK_DIV
 * \anchor SS_SSWITCH_REF_CLK_DIV
 * Software reference clock divider
 */
///@{
#define XS1_SS_SSWITCH_REF_CLK_DIV_SHIFT 0x0
#define XS1_SS_SSWITCH_REF_CLK_DIV_SIZE 0x10
#define XS1_SS_SSWITCH_REF_CLK_DIV_MASK (((1 << XS1_SS_SSWITCH_REF_CLK_DIV_SIZE) - 1) << XS1_SS_SSWITCH_REF_CLK_DIV_SHIFT)
/**
 * Extract the SS_SSWITCH_REF_CLK_DIV bitfield from a packed word x and return it.
 */
#define XS1_SS_SSWITCH_REF_CLK_DIV(x) (((x) & XS1_SS_SSWITCH_REF_CLK_DIV_MASK) >> XS1_SS_SSWITCH_REF_CLK_DIV_SHIFT)
/**
 * Pack the value (v) of the SS_SSWITCH_REF_CLK_DIV bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_SSWITCH_REF_CLK_DIV_SET(x, v) (((x) & ~XS1_SS_SSWITCH_REF_CLK_DIV_MASK) | (((v) << XS1_SS_SSWITCH_REF_CLK_DIV_SHIFT) & XS1_SS_SSWITCH_REF_CLK_DIV_MASK))
///@}
/**
 * \name SS_SSWITCH_MIPI_CLK_DIV
 * \anchor SS_SSWITCH_MIPI_CLK_DIV
 * MIPI shim clock divider. When set to ``X`` the input clock
 *       is divided by ``2(X+1)``.
 */
///@{
#define XS1_SS_SSWITCH_MIPI_CLK_DIV_SHIFT 0x0
#define XS1_SS_SSWITCH_MIPI_CLK_DIV_SIZE 0x10
#define XS1_SS_SSWITCH_MIPI_CLK_DIV_MASK (((1 << XS1_SS_SSWITCH_MIPI_CLK_DIV_SIZE) - 1) << XS1_SS_SSWITCH_MIPI_CLK_DIV_SHIFT)
/**
 * Extract the SS_SSWITCH_MIPI_CLK_DIV bitfield from a packed word x and return it.
 */
#define XS1_SS_SSWITCH_MIPI_CLK_DIV(x) (((x) & XS1_SS_SSWITCH_MIPI_CLK_DIV_MASK) >> XS1_SS_SSWITCH_MIPI_CLK_DIV_SHIFT)
/**
 * Pack the value (v) of the SS_SSWITCH_MIPI_CLK_DIV bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_SSWITCH_MIPI_CLK_DIV_SET(x, v) (((x) & ~XS1_SS_SSWITCH_MIPI_CLK_DIV_MASK) | (((v) << XS1_SS_SSWITCH_MIPI_CLK_DIV_SHIFT) & XS1_SS_SSWITCH_MIPI_CLK_DIV_MASK))
///@}
/**
 * \name SS_SSWITCH_MIPI_CLK_DIV_DISABLE
 * \anchor SS_SSWITCH_MIPI_CLK_DIV_DISABLE
 * MIPI clock divider disable. When set to 0, the
 *       divider is enabled.
 */
///@{
#define XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_SHIFT 0x10
#define XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_SIZE 0x1
#define XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_MASK (((1 << XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_SIZE) - 1) << XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_SHIFT)
/**
 * Extract the SS_SSWITCH_MIPI_CLK_DIV_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE(x) (((x) & XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_MASK) >> XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_SHIFT)
/**
 * Pack the value (v) of the SS_SSWITCH_MIPI_CLK_DIV_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_SET(x, v) (((x) & ~XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_MASK) | (((v) << XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_SHIFT) & XS1_SS_SSWITCH_MIPI_CLK_DIV_DISABLE_MASK))
///@}
/**
 * \name SS_DDR_CLK_DIV
 * \anchor SS_DDR_CLK_DIV
 * LPDDR clock divider. When set to ``X`` the input clock
 *       is divided by ``2(X+1)``.
 */
///@{
#define XS1_SS_DDR_CLK_DIV_SHIFT 0x0
#define XS1_SS_DDR_CLK_DIV_SIZE 0x10
#define XS1_SS_DDR_CLK_DIV_MASK (((1 << XS1_SS_DDR_CLK_DIV_SIZE) - 1) << XS1_SS_DDR_CLK_DIV_SHIFT)
/**
 * Extract the SS_DDR_CLK_DIV bitfield from a packed word x and return it.
 */
#define XS1_SS_DDR_CLK_DIV(x) (((x) & XS1_SS_DDR_CLK_DIV_MASK) >> XS1_SS_DDR_CLK_DIV_SHIFT)
/**
 * Pack the value (v) of the SS_DDR_CLK_DIV bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DDR_CLK_DIV_SET(x, v) (((x) & ~XS1_SS_DDR_CLK_DIV_MASK) | (((v) << XS1_SS_DDR_CLK_DIV_SHIFT) & XS1_SS_DDR_CLK_DIV_MASK))
///@}
/**
 * \name SS_DDR_CLK_DIV_DISABLE
 * \anchor SS_DDR_CLK_DIV_DISABLE
 * LPDDR clock divider disable. When set to 0, the
 *       divider is enabled.
 */
///@{
#define XS1_SS_DDR_CLK_DIV_DISABLE_SHIFT 0x10
#define XS1_SS_DDR_CLK_DIV_DISABLE_SIZE 0x1
#define XS1_SS_DDR_CLK_DIV_DISABLE_MASK (((1 << XS1_SS_DDR_CLK_DIV_DISABLE_SIZE) - 1) << XS1_SS_DDR_CLK_DIV_DISABLE_SHIFT)
/**
 * Extract the SS_DDR_CLK_DIV_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_SS_DDR_CLK_DIV_DISABLE(x) (((x) & XS1_SS_DDR_CLK_DIV_DISABLE_MASK) >> XS1_SS_DDR_CLK_DIV_DISABLE_SHIFT)
/**
 * Pack the value (v) of the SS_DDR_CLK_DIV_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DDR_CLK_DIV_DISABLE_SET(x, v) (((x) & ~XS1_SS_DDR_CLK_DIV_DISABLE_MASK) | (((v) << XS1_SS_DDR_CLK_DIV_DISABLE_SHIFT) & XS1_SS_DDR_CLK_DIV_DISABLE_MASK))
///@}
/**
 * \name SS_DDR_CLK_FROM_APP_PLL
 * \anchor SS_DDR_CLK_FROM_APP_PLL
 * If set to 1, the secondary PLL is used as a source for
 *       the LPDDR clock divider. By default, the output of the core PLL is used.
 */
///@{
#define XS1_SS_DDR_CLK_FROM_APP_PLL_SHIFT 0x1f
#define XS1_SS_DDR_CLK_FROM_APP_PLL_SIZE 0x1
#define XS1_SS_DDR_CLK_FROM_APP_PLL_MASK (((1 << XS1_SS_DDR_CLK_FROM_APP_PLL_SIZE) - 1) << XS1_SS_DDR_CLK_FROM_APP_PLL_SHIFT)
/**
 * Extract the SS_DDR_CLK_FROM_APP_PLL bitfield from a packed word x and return it.
 */
#define XS1_SS_DDR_CLK_FROM_APP_PLL(x) (((x) & XS1_SS_DDR_CLK_FROM_APP_PLL_MASK) >> XS1_SS_DDR_CLK_FROM_APP_PLL_SHIFT)
/**
 * Pack the value (v) of the SS_DDR_CLK_FROM_APP_PLL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_DDR_CLK_FROM_APP_PLL_SET(x, v) (((x) & ~XS1_SS_DDR_CLK_FROM_APP_PLL_MASK) | (((v) << XS1_SS_DDR_CLK_FROM_APP_PLL_SHIFT) & XS1_SS_DDR_CLK_FROM_APP_PLL_MASK))
///@}
/**
 * \name SS_MIPI_CLK_FROM_APP_PLL
 * \anchor SS_MIPI_CLK_FROM_APP_PLL
 * If set to 1, the secondary PLL is used as a source for
 *       the MIPI shim clock divider. By default, the output of the core PLL is used.
 */
///@{
#define XS1_SS_MIPI_CLK_FROM_APP_PLL_SHIFT 0x1f
#define XS1_SS_MIPI_CLK_FROM_APP_PLL_SIZE 0x1
#define XS1_SS_MIPI_CLK_FROM_APP_PLL_MASK (((1 << XS1_SS_MIPI_CLK_FROM_APP_PLL_SIZE) - 1) << XS1_SS_MIPI_CLK_FROM_APP_PLL_SHIFT)
/**
 * Extract the SS_MIPI_CLK_FROM_APP_PLL bitfield from a packed word x and return it.
 */
#define XS1_SS_MIPI_CLK_FROM_APP_PLL(x) (((x) & XS1_SS_MIPI_CLK_FROM_APP_PLL_MASK) >> XS1_SS_MIPI_CLK_FROM_APP_PLL_SHIFT)
/**
 * Pack the value (v) of the SS_MIPI_CLK_FROM_APP_PLL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_MIPI_CLK_FROM_APP_PLL_SET(x, v) (((x) & ~XS1_SS_MIPI_CLK_FROM_APP_PLL_MASK) | (((v) << XS1_SS_MIPI_CLK_FROM_APP_PLL_SHIFT) & XS1_SS_MIPI_CLK_FROM_APP_PLL_MASK))
///@}
/**
 * \name SS_APP_CLK_DIV
 * \anchor SS_APP_CLK_DIV
 * Application clock divider. When set to ``X``, the output
 *       of the secondary PLL will be divided by ``2(X+1)`` in order to form the
 *       output on the output pin
 */
///@{
#define XS1_SS_APP_CLK_DIV_SHIFT 0x0
#define XS1_SS_APP_CLK_DIV_SIZE 0x10
#define XS1_SS_APP_CLK_DIV_MASK (((1 << XS1_SS_APP_CLK_DIV_SIZE) - 1) << XS1_SS_APP_CLK_DIV_SHIFT)
/**
 * Extract the SS_APP_CLK_DIV bitfield from a packed word x and return it.
 */
#define XS1_SS_APP_CLK_DIV(x) (((x) & XS1_SS_APP_CLK_DIV_MASK) >> XS1_SS_APP_CLK_DIV_SHIFT)
/**
 * Pack the value (v) of the SS_APP_CLK_DIV bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_APP_CLK_DIV_SET(x, v) (((x) & ~XS1_SS_APP_CLK_DIV_MASK) | (((v) << XS1_SS_APP_CLK_DIV_SHIFT) & XS1_SS_APP_CLK_DIV_MASK))
///@}
/**
 * \name SS_APP_CLK_DIV_DISABLE
 * \anchor SS_APP_CLK_DIV_DISABLE
 * Application clock divider disable. When set to 0, the
 *       divider is enabled, and pin X1D11 will be connected to the
 *       application clock rather than to port 1D.
 */
///@{
#define XS1_SS_APP_CLK_DIV_DISABLE_SHIFT 0x10
#define XS1_SS_APP_CLK_DIV_DISABLE_SIZE 0x1
#define XS1_SS_APP_CLK_DIV_DISABLE_MASK (((1 << XS1_SS_APP_CLK_DIV_DISABLE_SIZE) - 1) << XS1_SS_APP_CLK_DIV_DISABLE_SHIFT)
/**
 * Extract the SS_APP_CLK_DIV_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_SS_APP_CLK_DIV_DISABLE(x) (((x) & XS1_SS_APP_CLK_DIV_DISABLE_MASK) >> XS1_SS_APP_CLK_DIV_DISABLE_SHIFT)
/**
 * Pack the value (v) of the SS_APP_CLK_DIV_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_APP_CLK_DIV_DISABLE_SET(x, v) (((x) & ~XS1_SS_APP_CLK_DIV_DISABLE_MASK) | (((v) << XS1_SS_APP_CLK_DIV_DISABLE_SHIFT) & XS1_SS_APP_CLK_DIV_DISABLE_MASK))
///@}
/**
 * \name SS_APP_CLK_FROM_APP_PLL
 * \anchor SS_APP_CLK_FROM_APP_PLL
 * If set to 1, the secondary PLL is used as a source for
 *       the application clock divider. By default, the output of the core PLL is used.
 */
///@{
#define XS1_SS_APP_CLK_FROM_APP_PLL_SHIFT 0x1f
#define XS1_SS_APP_CLK_FROM_APP_PLL_SIZE 0x1
#define XS1_SS_APP_CLK_FROM_APP_PLL_MASK (((1 << XS1_SS_APP_CLK_FROM_APP_PLL_SIZE) - 1) << XS1_SS_APP_CLK_FROM_APP_PLL_SHIFT)
/**
 * Extract the SS_APP_CLK_FROM_APP_PLL bitfield from a packed word x and return it.
 */
#define XS1_SS_APP_CLK_FROM_APP_PLL(x) (((x) & XS1_SS_APP_CLK_FROM_APP_PLL_MASK) >> XS1_SS_APP_CLK_FROM_APP_PLL_SHIFT)
/**
 * Pack the value (v) of the SS_APP_CLK_FROM_APP_PLL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_APP_CLK_FROM_APP_PLL_SET(x, v) (((x) & ~XS1_SS_APP_CLK_FROM_APP_PLL_MASK) | (((v) << XS1_SS_APP_CLK_FROM_APP_PLL_SHIFT) & XS1_SS_APP_CLK_FROM_APP_PLL_MASK))
///@}
/**
 * \name SS_MIPI_CFG_CLK_DIV
 * \anchor SS_MIPI_CFG_CLK_DIV
 * MIPI PHY clock divider. When set to ``X``, the input
 *       clock will be divided by ``2(X+1)``.
 */
///@{
#define XS1_SS_MIPI_CFG_CLK_DIV_SHIFT 0x0
#define XS1_SS_MIPI_CFG_CLK_DIV_SIZE 0x10
#define XS1_SS_MIPI_CFG_CLK_DIV_MASK (((1 << XS1_SS_MIPI_CFG_CLK_DIV_SIZE) - 1) << XS1_SS_MIPI_CFG_CLK_DIV_SHIFT)
/**
 * Extract the SS_MIPI_CFG_CLK_DIV bitfield from a packed word x and return it.
 */
#define XS1_SS_MIPI_CFG_CLK_DIV(x) (((x) & XS1_SS_MIPI_CFG_CLK_DIV_MASK) >> XS1_SS_MIPI_CFG_CLK_DIV_SHIFT)
/**
 * Pack the value (v) of the SS_MIPI_CFG_CLK_DIV bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_MIPI_CFG_CLK_DIV_SET(x, v) (((x) & ~XS1_SS_MIPI_CFG_CLK_DIV_MASK) | (((v) << XS1_SS_MIPI_CFG_CLK_DIV_SHIFT) & XS1_SS_MIPI_CFG_CLK_DIV_MASK))
///@}
/**
 * \name SS_MIPI_CFG_CLK_DIV_DISABLE
 * \anchor SS_MIPI_CFG_CLK_DIV_DISABLE
 * MIPI PHY clock divider disable. When set to 0, the
 *       divider is enabled.
 */
///@{
#define XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_SHIFT 0x10
#define XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_SIZE 0x1
#define XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_MASK (((1 << XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_SIZE) - 1) << XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_SHIFT)
/**
 * Extract the SS_MIPI_CFG_CLK_DIV_DISABLE bitfield from a packed word x and return it.
 */
#define XS1_SS_MIPI_CFG_CLK_DIV_DISABLE(x) (((x) & XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_MASK) >> XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_SHIFT)
/**
 * Pack the value (v) of the SS_MIPI_CFG_CLK_DIV_DISABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_SET(x, v) (((x) & ~XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_MASK) | (((v) << XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_SHIFT) & XS1_SS_MIPI_CFG_CLK_DIV_DISABLE_MASK))
///@}
/**
 * \name SS_MIPI_CFG_CLK_FROM_APP_PLL
 * \anchor SS_MIPI_CFG_CLK_FROM_APP_PLL
 * If set to 1, the secondary PLL is used as a source for
 *       the MIPI PHY clock divider. By default, the output of the core PLL is used.
 */
///@{
#define XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_SHIFT 0x1f
#define XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_SIZE 0x1
#define XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_MASK (((1 << XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_SIZE) - 1) << XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_SHIFT)
/**
 * Extract the SS_MIPI_CFG_CLK_FROM_APP_PLL bitfield from a packed word x and return it.
 */
#define XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL(x) (((x) & XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_MASK) >> XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_SHIFT)
/**
 * Pack the value (v) of the SS_MIPI_CFG_CLK_FROM_APP_PLL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_SET(x, v) (((x) & ~XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_MASK) | (((v) << XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_SHIFT) & XS1_SS_MIPI_CFG_CLK_FROM_APP_PLL_MASK))
///@}
/**
 * \name SS_JTAG_DEVICE_ID_CONST_VAL
 * \anchor SS_JTAG_DEVICE_ID_CONST_VAL
 */
///@{
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SHIFT 0x0
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SIZE 0x1
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL_MASK (((1 << XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SIZE) - 1) << XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SHIFT)
/**
 * Extract the SS_JTAG_DEVICE_ID_CONST_VAL bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL(x) (((x) & XS1_SS_JTAG_DEVICE_ID_CONST_VAL_MASK) >> XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_DEVICE_ID_CONST_VAL bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SET(x, v) (((x) & ~XS1_SS_JTAG_DEVICE_ID_CONST_VAL_MASK) | (((v) << XS1_SS_JTAG_DEVICE_ID_CONST_VAL_SHIFT) & XS1_SS_JTAG_DEVICE_ID_CONST_VAL_MASK))
///@}
/**
 * \name SS_JTAG_DEVICE_ID_MANU_ID
 * \anchor SS_JTAG_DEVICE_ID_MANU_ID
 */
///@{
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID_SHIFT 0x1
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID_SIZE 0xb
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID_MASK (((1 << XS1_SS_JTAG_DEVICE_ID_MANU_ID_SIZE) - 1) << XS1_SS_JTAG_DEVICE_ID_MANU_ID_SHIFT)
/**
 * Extract the SS_JTAG_DEVICE_ID_MANU_ID bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID(x) (((x) & XS1_SS_JTAG_DEVICE_ID_MANU_ID_MASK) >> XS1_SS_JTAG_DEVICE_ID_MANU_ID_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_DEVICE_ID_MANU_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_DEVICE_ID_MANU_ID_SET(x, v) (((x) & ~XS1_SS_JTAG_DEVICE_ID_MANU_ID_MASK) | (((v) << XS1_SS_JTAG_DEVICE_ID_MANU_ID_SHIFT) & XS1_SS_JTAG_DEVICE_ID_MANU_ID_MASK))
///@}
/**
 * \name SS_JTAG_DEVICE_ID_PART_NUM
 * \anchor SS_JTAG_DEVICE_ID_PART_NUM
 */
///@{
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM_SHIFT 0xc
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM_SIZE 0x10
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM_MASK (((1 << XS1_SS_JTAG_DEVICE_ID_PART_NUM_SIZE) - 1) << XS1_SS_JTAG_DEVICE_ID_PART_NUM_SHIFT)
/**
 * Extract the SS_JTAG_DEVICE_ID_PART_NUM bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM(x) (((x) & XS1_SS_JTAG_DEVICE_ID_PART_NUM_MASK) >> XS1_SS_JTAG_DEVICE_ID_PART_NUM_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_DEVICE_ID_PART_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_DEVICE_ID_PART_NUM_SET(x, v) (((x) & ~XS1_SS_JTAG_DEVICE_ID_PART_NUM_MASK) | (((v) << XS1_SS_JTAG_DEVICE_ID_PART_NUM_SHIFT) & XS1_SS_JTAG_DEVICE_ID_PART_NUM_MASK))
///@}
/**
 * \name SS_JTAG_DEVICE_ID_VERSION
 * \anchor SS_JTAG_DEVICE_ID_VERSION
 */
///@{
#define XS1_SS_JTAG_DEVICE_ID_VERSION_SHIFT 0x1c
#define XS1_SS_JTAG_DEVICE_ID_VERSION_SIZE 0x4
#define XS1_SS_JTAG_DEVICE_ID_VERSION_MASK (((1 << XS1_SS_JTAG_DEVICE_ID_VERSION_SIZE) - 1) << XS1_SS_JTAG_DEVICE_ID_VERSION_SHIFT)
/**
 * Extract the SS_JTAG_DEVICE_ID_VERSION bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_DEVICE_ID_VERSION(x) (((x) & XS1_SS_JTAG_DEVICE_ID_VERSION_MASK) >> XS1_SS_JTAG_DEVICE_ID_VERSION_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_DEVICE_ID_VERSION bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_DEVICE_ID_VERSION_SET(x, v) (((x) & ~XS1_SS_JTAG_DEVICE_ID_VERSION_MASK) | (((v) << XS1_SS_JTAG_DEVICE_ID_VERSION_SHIFT) & XS1_SS_JTAG_DEVICE_ID_VERSION_MASK))
///@}
/**
 * \name SS_JTAG_USERCODE_MASKID
 * \anchor SS_JTAG_USERCODE_MASKID
 * metal fixable ID code 
 */
///@{
#define XS1_SS_JTAG_USERCODE_MASKID_SHIFT 0x0
#define XS1_SS_JTAG_USERCODE_MASKID_SIZE 0x12
#define XS1_SS_JTAG_USERCODE_MASKID_MASK (((1 << XS1_SS_JTAG_USERCODE_MASKID_SIZE) - 1) << XS1_SS_JTAG_USERCODE_MASKID_SHIFT)
/**
 * Extract the SS_JTAG_USERCODE_MASKID bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_USERCODE_MASKID(x) (((x) & XS1_SS_JTAG_USERCODE_MASKID_MASK) >> XS1_SS_JTAG_USERCODE_MASKID_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_USERCODE_MASKID bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_USERCODE_MASKID_SET(x, v) (((x) & ~XS1_SS_JTAG_USERCODE_MASKID_MASK) | (((v) << XS1_SS_JTAG_USERCODE_MASKID_SHIFT) & XS1_SS_JTAG_USERCODE_MASKID_MASK))
///@}
/**
 * \name SS_JTAG_USERCODE_OTP
 * \anchor SS_JTAG_USERCODE_OTP
 * JTAG USERCODE value programmed into OTP SR
 */
///@{
#define XS1_SS_JTAG_USERCODE_OTP_SHIFT 0x12
#define XS1_SS_JTAG_USERCODE_OTP_SIZE 0xe
#define XS1_SS_JTAG_USERCODE_OTP_MASK (((1 << XS1_SS_JTAG_USERCODE_OTP_SIZE) - 1) << XS1_SS_JTAG_USERCODE_OTP_SHIFT)
/**
 * Extract the SS_JTAG_USERCODE_OTP bitfield from a packed word x and return it.
 */
#define XS1_SS_JTAG_USERCODE_OTP(x) (((x) & XS1_SS_JTAG_USERCODE_OTP_MASK) >> XS1_SS_JTAG_USERCODE_OTP_SHIFT)
/**
 * Pack the value (v) of the SS_JTAG_USERCODE_OTP bitfield into a packed word x and return the packed field.
 */
#define XS1_SS_JTAG_USERCODE_OTP_SET(x, v) (((x) & ~XS1_SS_JTAG_USERCODE_OTP_MASK) | (((v) << XS1_SS_JTAG_USERCODE_OTP_SHIFT) & XS1_SS_JTAG_USERCODE_OTP_MASK))
///@}
/**
 * \name DIM0_DIR
 * \anchor DIM0_DIR
 * The direction for packets whose dimension is 0.  
 */
///@{
#define XS1_DIM0_DIR_SHIFT 0x0
#define XS1_DIM0_DIR_SIZE 0x4
#define XS1_DIM0_DIR_MASK (((1 << XS1_DIM0_DIR_SIZE) - 1) << XS1_DIM0_DIR_SHIFT)
/**
 * Extract the DIM0_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM0_DIR(x) (((x) & XS1_DIM0_DIR_MASK) >> XS1_DIM0_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM0_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM0_DIR_SET(x, v) (((x) & ~XS1_DIM0_DIR_MASK) | (((v) << XS1_DIM0_DIR_SHIFT) & XS1_DIM0_DIR_MASK))
///@}
/**
 * \name DIM1_DIR
 * \anchor DIM1_DIR
 * The direction for packets whose dimension is 1.  
 */
///@{
#define XS1_DIM1_DIR_SHIFT 0x4
#define XS1_DIM1_DIR_SIZE 0x4
#define XS1_DIM1_DIR_MASK (((1 << XS1_DIM1_DIR_SIZE) - 1) << XS1_DIM1_DIR_SHIFT)
/**
 * Extract the DIM1_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM1_DIR(x) (((x) & XS1_DIM1_DIR_MASK) >> XS1_DIM1_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM1_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM1_DIR_SET(x, v) (((x) & ~XS1_DIM1_DIR_MASK) | (((v) << XS1_DIM1_DIR_SHIFT) & XS1_DIM1_DIR_MASK))
///@}
/**
 * \name DIM2_DIR
 * \anchor DIM2_DIR
 * The direction for packets whose dimension is 2.  
 */
///@{
#define XS1_DIM2_DIR_SHIFT 0x8
#define XS1_DIM2_DIR_SIZE 0x4
#define XS1_DIM2_DIR_MASK (((1 << XS1_DIM2_DIR_SIZE) - 1) << XS1_DIM2_DIR_SHIFT)
/**
 * Extract the DIM2_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM2_DIR(x) (((x) & XS1_DIM2_DIR_MASK) >> XS1_DIM2_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM2_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM2_DIR_SET(x, v) (((x) & ~XS1_DIM2_DIR_MASK) | (((v) << XS1_DIM2_DIR_SHIFT) & XS1_DIM2_DIR_MASK))
///@}
/**
 * \name DIM3_DIR
 * \anchor DIM3_DIR
 * The direction for packets whose dimension is 3.  
 */
///@{
#define XS1_DIM3_DIR_SHIFT 0xc
#define XS1_DIM3_DIR_SIZE 0x4
#define XS1_DIM3_DIR_MASK (((1 << XS1_DIM3_DIR_SIZE) - 1) << XS1_DIM3_DIR_SHIFT)
/**
 * Extract the DIM3_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM3_DIR(x) (((x) & XS1_DIM3_DIR_MASK) >> XS1_DIM3_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM3_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM3_DIR_SET(x, v) (((x) & ~XS1_DIM3_DIR_MASK) | (((v) << XS1_DIM3_DIR_SHIFT) & XS1_DIM3_DIR_MASK))
///@}
/**
 * \name DIM4_DIR
 * \anchor DIM4_DIR
 * The direction for packets whose dimension is 4.  
 */
///@{
#define XS1_DIM4_DIR_SHIFT 0x10
#define XS1_DIM4_DIR_SIZE 0x4
#define XS1_DIM4_DIR_MASK (((1 << XS1_DIM4_DIR_SIZE) - 1) << XS1_DIM4_DIR_SHIFT)
/**
 * Extract the DIM4_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM4_DIR(x) (((x) & XS1_DIM4_DIR_MASK) >> XS1_DIM4_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM4_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM4_DIR_SET(x, v) (((x) & ~XS1_DIM4_DIR_MASK) | (((v) << XS1_DIM4_DIR_SHIFT) & XS1_DIM4_DIR_MASK))
///@}
/**
 * \name DIM5_DIR
 * \anchor DIM5_DIR
 * The direction for packets whose dimension is 5.  
 */
///@{
#define XS1_DIM5_DIR_SHIFT 0x14
#define XS1_DIM5_DIR_SIZE 0x4
#define XS1_DIM5_DIR_MASK (((1 << XS1_DIM5_DIR_SIZE) - 1) << XS1_DIM5_DIR_SHIFT)
/**
 * Extract the DIM5_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM5_DIR(x) (((x) & XS1_DIM5_DIR_MASK) >> XS1_DIM5_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM5_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM5_DIR_SET(x, v) (((x) & ~XS1_DIM5_DIR_MASK) | (((v) << XS1_DIM5_DIR_SHIFT) & XS1_DIM5_DIR_MASK))
///@}
/**
 * \name DIM6_DIR
 * \anchor DIM6_DIR
 * The direction for packets whose dimension is 6.  
 */
///@{
#define XS1_DIM6_DIR_SHIFT 0x18
#define XS1_DIM6_DIR_SIZE 0x4
#define XS1_DIM6_DIR_MASK (((1 << XS1_DIM6_DIR_SIZE) - 1) << XS1_DIM6_DIR_SHIFT)
/**
 * Extract the DIM6_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM6_DIR(x) (((x) & XS1_DIM6_DIR_MASK) >> XS1_DIM6_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM6_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM6_DIR_SET(x, v) (((x) & ~XS1_DIM6_DIR_MASK) | (((v) << XS1_DIM6_DIR_SHIFT) & XS1_DIM6_DIR_MASK))
///@}
/**
 * \name DIM7_DIR
 * \anchor DIM7_DIR
 * The direction for packets whose dimension is 7.  
 */
///@{
#define XS1_DIM7_DIR_SHIFT 0x1c
#define XS1_DIM7_DIR_SIZE 0x4
#define XS1_DIM7_DIR_MASK (((1 << XS1_DIM7_DIR_SIZE) - 1) << XS1_DIM7_DIR_SHIFT)
/**
 * Extract the DIM7_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM7_DIR(x) (((x) & XS1_DIM7_DIR_MASK) >> XS1_DIM7_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM7_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM7_DIR_SET(x, v) (((x) & ~XS1_DIM7_DIR_MASK) | (((v) << XS1_DIM7_DIR_SHIFT) & XS1_DIM7_DIR_MASK))
///@}
/**
 * \name DIM8_DIR
 * \anchor DIM8_DIR
 * The direction for packets whose dimension is 8.  
 */
///@{
#define XS1_DIM8_DIR_SHIFT 0x0
#define XS1_DIM8_DIR_SIZE 0x4
#define XS1_DIM8_DIR_MASK (((1 << XS1_DIM8_DIR_SIZE) - 1) << XS1_DIM8_DIR_SHIFT)
/**
 * Extract the DIM8_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM8_DIR(x) (((x) & XS1_DIM8_DIR_MASK) >> XS1_DIM8_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM8_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM8_DIR_SET(x, v) (((x) & ~XS1_DIM8_DIR_MASK) | (((v) << XS1_DIM8_DIR_SHIFT) & XS1_DIM8_DIR_MASK))
///@}
/**
 * \name DIM9_DIR
 * \anchor DIM9_DIR
 * The direction for packets whose dimension is 9.  
 */
///@{
#define XS1_DIM9_DIR_SHIFT 0x4
#define XS1_DIM9_DIR_SIZE 0x4
#define XS1_DIM9_DIR_MASK (((1 << XS1_DIM9_DIR_SIZE) - 1) << XS1_DIM9_DIR_SHIFT)
/**
 * Extract the DIM9_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIM9_DIR(x) (((x) & XS1_DIM9_DIR_MASK) >> XS1_DIM9_DIR_SHIFT)
/**
 * Pack the value (v) of the DIM9_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIM9_DIR_SET(x, v) (((x) & ~XS1_DIM9_DIR_MASK) | (((v) << XS1_DIM9_DIR_SHIFT) & XS1_DIM9_DIR_MASK))
///@}
/**
 * \name DIMA_DIR
 * \anchor DIMA_DIR
 * The direction for packets whose dimension is A.  
 */
///@{
#define XS1_DIMA_DIR_SHIFT 0x8
#define XS1_DIMA_DIR_SIZE 0x4
#define XS1_DIMA_DIR_MASK (((1 << XS1_DIMA_DIR_SIZE) - 1) << XS1_DIMA_DIR_SHIFT)
/**
 * Extract the DIMA_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMA_DIR(x) (((x) & XS1_DIMA_DIR_MASK) >> XS1_DIMA_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMA_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMA_DIR_SET(x, v) (((x) & ~XS1_DIMA_DIR_MASK) | (((v) << XS1_DIMA_DIR_SHIFT) & XS1_DIMA_DIR_MASK))
///@}
/**
 * \name DIMB_DIR
 * \anchor DIMB_DIR
 * The direction for packets whose dimension is B.  
 */
///@{
#define XS1_DIMB_DIR_SHIFT 0xc
#define XS1_DIMB_DIR_SIZE 0x4
#define XS1_DIMB_DIR_MASK (((1 << XS1_DIMB_DIR_SIZE) - 1) << XS1_DIMB_DIR_SHIFT)
/**
 * Extract the DIMB_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMB_DIR(x) (((x) & XS1_DIMB_DIR_MASK) >> XS1_DIMB_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMB_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMB_DIR_SET(x, v) (((x) & ~XS1_DIMB_DIR_MASK) | (((v) << XS1_DIMB_DIR_SHIFT) & XS1_DIMB_DIR_MASK))
///@}
/**
 * \name DIMC_DIR
 * \anchor DIMC_DIR
 * The direction for packets whose dimension is C.  
 */
///@{
#define XS1_DIMC_DIR_SHIFT 0x10
#define XS1_DIMC_DIR_SIZE 0x4
#define XS1_DIMC_DIR_MASK (((1 << XS1_DIMC_DIR_SIZE) - 1) << XS1_DIMC_DIR_SHIFT)
/**
 * Extract the DIMC_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMC_DIR(x) (((x) & XS1_DIMC_DIR_MASK) >> XS1_DIMC_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMC_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMC_DIR_SET(x, v) (((x) & ~XS1_DIMC_DIR_MASK) | (((v) << XS1_DIMC_DIR_SHIFT) & XS1_DIMC_DIR_MASK))
///@}
/**
 * \name DIMD_DIR
 * \anchor DIMD_DIR
 * The direction for packets whose dimension is D.  
 */
///@{
#define XS1_DIMD_DIR_SHIFT 0x14
#define XS1_DIMD_DIR_SIZE 0x4
#define XS1_DIMD_DIR_MASK (((1 << XS1_DIMD_DIR_SIZE) - 1) << XS1_DIMD_DIR_SHIFT)
/**
 * Extract the DIMD_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMD_DIR(x) (((x) & XS1_DIMD_DIR_MASK) >> XS1_DIMD_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMD_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMD_DIR_SET(x, v) (((x) & ~XS1_DIMD_DIR_MASK) | (((v) << XS1_DIMD_DIR_SHIFT) & XS1_DIMD_DIR_MASK))
///@}
/**
 * \name DIME_DIR
 * \anchor DIME_DIR
 * The direction for packets whose dimension is E.  
 */
///@{
#define XS1_DIME_DIR_SHIFT 0x18
#define XS1_DIME_DIR_SIZE 0x4
#define XS1_DIME_DIR_MASK (((1 << XS1_DIME_DIR_SIZE) - 1) << XS1_DIME_DIR_SHIFT)
/**
 * Extract the DIME_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIME_DIR(x) (((x) & XS1_DIME_DIR_MASK) >> XS1_DIME_DIR_SHIFT)
/**
 * Pack the value (v) of the DIME_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIME_DIR_SET(x, v) (((x) & ~XS1_DIME_DIR_MASK) | (((v) << XS1_DIME_DIR_SHIFT) & XS1_DIME_DIR_MASK))
///@}
/**
 * \name DIMF_DIR
 * \anchor DIMF_DIR
 * The direction for packets whose dimension is F.  
 */
///@{
#define XS1_DIMF_DIR_SHIFT 0x1c
#define XS1_DIMF_DIR_SIZE 0x4
#define XS1_DIMF_DIR_MASK (((1 << XS1_DIMF_DIR_SIZE) - 1) << XS1_DIMF_DIR_SHIFT)
/**
 * Extract the DIMF_DIR bitfield from a packed word x and return it.
 */
#define XS1_DIMF_DIR(x) (((x) & XS1_DIMF_DIR_MASK) >> XS1_DIMF_DIR_SHIFT)
/**
 * Pack the value (v) of the DIMF_DIR bitfield into a packed word x and return the packed field.
 */
#define XS1_DIMF_DIR_SET(x, v) (((x) & ~XS1_DIMF_DIR_MASK) | (((v) << XS1_DIMF_DIR_SHIFT) & XS1_DIMF_DIR_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_ENABLE_INDEBUG
 * \anchor GLOBAL_DEBUG_ENABLE_INDEBUG
 * if DEBUGN Set 1 to enable inDebug bit to drive GlobalDebug.else  Reserved.
 */
///@{
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SHIFT 0x0
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SIZE 0x1
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_MASK (((1 << XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SIZE) - 1) << XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_ENABLE_INDEBUG bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG(x) (((x) & XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_MASK) >> XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_ENABLE_INDEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_MASK) | (((v) << XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_SHIFT) & XS1_GLOBAL_DEBUG_ENABLE_INDEBUG_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ
 * \anchor GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ
 * if DEBUGN Set 1 to enable GlobalDebug to generate debug request to XCore.else  Reserved.
 */
///@{
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SHIFT 0x1
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SIZE 0x1
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_MASK (((1 << XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SIZE) - 1) << XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ(x) (((x) & XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_MASK) >> XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_MASK) | (((v) << XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_SHIFT) & XS1_GLOBAL_DEBUG_ENABLE_GLOBAL_DEBUG_REQ_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG
 * \anchor GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG
 * If set, XCore0 is the source of last GlobalDebug event.
 */
///@{
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SHIFT 0x0
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SIZE 0x1
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_MASK (((1 << XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SIZE) - 1) << XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG(x) (((x) & XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_MASK) >> XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_MASK) | (((v) << XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_SHIFT) & XS1_GLOBAL_DEBUG_SOURCE_XCORE0_INDEBUG_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG
 * \anchor GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG
 * If set, XCore1 is the source of last GlobalDebug event.
 */
///@{
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SHIFT 0x1
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SIZE 0x1
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_MASK (((1 << XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SIZE) - 1) << XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG(x) (((x) & XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_MASK) >> XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_MASK) | (((v) << XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_SHIFT) & XS1_GLOBAL_DEBUG_SOURCE_XCORE1_INDEBUG_MASK))
///@}
/**
 * \name GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG
 * \anchor GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG
 * if DEBUGN If set, external pin, is the source of last GlobalDebug event.else  Reserved.
 */
///@{
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SHIFT 0x4
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SIZE 0x1
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_MASK (((1 << XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SIZE) - 1) << XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SHIFT)
/**
 * Extract the GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG bitfield from a packed word x and return it.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG(x) (((x) & XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_MASK) >> XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SHIFT)
/**
 * Pack the value (v) of the GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SET(x, v) (((x) & ~XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_MASK) | (((v) << XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_SHIFT) & XS1_GLOBAL_DEBUG_SOURCE_EXTERNAL_PAD_INDEBUG_MASK))
///@}
/**
 * \name LINK_SRC_INUSE
 * \anchor LINK_SRC_INUSE
 * 1 when the source side of the link is in use.
 */
///@{
#define XS1_LINK_SRC_INUSE_SHIFT 0x0
#define XS1_LINK_SRC_INUSE_SIZE 0x1
#define XS1_LINK_SRC_INUSE_MASK (((1 << XS1_LINK_SRC_INUSE_SIZE) - 1) << XS1_LINK_SRC_INUSE_SHIFT)
/**
 * Extract the LINK_SRC_INUSE bitfield from a packed word x and return it.
 */
#define XS1_LINK_SRC_INUSE(x) (((x) & XS1_LINK_SRC_INUSE_MASK) >> XS1_LINK_SRC_INUSE_SHIFT)
/**
 * Pack the value (v) of the LINK_SRC_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_SRC_INUSE_SET(x, v) (((x) & ~XS1_LINK_SRC_INUSE_MASK) | (((v) << XS1_LINK_SRC_INUSE_SHIFT) & XS1_LINK_SRC_INUSE_MASK))
///@}
/**
 * \name LINK_DST_INUSE
 * \anchor LINK_DST_INUSE
 * 1 when the dest side of the link is in use.
 */
///@{
#define XS1_LINK_DST_INUSE_SHIFT 0x1
#define XS1_LINK_DST_INUSE_SIZE 0x1
#define XS1_LINK_DST_INUSE_MASK (((1 << XS1_LINK_DST_INUSE_SIZE) - 1) << XS1_LINK_DST_INUSE_SHIFT)
/**
 * Extract the LINK_DST_INUSE bitfield from a packed word x and return it.
 */
#define XS1_LINK_DST_INUSE(x) (((x) & XS1_LINK_DST_INUSE_MASK) >> XS1_LINK_DST_INUSE_SHIFT)
/**
 * Pack the value (v) of the LINK_DST_INUSE bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_DST_INUSE_SET(x, v) (((x) & ~XS1_LINK_DST_INUSE_MASK) | (((v) << XS1_LINK_DST_INUSE_SHIFT) & XS1_LINK_DST_INUSE_MASK))
///@}
/**
 * \name LINK_JUNK
 * \anchor LINK_JUNK
 * 1 when the current packet is considered junk and will be thrown away.
 */
///@{
#define XS1_LINK_JUNK_SHIFT 0x2
#define XS1_LINK_JUNK_SIZE 0x1
#define XS1_LINK_JUNK_MASK (((1 << XS1_LINK_JUNK_SIZE) - 1) << XS1_LINK_JUNK_SHIFT)
/**
 * Extract the LINK_JUNK bitfield from a packed word x and return it.
 */
#define XS1_LINK_JUNK(x) (((x) & XS1_LINK_JUNK_MASK) >> XS1_LINK_JUNK_SHIFT)
/**
 * Pack the value (v) of the LINK_JUNK bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_JUNK_SET(x, v) (((x) & ~XS1_LINK_JUNK_MASK) | (((v) << XS1_LINK_JUNK_SHIFT) & XS1_LINK_JUNK_MASK))
///@}
/**
 * \name LINK_NETWORK
 * \anchor LINK_NETWORK
 * Determines the network to which this link belongs, reset as 0.
 */
///@{
#define XS1_LINK_NETWORK_SHIFT 0x4
#define XS1_LINK_NETWORK_SIZE 0x2
#define XS1_LINK_NETWORK_MASK (((1 << XS1_LINK_NETWORK_SIZE) - 1) << XS1_LINK_NETWORK_SHIFT)
/**
 * Extract the LINK_NETWORK bitfield from a packed word x and return it.
 */
#define XS1_LINK_NETWORK(x) (((x) & XS1_LINK_NETWORK_MASK) >> XS1_LINK_NETWORK_SHIFT)
/**
 * Pack the value (v) of the LINK_NETWORK bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_NETWORK_SET(x, v) (((x) & ~XS1_LINK_NETWORK_MASK) | (((v) << XS1_LINK_NETWORK_SHIFT) & XS1_LINK_NETWORK_MASK))
///@}
/**
 * \name LINK_DIRECTION
 * \anchor LINK_DIRECTION
 * The direction that this link operates in.
 */
///@{
#define XS1_LINK_DIRECTION_SHIFT 0x8
#define XS1_LINK_DIRECTION_SIZE 0x4
#define XS1_LINK_DIRECTION_MASK (((1 << XS1_LINK_DIRECTION_SIZE) - 1) << XS1_LINK_DIRECTION_SHIFT)
/**
 * Extract the LINK_DIRECTION bitfield from a packed word x and return it.
 */
#define XS1_LINK_DIRECTION(x) (((x) & XS1_LINK_DIRECTION_MASK) >> XS1_LINK_DIRECTION_SHIFT)
/**
 * Pack the value (v) of the LINK_DIRECTION bitfield into a packed word x and return the packed field.
 */
#define XS1_LINK_DIRECTION_SET(x, v) (((x) & ~XS1_LINK_DIRECTION_MASK) | (((v) << XS1_LINK_DIRECTION_SHIFT) & XS1_LINK_DIRECTION_MASK))
///@}
/**
 * \name SLINK_SRC_TARGET_ID
 * \anchor SLINK_SRC_TARGET_ID
 * When the link is in use, this is the destination link number to which all packets are sent.
 */
///@{
#define XS1_SLINK_SRC_TARGET_ID_SHIFT 0x10
#define XS1_SLINK_SRC_TARGET_ID_SIZE 0x8
#define XS1_SLINK_SRC_TARGET_ID_MASK (((1 << XS1_SLINK_SRC_TARGET_ID_SIZE) - 1) << XS1_SLINK_SRC_TARGET_ID_SHIFT)
/**
 * Extract the SLINK_SRC_TARGET_ID bitfield from a packed word x and return it.
 */
#define XS1_SLINK_SRC_TARGET_ID(x) (((x) & XS1_SLINK_SRC_TARGET_ID_MASK) >> XS1_SLINK_SRC_TARGET_ID_SHIFT)
/**
 * Pack the value (v) of the SLINK_SRC_TARGET_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_SLINK_SRC_TARGET_ID_SET(x, v) (((x) & ~XS1_SLINK_SRC_TARGET_ID_MASK) | (((v) << XS1_SLINK_SRC_TARGET_ID_SHIFT) & XS1_SLINK_SRC_TARGET_ID_MASK))
///@}
/**
 * \name SLINK_SRC_TARGET_TYPE
 * \anchor SLINK_SRC_TARGET_TYPE
 * Identify the SRC_TARGET type 0 - SLink, 1 - PLink, 2 - SSCTL, 3 - Undefine.
 */
///@{
#define XS1_SLINK_SRC_TARGET_TYPE_SHIFT 0x18
#define XS1_SLINK_SRC_TARGET_TYPE_SIZE 0x2
#define XS1_SLINK_SRC_TARGET_TYPE_MASK (((1 << XS1_SLINK_SRC_TARGET_TYPE_SIZE) - 1) << XS1_SLINK_SRC_TARGET_TYPE_SHIFT)
/**
 * Extract the SLINK_SRC_TARGET_TYPE bitfield from a packed word x and return it.
 */
#define XS1_SLINK_SRC_TARGET_TYPE(x) (((x) & XS1_SLINK_SRC_TARGET_TYPE_MASK) >> XS1_SLINK_SRC_TARGET_TYPE_SHIFT)
/**
 * Pack the value (v) of the SLINK_SRC_TARGET_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_SLINK_SRC_TARGET_TYPE_SET(x, v) (((x) & ~XS1_SLINK_SRC_TARGET_TYPE_MASK) | (((v) << XS1_SLINK_SRC_TARGET_TYPE_SHIFT) & XS1_SLINK_SRC_TARGET_TYPE_MASK))
///@}
/**
 * \name PLINK_SRC_TARGET_ID
 * \anchor PLINK_SRC_TARGET_ID
 * When the link is in use, this is the destination link number to which all packets are sent.
 */
///@{
#define XS1_PLINK_SRC_TARGET_ID_SHIFT 0x10
#define XS1_PLINK_SRC_TARGET_ID_SIZE 0x8
#define XS1_PLINK_SRC_TARGET_ID_MASK (((1 << XS1_PLINK_SRC_TARGET_ID_SIZE) - 1) << XS1_PLINK_SRC_TARGET_ID_SHIFT)
/**
 * Extract the PLINK_SRC_TARGET_ID bitfield from a packed word x and return it.
 */
#define XS1_PLINK_SRC_TARGET_ID(x) (((x) & XS1_PLINK_SRC_TARGET_ID_MASK) >> XS1_PLINK_SRC_TARGET_ID_SHIFT)
/**
 * Pack the value (v) of the PLINK_SRC_TARGET_ID bitfield into a packed word x and return the packed field.
 */
#define XS1_PLINK_SRC_TARGET_ID_SET(x, v) (((x) & ~XS1_PLINK_SRC_TARGET_ID_MASK) | (((v) << XS1_PLINK_SRC_TARGET_ID_SHIFT) & XS1_PLINK_SRC_TARGET_ID_MASK))
///@}
/**
 * \name PLINK_SRC_TARGET_TYPE
 * \anchor PLINK_SRC_TARGET_TYPE
 * Identify the SRC_TARGET type 0 - SLink, 1 - PLink, 2 - SSCTL, 3 - Undefine.
 */
///@{
#define XS1_PLINK_SRC_TARGET_TYPE_SHIFT 0x18
#define XS1_PLINK_SRC_TARGET_TYPE_SIZE 0x2
#define XS1_PLINK_SRC_TARGET_TYPE_MASK (((1 << XS1_PLINK_SRC_TARGET_TYPE_SIZE) - 1) << XS1_PLINK_SRC_TARGET_TYPE_SHIFT)
/**
 * Extract the PLINK_SRC_TARGET_TYPE bitfield from a packed word x and return it.
 */
#define XS1_PLINK_SRC_TARGET_TYPE(x) (((x) & XS1_PLINK_SRC_TARGET_TYPE_MASK) >> XS1_PLINK_SRC_TARGET_TYPE_SHIFT)
/**
 * Pack the value (v) of the PLINK_SRC_TARGET_TYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_PLINK_SRC_TARGET_TYPE_SET(x, v) (((x) & ~XS1_PLINK_SRC_TARGET_TYPE_MASK) | (((v) << XS1_PLINK_SRC_TARGET_TYPE_SHIFT) & XS1_PLINK_SRC_TARGET_TYPE_MASK))
///@}
/**
 * \name XLINK_INTER_TOKEN_DELAY
 * \anchor XLINK_INTER_TOKEN_DELAY
 * Specify min. number of idle system clocks between two continuous transmit tokens -1.
 */
///@{
#define XS1_XLINK_INTER_TOKEN_DELAY_SHIFT 0x0
#define XS1_XLINK_INTER_TOKEN_DELAY_SIZE 0xb
#define XS1_XLINK_INTER_TOKEN_DELAY_MASK (((1 << XS1_XLINK_INTER_TOKEN_DELAY_SIZE) - 1) << XS1_XLINK_INTER_TOKEN_DELAY_SHIFT)
/**
 * Extract the XLINK_INTER_TOKEN_DELAY bitfield from a packed word x and return it.
 */
#define XS1_XLINK_INTER_TOKEN_DELAY(x) (((x) & XS1_XLINK_INTER_TOKEN_DELAY_MASK) >> XS1_XLINK_INTER_TOKEN_DELAY_SHIFT)
/**
 * Pack the value (v) of the XLINK_INTER_TOKEN_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_INTER_TOKEN_DELAY_SET(x, v) (((x) & ~XS1_XLINK_INTER_TOKEN_DELAY_MASK) | (((v) << XS1_XLINK_INTER_TOKEN_DELAY_SHIFT) & XS1_XLINK_INTER_TOKEN_DELAY_MASK))
///@}
/**
 * \name XLINK_INTRA_TOKEN_DELAY
 * \anchor XLINK_INTRA_TOKEN_DELAY
 * Specify min. number of idle system clocks between two continuous symbols witin a transmit token -1.
 */
///@{
#define XS1_XLINK_INTRA_TOKEN_DELAY_SHIFT 0xb
#define XS1_XLINK_INTRA_TOKEN_DELAY_SIZE 0xb
#define XS1_XLINK_INTRA_TOKEN_DELAY_MASK (((1 << XS1_XLINK_INTRA_TOKEN_DELAY_SIZE) - 1) << XS1_XLINK_INTRA_TOKEN_DELAY_SHIFT)
/**
 * Extract the XLINK_INTRA_TOKEN_DELAY bitfield from a packed word x and return it.
 */
#define XS1_XLINK_INTRA_TOKEN_DELAY(x) (((x) & XS1_XLINK_INTRA_TOKEN_DELAY_MASK) >> XS1_XLINK_INTRA_TOKEN_DELAY_SHIFT)
/**
 * Pack the value (v) of the XLINK_INTRA_TOKEN_DELAY bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_INTRA_TOKEN_DELAY_SET(x, v) (((x) & ~XS1_XLINK_INTRA_TOKEN_DELAY_MASK) | (((v) << XS1_XLINK_INTRA_TOKEN_DELAY_SHIFT) & XS1_XLINK_INTRA_TOKEN_DELAY_MASK))
///@}
/**
 * \name XLINK_RX_RESET
 * \anchor XLINK_RX_RESET
 * Reset the receiver.  The next symbol that is detected will be the first symbol in a token.
 */
///@{
#define XS1_XLINK_RX_RESET_SHIFT 0x17
#define XS1_XLINK_RX_RESET_SIZE 0x1
#define XS1_XLINK_RX_RESET_MASK (((1 << XS1_XLINK_RX_RESET_SIZE) - 1) << XS1_XLINK_RX_RESET_SHIFT)
/**
 * Extract the XLINK_RX_RESET bitfield from a packed word x and return it.
 */
#define XS1_XLINK_RX_RESET(x) (((x) & XS1_XLINK_RX_RESET_MASK) >> XS1_XLINK_RX_RESET_SHIFT)
/**
 * Pack the value (v) of the XLINK_RX_RESET bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_RX_RESET_SET(x, v) (((x) & ~XS1_XLINK_RX_RESET_MASK) | (((v) << XS1_XLINK_RX_RESET_SHIFT) & XS1_XLINK_RX_RESET_MASK))
///@}
/**
 * \name XLINK_HELLO
 * \anchor XLINK_HELLO
 * Clear this end of the xlink's credit and issue a HELLO token.
 */
///@{
#define XS1_XLINK_HELLO_SHIFT 0x18
#define XS1_XLINK_HELLO_SIZE 0x1
#define XS1_XLINK_HELLO_MASK (((1 << XS1_XLINK_HELLO_SIZE) - 1) << XS1_XLINK_HELLO_SHIFT)
/**
 * Extract the XLINK_HELLO bitfield from a packed word x and return it.
 */
#define XS1_XLINK_HELLO(x) (((x) & XS1_XLINK_HELLO_MASK) >> XS1_XLINK_HELLO_SHIFT)
/**
 * Pack the value (v) of the XLINK_HELLO bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_HELLO_SET(x, v) (((x) & ~XS1_XLINK_HELLO_MASK) | (((v) << XS1_XLINK_HELLO_SHIFT) & XS1_XLINK_HELLO_MASK))
///@}
/**
 * \name TX_CREDIT
 * \anchor TX_CREDIT
 * This end of the xlink has credit to allow it to transmit.
 */
///@{
#define XS1_TX_CREDIT_SHIFT 0x19
#define XS1_TX_CREDIT_SIZE 0x1
#define XS1_TX_CREDIT_MASK (((1 << XS1_TX_CREDIT_SIZE) - 1) << XS1_TX_CREDIT_SHIFT)
/**
 * Extract the TX_CREDIT bitfield from a packed word x and return it.
 */
#define XS1_TX_CREDIT(x) (((x) & XS1_TX_CREDIT_MASK) >> XS1_TX_CREDIT_SHIFT)
/**
 * Pack the value (v) of the TX_CREDIT bitfield into a packed word x and return the packed field.
 */
#define XS1_TX_CREDIT_SET(x, v) (((x) & ~XS1_TX_CREDIT_MASK) | (((v) << XS1_TX_CREDIT_SHIFT) & XS1_TX_CREDIT_MASK))
///@}
/**
 * \name RX_CREDIT
 * \anchor RX_CREDIT
 * This end of the xlink has issued credit to allow the remote end to transmit
 */
///@{
#define XS1_RX_CREDIT_SHIFT 0x1a
#define XS1_RX_CREDIT_SIZE 0x1
#define XS1_RX_CREDIT_MASK (((1 << XS1_RX_CREDIT_SIZE) - 1) << XS1_RX_CREDIT_SHIFT)
/**
 * Extract the RX_CREDIT bitfield from a packed word x and return it.
 */
#define XS1_RX_CREDIT(x) (((x) & XS1_RX_CREDIT_MASK) >> XS1_RX_CREDIT_SHIFT)
/**
 * Pack the value (v) of the RX_CREDIT bitfield into a packed word x and return the packed field.
 */
#define XS1_RX_CREDIT_SET(x, v) (((x) & ~XS1_RX_CREDIT_MASK) | (((v) << XS1_RX_CREDIT_SHIFT) & XS1_RX_CREDIT_MASK))
///@}
/**
 * \name XLINK_RX_ERROR
 * \anchor XLINK_RX_ERROR
 * Rx buffer overflow or illegal token encoding received.
 */
///@{
#define XS1_XLINK_RX_ERROR_SHIFT 0x1b
#define XS1_XLINK_RX_ERROR_SIZE 0x1
#define XS1_XLINK_RX_ERROR_MASK (((1 << XS1_XLINK_RX_ERROR_SIZE) - 1) << XS1_XLINK_RX_ERROR_SHIFT)
/**
 * Extract the XLINK_RX_ERROR bitfield from a packed word x and return it.
 */
#define XS1_XLINK_RX_ERROR(x) (((x) & XS1_XLINK_RX_ERROR_MASK) >> XS1_XLINK_RX_ERROR_SHIFT)
/**
 * Pack the value (v) of the XLINK_RX_ERROR bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_RX_ERROR_SET(x, v) (((x) & ~XS1_XLINK_RX_ERROR_MASK) | (((v) << XS1_XLINK_RX_ERROR_SHIFT) & XS1_XLINK_RX_ERROR_MASK))
///@}
/**
 * \name XLINK_WIDE
 * \anchor XLINK_WIDE
 * 0: operate in 2 wire mode; 1: operate in 5 wire mode
 */
///@{
#define XS1_XLINK_WIDE_SHIFT 0x1e
#define XS1_XLINK_WIDE_SIZE 0x1
#define XS1_XLINK_WIDE_MASK (((1 << XS1_XLINK_WIDE_SIZE) - 1) << XS1_XLINK_WIDE_SHIFT)
/**
 * Extract the XLINK_WIDE bitfield from a packed word x and return it.
 */
#define XS1_XLINK_WIDE(x) (((x) & XS1_XLINK_WIDE_MASK) >> XS1_XLINK_WIDE_SHIFT)
/**
 * Pack the value (v) of the XLINK_WIDE bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_WIDE_SET(x, v) (((x) & ~XS1_XLINK_WIDE_MASK) | (((v) << XS1_XLINK_WIDE_SHIFT) & XS1_XLINK_WIDE_MASK))
///@}
/**
 * \name XLINK_ENABLE
 * \anchor XLINK_ENABLE
 * Write to this bit with '1' will enable the XLink, writing '0' will disable it. This bit controls the muxing of ports with overlapping xlinks.
 */
///@{
#define XS1_XLINK_ENABLE_SHIFT 0x1f
#define XS1_XLINK_ENABLE_SIZE 0x1
#define XS1_XLINK_ENABLE_MASK (((1 << XS1_XLINK_ENABLE_SIZE) - 1) << XS1_XLINK_ENABLE_SHIFT)
/**
 * Extract the XLINK_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XLINK_ENABLE(x) (((x) & XS1_XLINK_ENABLE_MASK) >> XS1_XLINK_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XLINK_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XLINK_ENABLE_SET(x, v) (((x) & ~XS1_XLINK_ENABLE_MASK) | (((v) << XS1_XLINK_ENABLE_SHIFT) & XS1_XLINK_ENABLE_MASK))
///@}
/**
 * \name XSTATIC_DEST_CHAN_END
 * \anchor XSTATIC_DEST_CHAN_END
 * The destination channel end on this node that packets received in static mode are forwarded to.
 */
///@{
#define XS1_XSTATIC_DEST_CHAN_END_SHIFT 0x0
#define XS1_XSTATIC_DEST_CHAN_END_SIZE 0x5
#define XS1_XSTATIC_DEST_CHAN_END_MASK (((1 << XS1_XSTATIC_DEST_CHAN_END_SIZE) - 1) << XS1_XSTATIC_DEST_CHAN_END_SHIFT)
/**
 * Extract the XSTATIC_DEST_CHAN_END bitfield from a packed word x and return it.
 */
#define XS1_XSTATIC_DEST_CHAN_END(x) (((x) & XS1_XSTATIC_DEST_CHAN_END_MASK) >> XS1_XSTATIC_DEST_CHAN_END_SHIFT)
/**
 * Pack the value (v) of the XSTATIC_DEST_CHAN_END bitfield into a packed word x and return the packed field.
 */
#define XS1_XSTATIC_DEST_CHAN_END_SET(x, v) (((x) & ~XS1_XSTATIC_DEST_CHAN_END_MASK) | (((v) << XS1_XSTATIC_DEST_CHAN_END_SHIFT) & XS1_XSTATIC_DEST_CHAN_END_MASK))
///@}
/**
 * \name XSTATIC_DEST_PROC
 * \anchor XSTATIC_DEST_PROC
 * The destination processor on this node that packets received in static mode are forwarded to.
 */
///@{
#define XS1_XSTATIC_DEST_PROC_SHIFT 0x8
#define XS1_XSTATIC_DEST_PROC_SIZE 0x1
#define XS1_XSTATIC_DEST_PROC_MASK (((1 << XS1_XSTATIC_DEST_PROC_SIZE) - 1) << XS1_XSTATIC_DEST_PROC_SHIFT)
/**
 * Extract the XSTATIC_DEST_PROC bitfield from a packed word x and return it.
 */
#define XS1_XSTATIC_DEST_PROC(x) (((x) & XS1_XSTATIC_DEST_PROC_MASK) >> XS1_XSTATIC_DEST_PROC_SHIFT)
/**
 * Pack the value (v) of the XSTATIC_DEST_PROC bitfield into a packed word x and return the packed field.
 */
#define XS1_XSTATIC_DEST_PROC_SET(x, v) (((x) & ~XS1_XSTATIC_DEST_PROC_MASK) | (((v) << XS1_XSTATIC_DEST_PROC_SHIFT) & XS1_XSTATIC_DEST_PROC_MASK))
///@}
/**
 * \name XSTATIC_ENABLE
 * \anchor XSTATIC_ENABLE
 * Enable static forwarding.
 */
///@{
#define XS1_XSTATIC_ENABLE_SHIFT 0x1f
#define XS1_XSTATIC_ENABLE_SIZE 0x1
#define XS1_XSTATIC_ENABLE_MASK (((1 << XS1_XSTATIC_ENABLE_SIZE) - 1) << XS1_XSTATIC_ENABLE_SHIFT)
/**
 * Extract the XSTATIC_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_XSTATIC_ENABLE(x) (((x) & XS1_XSTATIC_ENABLE_MASK) >> XS1_XSTATIC_ENABLE_SHIFT)
/**
 * Pack the value (v) of the XSTATIC_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_XSTATIC_ENABLE_SET(x, v) (((x) & ~XS1_XSTATIC_ENABLE_MASK) | (((v) << XS1_XSTATIC_ENABLE_SHIFT) & XS1_XSTATIC_ENABLE_MASK))
///@}
/**
 * \name SSCTRL_PSCTRL_CORE_NUM
 * \anchor SSCTRL_PSCTRL_CORE_NUM
 * Core Number for the PSCTRL register address through the SSwitch
 */
///@{
#define XS1_SSCTRL_PSCTRL_CORE_NUM_SHIFT 0x8
#define XS1_SSCTRL_PSCTRL_CORE_NUM_SIZE 0x8
#define XS1_SSCTRL_PSCTRL_CORE_NUM_MASK (((1 << XS1_SSCTRL_PSCTRL_CORE_NUM_SIZE) - 1) << XS1_SSCTRL_PSCTRL_CORE_NUM_SHIFT)
/**
 * Extract the SSCTRL_PSCTRL_CORE_NUM bitfield from a packed word x and return it.
 */
#define XS1_SSCTRL_PSCTRL_CORE_NUM(x) (((x) & XS1_SSCTRL_PSCTRL_CORE_NUM_MASK) >> XS1_SSCTRL_PSCTRL_CORE_NUM_SHIFT)
/**
 * Pack the value (v) of the SSCTRL_PSCTRL_CORE_NUM bitfield into a packed word x and return the packed field.
 */
#define XS1_SSCTRL_PSCTRL_CORE_NUM_SET(x, v) (((x) & ~XS1_SSCTRL_PSCTRL_CORE_NUM_MASK) | (((v) << XS1_SSCTRL_PSCTRL_CORE_NUM_SHIFT) & XS1_SSCTRL_PSCTRL_CORE_NUM_MASK))
///@}
/**
 * \name USB_PHY_CFG0_UTMI_XCVRSELECT
 * \anchor USB_PHY_CFG0_UTMI_XCVRSELECT
 * Value of the UTMI XCVRSelect signals to the USB Phy
 */
///@{
#define XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_SHIFT 0x0
#define XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_SIZE 0x2
#define XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_MASK (((1 << XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_SIZE) - 1) << XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_SHIFT)
/**
 * Extract the USB_PHY_CFG0_UTMI_XCVRSELECT bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_UTMI_XCVRSELECT(x) (((x) & XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_MASK) >> XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_UTMI_XCVRSELECT bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_MASK) | (((v) << XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_SHIFT) & XS1_USB_PHY_CFG0_UTMI_XCVRSELECT_MASK))
///@}
/**
 * \name USB_PHY_CFG0_UTMI_TERMSELECT
 * \anchor USB_PHY_CFG0_UTMI_TERMSELECT
 * Value of the UTMI Terminal Select signal to the USB Phy
 */
///@{
#define XS1_USB_PHY_CFG0_UTMI_TERMSELECT_SHIFT 0x2
#define XS1_USB_PHY_CFG0_UTMI_TERMSELECT_SIZE 0x1
#define XS1_USB_PHY_CFG0_UTMI_TERMSELECT_MASK (((1 << XS1_USB_PHY_CFG0_UTMI_TERMSELECT_SIZE) - 1) << XS1_USB_PHY_CFG0_UTMI_TERMSELECT_SHIFT)
/**
 * Extract the USB_PHY_CFG0_UTMI_TERMSELECT bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_UTMI_TERMSELECT(x) (((x) & XS1_USB_PHY_CFG0_UTMI_TERMSELECT_MASK) >> XS1_USB_PHY_CFG0_UTMI_TERMSELECT_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_UTMI_TERMSELECT bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_UTMI_TERMSELECT_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_UTMI_TERMSELECT_MASK) | (((v) << XS1_USB_PHY_CFG0_UTMI_TERMSELECT_SHIFT) & XS1_USB_PHY_CFG0_UTMI_TERMSELECT_MASK))
///@}
/**
 * \name USB_PHY_CFG0_UTMI_OPMODE
 * \anchor USB_PHY_CFG0_UTMI_OPMODE
 * Value of the UTMI OpMode signals to the USB Phy
 */
///@{
#define XS1_USB_PHY_CFG0_UTMI_OPMODE_SHIFT 0x3
#define XS1_USB_PHY_CFG0_UTMI_OPMODE_SIZE 0x2
#define XS1_USB_PHY_CFG0_UTMI_OPMODE_MASK (((1 << XS1_USB_PHY_CFG0_UTMI_OPMODE_SIZE) - 1) << XS1_USB_PHY_CFG0_UTMI_OPMODE_SHIFT)
/**
 * Extract the USB_PHY_CFG0_UTMI_OPMODE bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_UTMI_OPMODE(x) (((x) & XS1_USB_PHY_CFG0_UTMI_OPMODE_MASK) >> XS1_USB_PHY_CFG0_UTMI_OPMODE_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_UTMI_OPMODE bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_UTMI_OPMODE_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_UTMI_OPMODE_MASK) | (((v) << XS1_USB_PHY_CFG0_UTMI_OPMODE_SHIFT) & XS1_USB_PHY_CFG0_UTMI_OPMODE_MASK))
///@}
/**
 * \name USB_PHY_CFG0_UTMI_SUSPENDM
 * \anchor USB_PHY_CFG0_UTMI_SUSPENDM
 * Value of the UTMI SuspendM signal to the USB Phy
 */
///@{
#define XS1_USB_PHY_CFG0_UTMI_SUSPENDM_SHIFT 0x5
#define XS1_USB_PHY_CFG0_UTMI_SUSPENDM_SIZE 0x1
#define XS1_USB_PHY_CFG0_UTMI_SUSPENDM_MASK (((1 << XS1_USB_PHY_CFG0_UTMI_SUSPENDM_SIZE) - 1) << XS1_USB_PHY_CFG0_UTMI_SUSPENDM_SHIFT)
/**
 * Extract the USB_PHY_CFG0_UTMI_SUSPENDM bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_UTMI_SUSPENDM(x) (((x) & XS1_USB_PHY_CFG0_UTMI_SUSPENDM_MASK) >> XS1_USB_PHY_CFG0_UTMI_SUSPENDM_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_UTMI_SUSPENDM bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_UTMI_SUSPENDM_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_UTMI_SUSPENDM_MASK) | (((v) << XS1_USB_PHY_CFG0_UTMI_SUSPENDM_SHIFT) & XS1_USB_PHY_CFG0_UTMI_SUSPENDM_MASK))
///@}
/**
 * \name USB_PHY_CFG0_DPPULLDOWN
 * \anchor USB_PHY_CFG0_DPPULLDOWN
 * Set to 1 to enable the DP Pulldown
 */
///@{
#define XS1_USB_PHY_CFG0_DPPULLDOWN_SHIFT 0x6
#define XS1_USB_PHY_CFG0_DPPULLDOWN_SIZE 0x1
#define XS1_USB_PHY_CFG0_DPPULLDOWN_MASK (((1 << XS1_USB_PHY_CFG0_DPPULLDOWN_SIZE) - 1) << XS1_USB_PHY_CFG0_DPPULLDOWN_SHIFT)
/**
 * Extract the USB_PHY_CFG0_DPPULLDOWN bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_DPPULLDOWN(x) (((x) & XS1_USB_PHY_CFG0_DPPULLDOWN_MASK) >> XS1_USB_PHY_CFG0_DPPULLDOWN_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_DPPULLDOWN bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_DPPULLDOWN_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_DPPULLDOWN_MASK) | (((v) << XS1_USB_PHY_CFG0_DPPULLDOWN_SHIFT) & XS1_USB_PHY_CFG0_DPPULLDOWN_MASK))
///@}
/**
 * \name USB_PHY_CFG0_DMPULLDOWN
 * \anchor USB_PHY_CFG0_DMPULLDOWN
 * Set to 1 to enable the DM Pulldown
 */
///@{
#define XS1_USB_PHY_CFG0_DMPULLDOWN_SHIFT 0x7
#define XS1_USB_PHY_CFG0_DMPULLDOWN_SIZE 0x1
#define XS1_USB_PHY_CFG0_DMPULLDOWN_MASK (((1 << XS1_USB_PHY_CFG0_DMPULLDOWN_SIZE) - 1) << XS1_USB_PHY_CFG0_DMPULLDOWN_SHIFT)
/**
 * Extract the USB_PHY_CFG0_DMPULLDOWN bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_DMPULLDOWN(x) (((x) & XS1_USB_PHY_CFG0_DMPULLDOWN_MASK) >> XS1_USB_PHY_CFG0_DMPULLDOWN_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_DMPULLDOWN bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_DMPULLDOWN_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_DMPULLDOWN_MASK) | (((v) << XS1_USB_PHY_CFG0_DMPULLDOWN_SHIFT) & XS1_USB_PHY_CFG0_DMPULLDOWN_MASK))
///@}
/**
 * \name USB_PHY_CFG0_TXBITSTUFF_EN
 * \anchor USB_PHY_CFG0_TXBITSTUFF_EN
 * Set to 1 to enable USB Tx BitStuffing
 */
///@{
#define XS1_USB_PHY_CFG0_TXBITSTUFF_EN_SHIFT 0x8
#define XS1_USB_PHY_CFG0_TXBITSTUFF_EN_SIZE 0x1
#define XS1_USB_PHY_CFG0_TXBITSTUFF_EN_MASK (((1 << XS1_USB_PHY_CFG0_TXBITSTUFF_EN_SIZE) - 1) << XS1_USB_PHY_CFG0_TXBITSTUFF_EN_SHIFT)
/**
 * Extract the USB_PHY_CFG0_TXBITSTUFF_EN bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_TXBITSTUFF_EN(x) (((x) & XS1_USB_PHY_CFG0_TXBITSTUFF_EN_MASK) >> XS1_USB_PHY_CFG0_TXBITSTUFF_EN_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_TXBITSTUFF_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_TXBITSTUFF_EN_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_TXBITSTUFF_EN_MASK) | (((v) << XS1_USB_PHY_CFG0_TXBITSTUFF_EN_SHIFT) & XS1_USB_PHY_CFG0_TXBITSTUFF_EN_MASK))
///@}
/**
 * \name USB_PHY_CFG0_PLL_EN
 * \anchor USB_PHY_CFG0_PLL_EN
 * Set to 1 to enable the USB PLL
 */
///@{
#define XS1_USB_PHY_CFG0_PLL_EN_SHIFT 0x9
#define XS1_USB_PHY_CFG0_PLL_EN_SIZE 0x1
#define XS1_USB_PHY_CFG0_PLL_EN_MASK (((1 << XS1_USB_PHY_CFG0_PLL_EN_SIZE) - 1) << XS1_USB_PHY_CFG0_PLL_EN_SHIFT)
/**
 * Extract the USB_PHY_CFG0_PLL_EN bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_PLL_EN(x) (((x) & XS1_USB_PHY_CFG0_PLL_EN_MASK) >> XS1_USB_PHY_CFG0_PLL_EN_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_PLL_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_PLL_EN_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_PLL_EN_MASK) | (((v) << XS1_USB_PHY_CFG0_PLL_EN_SHIFT) & XS1_USB_PHY_CFG0_PLL_EN_MASK))
///@}
/**
 * \name USB_PHY_CFG0_LPM_ALIVE
 * \anchor USB_PHY_CFG0_LPM_ALIVE
 * Set to 1 to enable USB LPM
 */
///@{
#define XS1_USB_PHY_CFG0_LPM_ALIVE_SHIFT 0xa
#define XS1_USB_PHY_CFG0_LPM_ALIVE_SIZE 0x1
#define XS1_USB_PHY_CFG0_LPM_ALIVE_MASK (((1 << XS1_USB_PHY_CFG0_LPM_ALIVE_SIZE) - 1) << XS1_USB_PHY_CFG0_LPM_ALIVE_SHIFT)
/**
 * Extract the USB_PHY_CFG0_LPM_ALIVE bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_LPM_ALIVE(x) (((x) & XS1_USB_PHY_CFG0_LPM_ALIVE_MASK) >> XS1_USB_PHY_CFG0_LPM_ALIVE_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_LPM_ALIVE bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_LPM_ALIVE_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_LPM_ALIVE_MASK) | (((v) << XS1_USB_PHY_CFG0_LPM_ALIVE_SHIFT) & XS1_USB_PHY_CFG0_LPM_ALIVE_MASK))
///@}
/**
 * \name USB_PHY_CFG0_IDPAD_EN
 * \anchor USB_PHY_CFG0_IDPAD_EN
 * Set to 1 to enable the ID PAD
 */
///@{
#define XS1_USB_PHY_CFG0_IDPAD_EN_SHIFT 0xb
#define XS1_USB_PHY_CFG0_IDPAD_EN_SIZE 0x1
#define XS1_USB_PHY_CFG0_IDPAD_EN_MASK (((1 << XS1_USB_PHY_CFG0_IDPAD_EN_SIZE) - 1) << XS1_USB_PHY_CFG0_IDPAD_EN_SHIFT)
/**
 * Extract the USB_PHY_CFG0_IDPAD_EN bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_IDPAD_EN(x) (((x) & XS1_USB_PHY_CFG0_IDPAD_EN_MASK) >> XS1_USB_PHY_CFG0_IDPAD_EN_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_IDPAD_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_IDPAD_EN_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_IDPAD_EN_MASK) | (((v) << XS1_USB_PHY_CFG0_IDPAD_EN_SHIFT) & XS1_USB_PHY_CFG0_IDPAD_EN_MASK))
///@}
/**
 * \name USB_PHY_CFG0_XTLSEL
 * \anchor USB_PHY_CFG0_XTLSEL
 * Oscillator freqeuncy. Set to: 0 (10MHz), 1 (12MHz), 2
 *       (25MHz), 3~(30MHz),
 *       4 (19.2MHz), 5 (24MHz), 6 (27MHz), or 7 (40MHz).
 */
///@{
#define XS1_USB_PHY_CFG0_XTLSEL_SHIFT 0xc
#define XS1_USB_PHY_CFG0_XTLSEL_SIZE 0x3
#define XS1_USB_PHY_CFG0_XTLSEL_MASK (((1 << XS1_USB_PHY_CFG0_XTLSEL_SIZE) - 1) << XS1_USB_PHY_CFG0_XTLSEL_SHIFT)
/**
 * Extract the USB_PHY_CFG0_XTLSEL bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG0_XTLSEL(x) (((x) & XS1_USB_PHY_CFG0_XTLSEL_MASK) >> XS1_USB_PHY_CFG0_XTLSEL_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG0_XTLSEL bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG0_XTLSEL_SET(x, v) (((x) & ~XS1_USB_PHY_CFG0_XTLSEL_MASK) | (((v) << XS1_USB_PHY_CFG0_XTLSEL_SHIFT) & XS1_USB_PHY_CFG0_XTLSEL_MASK))
///@}
/**
 * \name USB_PHY_CFG2_PONRST
 * \anchor USB_PHY_CFG2_PONRST
 * USB PHY reset, set to 1 to take the PHY out of reset
 */
///@{
#define XS1_USB_PHY_CFG2_PONRST_SHIFT 0x0
#define XS1_USB_PHY_CFG2_PONRST_SIZE 0x1
#define XS1_USB_PHY_CFG2_PONRST_MASK (((1 << XS1_USB_PHY_CFG2_PONRST_SIZE) - 1) << XS1_USB_PHY_CFG2_PONRST_SHIFT)
/**
 * Extract the USB_PHY_CFG2_PONRST bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG2_PONRST(x) (((x) & XS1_USB_PHY_CFG2_PONRST_MASK) >> XS1_USB_PHY_CFG2_PONRST_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG2_PONRST bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG2_PONRST_SET(x, v) (((x) & ~XS1_USB_PHY_CFG2_PONRST_MASK) | (((v) << XS1_USB_PHY_CFG2_PONRST_SHIFT) & XS1_USB_PHY_CFG2_PONRST_MASK))
///@}
/**
 * \name USB_PHY_CFG2_UTMI_RESET
 * \anchor USB_PHY_CFG2_UTMI_RESET
 * UTMI reset, set to 0 to take UTMI out of reset
 */
///@{
#define XS1_USB_PHY_CFG2_UTMI_RESET_SHIFT 0x1
#define XS1_USB_PHY_CFG2_UTMI_RESET_SIZE 0x1
#define XS1_USB_PHY_CFG2_UTMI_RESET_MASK (((1 << XS1_USB_PHY_CFG2_UTMI_RESET_SIZE) - 1) << XS1_USB_PHY_CFG2_UTMI_RESET_SHIFT)
/**
 * Extract the USB_PHY_CFG2_UTMI_RESET bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG2_UTMI_RESET(x) (((x) & XS1_USB_PHY_CFG2_UTMI_RESET_MASK) >> XS1_USB_PHY_CFG2_UTMI_RESET_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG2_UTMI_RESET bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG2_UTMI_RESET_SET(x, v) (((x) & ~XS1_USB_PHY_CFG2_UTMI_RESET_MASK) | (((v) << XS1_USB_PHY_CFG2_UTMI_RESET_SHIFT) & XS1_USB_PHY_CFG2_UTMI_RESET_MASK))
///@}
/**
 * \name USB_PHY_CFG3_VCONTROL
 * \anchor USB_PHY_CFG3_VCONTROL
 * USB VCONTROL
 */
///@{
#define XS1_USB_PHY_CFG3_VCONTROL_SHIFT 0x0
#define XS1_USB_PHY_CFG3_VCONTROL_SIZE 0x4
#define XS1_USB_PHY_CFG3_VCONTROL_MASK (((1 << XS1_USB_PHY_CFG3_VCONTROL_SIZE) - 1) << XS1_USB_PHY_CFG3_VCONTROL_SHIFT)
/**
 * Extract the USB_PHY_CFG3_VCONTROL bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG3_VCONTROL(x) (((x) & XS1_USB_PHY_CFG3_VCONTROL_MASK) >> XS1_USB_PHY_CFG3_VCONTROL_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG3_VCONTROL bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG3_VCONTROL_SET(x, v) (((x) & ~XS1_USB_PHY_CFG3_VCONTROL_MASK) | (((v) << XS1_USB_PHY_CFG3_VCONTROL_SHIFT) & XS1_USB_PHY_CFG3_VCONTROL_MASK))
///@}
/**
 * \name USB_PHY_CFG3_EXTERNAL_TEST_MODE
 * \anchor USB_PHY_CFG3_EXTERNAL_TEST_MODE
 * USB EXTERNAL TEST MODE
 */
///@{
#define XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_SHIFT 0x4
#define XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_SIZE 0x1
#define XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_MASK (((1 << XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_SIZE) - 1) << XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_SHIFT)
/**
 * Extract the USB_PHY_CFG3_EXTERNAL_TEST_MODE bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE(x) (((x) & XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_MASK) >> XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG3_EXTERNAL_TEST_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_SET(x, v) (((x) & ~XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_MASK) | (((v) << XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_SHIFT) & XS1_USB_PHY_CFG3_EXTERNAL_TEST_MODE_MASK))
///@}
/**
 * \name USB_PHY_CFG3_LS_EN
 * \anchor USB_PHY_CFG3_LS_EN
 * USB LS Enable
 */
///@{
#define XS1_USB_PHY_CFG3_LS_EN_SHIFT 0x5
#define XS1_USB_PHY_CFG3_LS_EN_SIZE 0x1
#define XS1_USB_PHY_CFG3_LS_EN_MASK (((1 << XS1_USB_PHY_CFG3_LS_EN_SIZE) - 1) << XS1_USB_PHY_CFG3_LS_EN_SHIFT)
/**
 * Extract the USB_PHY_CFG3_LS_EN bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG3_LS_EN(x) (((x) & XS1_USB_PHY_CFG3_LS_EN_MASK) >> XS1_USB_PHY_CFG3_LS_EN_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG3_LS_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG3_LS_EN_SET(x, v) (((x) & ~XS1_USB_PHY_CFG3_LS_EN_MASK) | (((v) << XS1_USB_PHY_CFG3_LS_EN_SHIFT) & XS1_USB_PHY_CFG3_LS_EN_MASK))
///@}
/**
 * \name USB_PHY_CFG3_UTMI_VCONTROLLOADM
 * \anchor USB_PHY_CFG3_UTMI_VCONTROLLOADM
 * USB UTMI VCONTROLLOADM
 */
///@{
#define XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_SHIFT 0x6
#define XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_SIZE 0x1
#define XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_MASK (((1 << XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_SIZE) - 1) << XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_SHIFT)
/**
 * Extract the USB_PHY_CFG3_UTMI_VCONTROLLOADM bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM(x) (((x) & XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_MASK) >> XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG3_UTMI_VCONTROLLOADM bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_SET(x, v) (((x) & ~XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_MASK) | (((v) << XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_SHIFT) & XS1_USB_PHY_CFG3_UTMI_VCONTROLLOADM_MASK))
///@}
/**
 * \name USB_PHY_CFG3_HS_BIST_MODE
 * \anchor USB_PHY_CFG3_HS_BIST_MODE
 * USB HS BIST Mode
 */
///@{
#define XS1_USB_PHY_CFG3_HS_BIST_MODE_SHIFT 0x7
#define XS1_USB_PHY_CFG3_HS_BIST_MODE_SIZE 0x1
#define XS1_USB_PHY_CFG3_HS_BIST_MODE_MASK (((1 << XS1_USB_PHY_CFG3_HS_BIST_MODE_SIZE) - 1) << XS1_USB_PHY_CFG3_HS_BIST_MODE_SHIFT)
/**
 * Extract the USB_PHY_CFG3_HS_BIST_MODE bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_CFG3_HS_BIST_MODE(x) (((x) & XS1_USB_PHY_CFG3_HS_BIST_MODE_MASK) >> XS1_USB_PHY_CFG3_HS_BIST_MODE_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_CFG3_HS_BIST_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_CFG3_HS_BIST_MODE_SET(x, v) (((x) & ~XS1_USB_PHY_CFG3_HS_BIST_MODE_MASK) | (((v) << XS1_USB_PHY_CFG3_HS_BIST_MODE_SHIFT) & XS1_USB_PHY_CFG3_HS_BIST_MODE_MASK))
///@}
/**
 * \name USB_SHIM_CFG_AND_RXV_RXA
 * \anchor USB_SHIM_CFG_AND_RXV_RXA
 * When enabled RxValid output to xCore is AND'd with RxActive
 */
///@{
#define XS1_USB_SHIM_CFG_AND_RXV_RXA_SHIFT 0x0
#define XS1_USB_SHIM_CFG_AND_RXV_RXA_SIZE 0x1
#define XS1_USB_SHIM_CFG_AND_RXV_RXA_MASK (((1 << XS1_USB_SHIM_CFG_AND_RXV_RXA_SIZE) - 1) << XS1_USB_SHIM_CFG_AND_RXV_RXA_SHIFT)
/**
 * Extract the USB_SHIM_CFG_AND_RXV_RXA bitfield from a packed word x and return it.
 */
#define XS1_USB_SHIM_CFG_AND_RXV_RXA(x) (((x) & XS1_USB_SHIM_CFG_AND_RXV_RXA_MASK) >> XS1_USB_SHIM_CFG_AND_RXV_RXA_SHIFT)
/**
 * Pack the value (v) of the USB_SHIM_CFG_AND_RXV_RXA bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_SHIM_CFG_AND_RXV_RXA_SET(x, v) (((x) & ~XS1_USB_SHIM_CFG_AND_RXV_RXA_MASK) | (((v) << XS1_USB_SHIM_CFG_AND_RXV_RXA_SHIFT) & XS1_USB_SHIM_CFG_AND_RXV_RXA_MASK))
///@}
/**
 * \name USB_SHIM_CFG_FLAG_MODE
 * \anchor USB_SHIM_CFG_FLAG_MODE
 * USB flag mode selection: 1 selects linestate; 0 selects RxActive and RxValid
 */
///@{
#define XS1_USB_SHIM_CFG_FLAG_MODE_SHIFT 0x1
#define XS1_USB_SHIM_CFG_FLAG_MODE_SIZE 0x1
#define XS1_USB_SHIM_CFG_FLAG_MODE_MASK (((1 << XS1_USB_SHIM_CFG_FLAG_MODE_SIZE) - 1) << XS1_USB_SHIM_CFG_FLAG_MODE_SHIFT)
/**
 * Extract the USB_SHIM_CFG_FLAG_MODE bitfield from a packed word x and return it.
 */
#define XS1_USB_SHIM_CFG_FLAG_MODE(x) (((x) & XS1_USB_SHIM_CFG_FLAG_MODE_MASK) >> XS1_USB_SHIM_CFG_FLAG_MODE_SHIFT)
/**
 * Pack the value (v) of the USB_SHIM_CFG_FLAG_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_SHIM_CFG_FLAG_MODE_SET(x, v) (((x) & ~XS1_USB_SHIM_CFG_FLAG_MODE_MASK) | (((v) << XS1_USB_SHIM_CFG_FLAG_MODE_SHIFT) & XS1_USB_SHIM_CFG_FLAG_MODE_MASK))
///@}
/**
 * \name USB_PHY_STATUS_UTMI_LINESTATE
 * \anchor USB_PHY_STATUS_UTMI_LINESTATE
 * The UTMI line state; 0: SE0, 1: J, 2: K, 3: SE1
 */
///@{
#define XS1_USB_PHY_STATUS_UTMI_LINESTATE_SHIFT 0x0
#define XS1_USB_PHY_STATUS_UTMI_LINESTATE_SIZE 0x2
#define XS1_USB_PHY_STATUS_UTMI_LINESTATE_MASK (((1 << XS1_USB_PHY_STATUS_UTMI_LINESTATE_SIZE) - 1) << XS1_USB_PHY_STATUS_UTMI_LINESTATE_SHIFT)
/**
 * Extract the USB_PHY_STATUS_UTMI_LINESTATE bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_STATUS_UTMI_LINESTATE(x) (((x) & XS1_USB_PHY_STATUS_UTMI_LINESTATE_MASK) >> XS1_USB_PHY_STATUS_UTMI_LINESTATE_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_STATUS_UTMI_LINESTATE bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_STATUS_UTMI_LINESTATE_SET(x, v) (((x) & ~XS1_USB_PHY_STATUS_UTMI_LINESTATE_MASK) | (((v) << XS1_USB_PHY_STATUS_UTMI_LINESTATE_SHIFT) & XS1_USB_PHY_STATUS_UTMI_LINESTATE_MASK))
///@}
/**
 * \name USB_PHY_STATUS_HOSTDISCONNECT
 * \anchor USB_PHY_STATUS_HOSTDISCONNECT
 * Set to 1 if no peripheral is connected
 */
///@{
#define XS1_USB_PHY_STATUS_HOSTDISCONNECT_SHIFT 0x2
#define XS1_USB_PHY_STATUS_HOSTDISCONNECT_SIZE 0x1
#define XS1_USB_PHY_STATUS_HOSTDISCONNECT_MASK (((1 << XS1_USB_PHY_STATUS_HOSTDISCONNECT_SIZE) - 1) << XS1_USB_PHY_STATUS_HOSTDISCONNECT_SHIFT)
/**
 * Extract the USB_PHY_STATUS_HOSTDISCONNECT bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_STATUS_HOSTDISCONNECT(x) (((x) & XS1_USB_PHY_STATUS_HOSTDISCONNECT_MASK) >> XS1_USB_PHY_STATUS_HOSTDISCONNECT_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_STATUS_HOSTDISCONNECT bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_STATUS_HOSTDISCONNECT_SET(x, v) (((x) & ~XS1_USB_PHY_STATUS_HOSTDISCONNECT_MASK) | (((v) << XS1_USB_PHY_STATUS_HOSTDISCONNECT_SHIFT) & XS1_USB_PHY_STATUS_HOSTDISCONNECT_MASK))
///@}
/**
 * \name USB_PHY_STATUS_IDPAD
 * \anchor USB_PHY_STATUS_IDPAD
 * 1 if resistance of IDPAD to ground is > 100 kOhm (mini B
 *       plug)
 */
///@{
#define XS1_USB_PHY_STATUS_IDPAD_SHIFT 0x3
#define XS1_USB_PHY_STATUS_IDPAD_SIZE 0x1
#define XS1_USB_PHY_STATUS_IDPAD_MASK (((1 << XS1_USB_PHY_STATUS_IDPAD_SIZE) - 1) << XS1_USB_PHY_STATUS_IDPAD_SHIFT)
/**
 * Extract the USB_PHY_STATUS_IDPAD bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_STATUS_IDPAD(x) (((x) & XS1_USB_PHY_STATUS_IDPAD_MASK) >> XS1_USB_PHY_STATUS_IDPAD_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_STATUS_IDPAD bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_STATUS_IDPAD_SET(x, v) (((x) & ~XS1_USB_PHY_STATUS_IDPAD_MASK) | (((v) << XS1_USB_PHY_STATUS_IDPAD_SHIFT) & XS1_USB_PHY_STATUS_IDPAD_MASK))
///@}
/**
 * \name USB_PHY_STATUS_BIST_OK
 * \anchor USB_PHY_STATUS_BIST_OK
 * 1 if BIST succeeded
 */
///@{
#define XS1_USB_PHY_STATUS_BIST_OK_SHIFT 0x4
#define XS1_USB_PHY_STATUS_BIST_OK_SIZE 0x1
#define XS1_USB_PHY_STATUS_BIST_OK_MASK (((1 << XS1_USB_PHY_STATUS_BIST_OK_SIZE) - 1) << XS1_USB_PHY_STATUS_BIST_OK_SHIFT)
/**
 * Extract the USB_PHY_STATUS_BIST_OK bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_STATUS_BIST_OK(x) (((x) & XS1_USB_PHY_STATUS_BIST_OK_MASK) >> XS1_USB_PHY_STATUS_BIST_OK_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_STATUS_BIST_OK bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_STATUS_BIST_OK_SET(x, v) (((x) & ~XS1_USB_PHY_STATUS_BIST_OK_MASK) | (((v) << XS1_USB_PHY_STATUS_BIST_OK_SHIFT) & XS1_USB_PHY_STATUS_BIST_OK_MASK))
///@}
/**
 * \name USB_PHY_STATUS_DEBUG_OUT
 * \anchor USB_PHY_STATUS_DEBUG_OUT
 * Debug output signals
 */
///@{
#define XS1_USB_PHY_STATUS_DEBUG_OUT_SHIFT 0x5
#define XS1_USB_PHY_STATUS_DEBUG_OUT_SIZE 0x10
#define XS1_USB_PHY_STATUS_DEBUG_OUT_MASK (((1 << XS1_USB_PHY_STATUS_DEBUG_OUT_SIZE) - 1) << XS1_USB_PHY_STATUS_DEBUG_OUT_SHIFT)
/**
 * Extract the USB_PHY_STATUS_DEBUG_OUT bitfield from a packed word x and return it.
 */
#define XS1_USB_PHY_STATUS_DEBUG_OUT(x) (((x) & XS1_USB_PHY_STATUS_DEBUG_OUT_MASK) >> XS1_USB_PHY_STATUS_DEBUG_OUT_SHIFT)
/**
 * Pack the value (v) of the USB_PHY_STATUS_DEBUG_OUT bitfield into a packed word x and return the packed field.
 */
#define XS1_USB_PHY_STATUS_DEBUG_OUT_SET(x, v) (((x) & ~XS1_USB_PHY_STATUS_DEBUG_OUT_MASK) | (((v) << XS1_USB_PHY_STATUS_DEBUG_OUT_SHIFT) & XS1_USB_PHY_STATUS_DEBUG_OUT_MASK))
///@}
/**
 * \name WATCHDOG_COUNT_ENABLE
 * \anchor WATCHDOG_COUNT_ENABLE
 * Set this bit to 1 to enable the watchdog counter.
 */
///@{
#define XS1_WATCHDOG_COUNT_ENABLE_SHIFT 0x0
#define XS1_WATCHDOG_COUNT_ENABLE_SIZE 0x1
#define XS1_WATCHDOG_COUNT_ENABLE_MASK (((1 << XS1_WATCHDOG_COUNT_ENABLE_SIZE) - 1) << XS1_WATCHDOG_COUNT_ENABLE_SHIFT)
/**
 * Extract the WATCHDOG_COUNT_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_WATCHDOG_COUNT_ENABLE(x) (((x) & XS1_WATCHDOG_COUNT_ENABLE_MASK) >> XS1_WATCHDOG_COUNT_ENABLE_SHIFT)
/**
 * Pack the value (v) of the WATCHDOG_COUNT_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_WATCHDOG_COUNT_ENABLE_SET(x, v) (((x) & ~XS1_WATCHDOG_COUNT_ENABLE_MASK) | (((v) << XS1_WATCHDOG_COUNT_ENABLE_SHIFT) & XS1_WATCHDOG_COUNT_ENABLE_MASK))
///@}
/**
 * \name WATCHDOG_TRIGGER_ENABLE
 * \anchor WATCHDOG_TRIGGER_ENABLE
 * Set this bit to 1 to enable the watchdog to actually
 *       reset the chip.
 */
///@{
#define XS1_WATCHDOG_TRIGGER_ENABLE_SHIFT 0x1
#define XS1_WATCHDOG_TRIGGER_ENABLE_SIZE 0x1
#define XS1_WATCHDOG_TRIGGER_ENABLE_MASK (((1 << XS1_WATCHDOG_TRIGGER_ENABLE_SIZE) - 1) << XS1_WATCHDOG_TRIGGER_ENABLE_SHIFT)
/**
 * Extract the WATCHDOG_TRIGGER_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_WATCHDOG_TRIGGER_ENABLE(x) (((x) & XS1_WATCHDOG_TRIGGER_ENABLE_MASK) >> XS1_WATCHDOG_TRIGGER_ENABLE_SHIFT)
/**
 * Pack the value (v) of the WATCHDOG_TRIGGER_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_WATCHDOG_TRIGGER_ENABLE_SET(x, v) (((x) & ~XS1_WATCHDOG_TRIGGER_ENABLE_MASK) | (((v) << XS1_WATCHDOG_TRIGGER_ENABLE_SHIFT) & XS1_WATCHDOG_TRIGGER_ENABLE_MASK))
///@}
/**
 * \name WATCHDOG_PRESCALER_VALUE
 * \anchor WATCHDOG_PRESCALER_VALUE
 * This is the current count of the prescaler. One is
 *       added one every input clock edge on the oscillator (XIN). When it
 *       reaches the prescaler wrap value (see below), it resets to zero and
 *       one is subtracted from the watchdog count (see below).
 */
///@{
#define XS1_WATCHDOG_PRESCALER_VALUE_SHIFT 0x0
#define XS1_WATCHDOG_PRESCALER_VALUE_SIZE 0x10
#define XS1_WATCHDOG_PRESCALER_VALUE_MASK (((1 << XS1_WATCHDOG_PRESCALER_VALUE_SIZE) - 1) << XS1_WATCHDOG_PRESCALER_VALUE_SHIFT)
/**
 * Extract the WATCHDOG_PRESCALER_VALUE bitfield from a packed word x and return it.
 */
#define XS1_WATCHDOG_PRESCALER_VALUE(x) (((x) & XS1_WATCHDOG_PRESCALER_VALUE_MASK) >> XS1_WATCHDOG_PRESCALER_VALUE_SHIFT)
/**
 * Pack the value (v) of the WATCHDOG_PRESCALER_VALUE bitfield into a packed word x and return the packed field.
 */
#define XS1_WATCHDOG_PRESCALER_VALUE_SET(x, v) (((x) & ~XS1_WATCHDOG_PRESCALER_VALUE_MASK) | (((v) << XS1_WATCHDOG_PRESCALER_VALUE_SHIFT) & XS1_WATCHDOG_PRESCALER_VALUE_MASK))
///@}
/**
 * \name WATCHDOG_PRESCALER_WRAP_VALUE
 * \anchor WATCHDOG_PRESCALER_WRAP_VALUE
 * This is the prescaler divider. The input clock on
 *       XIN is divided by this value plus one, before being used to adjust
 *       the watchdog count (see below).
 */
///@{
#define XS1_WATCHDOG_PRESCALER_WRAP_VALUE_SHIFT 0x0
#define XS1_WATCHDOG_PRESCALER_WRAP_VALUE_SIZE 0x10
#define XS1_WATCHDOG_PRESCALER_WRAP_VALUE_MASK (((1 << XS1_WATCHDOG_PRESCALER_WRAP_VALUE_SIZE) - 1) << XS1_WATCHDOG_PRESCALER_WRAP_VALUE_SHIFT)
/**
 * Extract the WATCHDOG_PRESCALER_WRAP_VALUE bitfield from a packed word x and return it.
 */
#define XS1_WATCHDOG_PRESCALER_WRAP_VALUE(x) (((x) & XS1_WATCHDOG_PRESCALER_WRAP_VALUE_MASK) >> XS1_WATCHDOG_PRESCALER_WRAP_VALUE_SHIFT)
/**
 * Pack the value (v) of the WATCHDOG_PRESCALER_WRAP_VALUE bitfield into a packed word x and return the packed field.
 */
#define XS1_WATCHDOG_PRESCALER_WRAP_VALUE_SET(x, v) (((x) & ~XS1_WATCHDOG_PRESCALER_WRAP_VALUE_MASK) | (((v) << XS1_WATCHDOG_PRESCALER_WRAP_VALUE_SHIFT) & XS1_WATCHDOG_PRESCALER_WRAP_VALUE_MASK))
///@}
/**
 * \name WATCHDOG_COUNT_VALUE
 * \anchor WATCHDOG_COUNT_VALUE
 * This is the watchdog counter. It counts down every
 *       PRESCALER_WRAP_VALUE input clock edges. When it reaches zero
 *       the chip is reset. The maximum time for the watchdog is
 *       ``2^{12} \times 2^{16} = 2^{28} = 268,435,456`` input clocks.
 *       
 */
///@{
#define XS1_WATCHDOG_COUNT_VALUE_SHIFT 0x0
#define XS1_WATCHDOG_COUNT_VALUE_SIZE 0xc
#define XS1_WATCHDOG_COUNT_VALUE_MASK (((1 << XS1_WATCHDOG_COUNT_VALUE_SIZE) - 1) << XS1_WATCHDOG_COUNT_VALUE_SHIFT)
/**
 * Extract the WATCHDOG_COUNT_VALUE bitfield from a packed word x and return it.
 */
#define XS1_WATCHDOG_COUNT_VALUE(x) (((x) & XS1_WATCHDOG_COUNT_VALUE_MASK) >> XS1_WATCHDOG_COUNT_VALUE_SHIFT)
/**
 * Pack the value (v) of the WATCHDOG_COUNT_VALUE bitfield into a packed word x and return the packed field.
 */
#define XS1_WATCHDOG_COUNT_VALUE_SET(x, v) (((x) & ~XS1_WATCHDOG_COUNT_VALUE_MASK) | (((v) << XS1_WATCHDOG_COUNT_VALUE_SHIFT) & XS1_WATCHDOG_COUNT_VALUE_MASK))
///@}
/**
 * \name WATCHDOG_HAS_TRIGGERED
 * \anchor WATCHDOG_HAS_TRIGGERED
 * When 1, the watchdog has been triggered. This bit is
 *       only reset to 0 on a power-on-reset.
 */
///@{
#define XS1_WATCHDOG_HAS_TRIGGERED_SHIFT 0x0
#define XS1_WATCHDOG_HAS_TRIGGERED_SIZE 0x1
#define XS1_WATCHDOG_HAS_TRIGGERED_MASK (((1 << XS1_WATCHDOG_HAS_TRIGGERED_SIZE) - 1) << XS1_WATCHDOG_HAS_TRIGGERED_SHIFT)
/**
 * Extract the WATCHDOG_HAS_TRIGGERED bitfield from a packed word x and return it.
 */
#define XS1_WATCHDOG_HAS_TRIGGERED(x) (((x) & XS1_WATCHDOG_HAS_TRIGGERED_MASK) >> XS1_WATCHDOG_HAS_TRIGGERED_SHIFT)
/**
 * Pack the value (v) of the WATCHDOG_HAS_TRIGGERED bitfield into a packed word x and return the packed field.
 */
#define XS1_WATCHDOG_HAS_TRIGGERED_SET(x, v) (((x) & ~XS1_WATCHDOG_HAS_TRIGGERED_MASK) | (((v) << XS1_WATCHDOG_HAS_TRIGGERED_SHIFT) & XS1_WATCHDOG_HAS_TRIGGERED_MASK))
///@}
/**
 * \name MIPI_STATUS0_OSC_CLK_ACT
 * \anchor MIPI_STATUS0_OSC_CLK_ACT
 * Test mode osc clock act
 */
///@{
#define XS1_MIPI_STATUS0_OSC_CLK_ACT_SHIFT 0x0
#define XS1_MIPI_STATUS0_OSC_CLK_ACT_SIZE 0x1
#define XS1_MIPI_STATUS0_OSC_CLK_ACT_MASK (((1 << XS1_MIPI_STATUS0_OSC_CLK_ACT_SIZE) - 1) << XS1_MIPI_STATUS0_OSC_CLK_ACT_SHIFT)
/**
 * Extract the MIPI_STATUS0_OSC_CLK_ACT bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_OSC_CLK_ACT(x) (((x) & XS1_MIPI_STATUS0_OSC_CLK_ACT_MASK) >> XS1_MIPI_STATUS0_OSC_CLK_ACT_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_OSC_CLK_ACT bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_OSC_CLK_ACT_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_OSC_CLK_ACT_MASK) | (((v) << XS1_MIPI_STATUS0_OSC_CLK_ACT_SHIFT) & XS1_MIPI_STATUS0_OSC_CLK_ACT_MASK))
///@}
/**
 * \name MIPI_STATUS0_OSC_CLK_READY
 * \anchor MIPI_STATUS0_OSC_CLK_READY
 * Test mode osc clock ready
 */
///@{
#define XS1_MIPI_STATUS0_OSC_CLK_READY_SHIFT 0x1
#define XS1_MIPI_STATUS0_OSC_CLK_READY_SIZE 0x1
#define XS1_MIPI_STATUS0_OSC_CLK_READY_MASK (((1 << XS1_MIPI_STATUS0_OSC_CLK_READY_SIZE) - 1) << XS1_MIPI_STATUS0_OSC_CLK_READY_SHIFT)
/**
 * Extract the MIPI_STATUS0_OSC_CLK_READY bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_OSC_CLK_READY(x) (((x) & XS1_MIPI_STATUS0_OSC_CLK_READY_MASK) >> XS1_MIPI_STATUS0_OSC_CLK_READY_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_OSC_CLK_READY bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_OSC_CLK_READY_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_OSC_CLK_READY_MASK) | (((v) << XS1_MIPI_STATUS0_OSC_CLK_READY_SHIFT) & XS1_MIPI_STATUS0_OSC_CLK_READY_MASK))
///@}
/**
 * \name MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G
 * \anchor MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G
 * Test mode bit clk greater than 2400G
 */
///@{
#define XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_SHIFT 0x2
#define XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_SIZE 0x1
#define XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_MASK (((1 << XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_SIZE) - 1) << XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_SHIFT)
/**
 * Extract the MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G(x) (((x) & XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_MASK) >> XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_MASK) | (((v) << XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_SHIFT) & XS1_MIPI_STATUS0_BIT_CLK_GREATER_THAN_2400G_MASK))
///@}
/**
 * \name MIPI_STATUS0_DATA_CORRECT_LAN0
 * \anchor MIPI_STATUS0_DATA_CORRECT_LAN0
 * Test mode data correct lan0
 */
///@{
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_SHIFT 0x3
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_SIZE 0x1
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_MASK (((1 << XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_SIZE) - 1) << XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_SHIFT)
/**
 * Extract the MIPI_STATUS0_DATA_CORRECT_LAN0 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN0(x) (((x) & XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_MASK) >> XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_DATA_CORRECT_LAN0 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_MASK) | (((v) << XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_SHIFT) & XS1_MIPI_STATUS0_DATA_CORRECT_LAN0_MASK))
///@}
/**
 * \name MIPI_STATUS0_DATA_CORRECT_LAN1
 * \anchor MIPI_STATUS0_DATA_CORRECT_LAN1
 * Test mode data correct lan1
 */
///@{
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_SHIFT 0x4
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_SIZE 0x1
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_MASK (((1 << XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_SIZE) - 1) << XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_SHIFT)
/**
 * Extract the MIPI_STATUS0_DATA_CORRECT_LAN1 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN1(x) (((x) & XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_MASK) >> XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_DATA_CORRECT_LAN1 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_MASK) | (((v) << XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_SHIFT) & XS1_MIPI_STATUS0_DATA_CORRECT_LAN1_MASK))
///@}
/**
 * \name MIPI_STATUS0_DATA_CORRECT_LAN2
 * \anchor MIPI_STATUS0_DATA_CORRECT_LAN2
 * Test mode data correct lan2
 */
///@{
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_SHIFT 0x5
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_SIZE 0x1
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_MASK (((1 << XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_SIZE) - 1) << XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_SHIFT)
/**
 * Extract the MIPI_STATUS0_DATA_CORRECT_LAN2 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN2(x) (((x) & XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_MASK) >> XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_DATA_CORRECT_LAN2 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_MASK) | (((v) << XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_SHIFT) & XS1_MIPI_STATUS0_DATA_CORRECT_LAN2_MASK))
///@}
/**
 * \name MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C
 * \anchor MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C
 * Test mode da cdphy r100 control0 2d1c
 */
///@{
#define XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_SHIFT 0x6
#define XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_SIZE 0x6
#define XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_MASK (((1 << XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_SIZE) - 1) << XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_SHIFT)
/**
 * Extract the MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C(x) (((x) & XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_MASK) >> XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_MASK) | (((v) << XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_SHIFT) & XS1_MIPI_STATUS0_DA_CDPHY_R100_CTRL0_2D1C_MASK))
///@}
/**
 * \name MIPI_STATUS0_STOPSTATE_CLK
 * \anchor MIPI_STATUS0_STOPSTATE_CLK
 * Clock lane is in the stop state
 */
///@{
#define XS1_MIPI_STATUS0_STOPSTATE_CLK_SHIFT 0xc
#define XS1_MIPI_STATUS0_STOPSTATE_CLK_SIZE 0x1
#define XS1_MIPI_STATUS0_STOPSTATE_CLK_MASK (((1 << XS1_MIPI_STATUS0_STOPSTATE_CLK_SIZE) - 1) << XS1_MIPI_STATUS0_STOPSTATE_CLK_SHIFT)
/**
 * Extract the MIPI_STATUS0_STOPSTATE_CLK bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_STOPSTATE_CLK(x) (((x) & XS1_MIPI_STATUS0_STOPSTATE_CLK_MASK) >> XS1_MIPI_STATUS0_STOPSTATE_CLK_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_STOPSTATE_CLK bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_STOPSTATE_CLK_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_STOPSTATE_CLK_MASK) | (((v) << XS1_MIPI_STATUS0_STOPSTATE_CLK_SHIFT) & XS1_MIPI_STATUS0_STOPSTATE_CLK_MASK))
///@}
/**
 * \name MIPI_STATUS0_STOPSTATE_LAN0
 * \anchor MIPI_STATUS0_STOPSTATE_LAN0
 * Lane 0 is in the stop state
 */
///@{
#define XS1_MIPI_STATUS0_STOPSTATE_LAN0_SHIFT 0xd
#define XS1_MIPI_STATUS0_STOPSTATE_LAN0_SIZE 0x1
#define XS1_MIPI_STATUS0_STOPSTATE_LAN0_MASK (((1 << XS1_MIPI_STATUS0_STOPSTATE_LAN0_SIZE) - 1) << XS1_MIPI_STATUS0_STOPSTATE_LAN0_SHIFT)
/**
 * Extract the MIPI_STATUS0_STOPSTATE_LAN0 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_STOPSTATE_LAN0(x) (((x) & XS1_MIPI_STATUS0_STOPSTATE_LAN0_MASK) >> XS1_MIPI_STATUS0_STOPSTATE_LAN0_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_STOPSTATE_LAN0 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_STOPSTATE_LAN0_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_STOPSTATE_LAN0_MASK) | (((v) << XS1_MIPI_STATUS0_STOPSTATE_LAN0_SHIFT) & XS1_MIPI_STATUS0_STOPSTATE_LAN0_MASK))
///@}
/**
 * \name MIPI_STATUS0_STOPSTATE_LAN1
 * \anchor MIPI_STATUS0_STOPSTATE_LAN1
 * Lane 1 is in the stop state
 */
///@{
#define XS1_MIPI_STATUS0_STOPSTATE_LAN1_SHIFT 0xe
#define XS1_MIPI_STATUS0_STOPSTATE_LAN1_SIZE 0x1
#define XS1_MIPI_STATUS0_STOPSTATE_LAN1_MASK (((1 << XS1_MIPI_STATUS0_STOPSTATE_LAN1_SIZE) - 1) << XS1_MIPI_STATUS0_STOPSTATE_LAN1_SHIFT)
/**
 * Extract the MIPI_STATUS0_STOPSTATE_LAN1 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_STATUS0_STOPSTATE_LAN1(x) (((x) & XS1_MIPI_STATUS0_STOPSTATE_LAN1_MASK) >> XS1_MIPI_STATUS0_STOPSTATE_LAN1_SHIFT)
/**
 * Pack the value (v) of the MIPI_STATUS0_STOPSTATE_LAN1 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_STATUS0_STOPSTATE_LAN1_SET(x, v) (((x) & ~XS1_MIPI_STATUS0_STOPSTATE_LAN1_MASK) | (((v) << XS1_MIPI_STATUS0_STOPSTATE_LAN1_SHIFT) & XS1_MIPI_STATUS0_STOPSTATE_LAN1_MASK))
///@}
/**
 * \name MIPI_SHIM_STATUS_REG
 * \anchor MIPI_SHIM_STATUS_REG
 * Set to 1 if an overflow has been detected in the
 *       DEMUXER. This is not recoverable, and indicates that the MIPI_CLK is
 *       too slow for the rate at which data is received.
 */
///@{
#define XS1_MIPI_SHIM_STATUS_REG_SHIFT 0x0
#define XS1_MIPI_SHIM_STATUS_REG_SIZE 0x1
#define XS1_MIPI_SHIM_STATUS_REG_MASK (((1 << XS1_MIPI_SHIM_STATUS_REG_SIZE) - 1) << XS1_MIPI_SHIM_STATUS_REG_SHIFT)
/**
 * Extract the MIPI_SHIM_STATUS_REG bitfield from a packed word x and return it.
 */
#define XS1_MIPI_SHIM_STATUS_REG(x) (((x) & XS1_MIPI_SHIM_STATUS_REG_MASK) >> XS1_MIPI_SHIM_STATUS_REG_SHIFT)
/**
 * Pack the value (v) of the MIPI_SHIM_STATUS_REG bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_SHIM_STATUS_REG_SET(x, v) (((x) & ~XS1_MIPI_SHIM_STATUS_REG_MASK) | (((v) << XS1_MIPI_SHIM_STATUS_REG_SHIFT) & XS1_MIPI_SHIM_STATUS_REG_MASK))
///@}
/**
 * \name MIPI_SHIM_CFG0_PIXEL_DEMUX_EN
 * \anchor MIPI_SHIM_CFG0_PIXEL_DEMUX_EN
 * Set to 1 to enable the MIPI shim to demultiplex data
 *       according to the demux mode and stuff fields. Demuxing is only
 *       applied to packets that have the correct datatype.
 */
///@{
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_SHIFT 0x0
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_SIZE 0x1
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_MASK (((1 << XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_SIZE) - 1) << XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_SHIFT)
/**
 * Extract the MIPI_SHIM_CFG0_PIXEL_DEMUX_EN bitfield from a packed word x and return it.
 */
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN(x) (((x) & XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_MASK) >> XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_SHIFT)
/**
 * Pack the value (v) of the MIPI_SHIM_CFG0_PIXEL_DEMUX_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_SET(x, v) (((x) & ~XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_MASK) | (((v) << XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_SHIFT) & XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_EN_MASK))
///@}
/**
 * \name MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE
 * \anchor MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE
 * This field needs to be set to the CSI-2 packet type that
 *       needs to be demuxed. Only packets with a matching type are
 *       demultiplexed.
 */
///@{
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_SHIFT 0x8
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_SIZE 0x8
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_MASK (((1 << XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_SIZE) - 1) << XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_SHIFT)
/**
 * Extract the MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE bitfield from a packed word x and return it.
 */
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE(x) (((x) & XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_MASK) >> XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_SHIFT)
/**
 * Pack the value (v) of the MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_SET(x, v) (((x) & ~XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_MASK) | (((v) << XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_SHIFT) & XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_DATATYPE_MASK))
///@}
/**
 * \name MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE
 * \anchor MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE
 * Specifies how the demultiplexer operates. The modes
 *       supported are 10to16, 12to16, 14to16, rgb565to888, rgb888to888.
 */
///@{
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_SHIFT 0x10
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_SIZE 0x6
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_MASK (((1 << XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_SIZE) - 1) << XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_SHIFT)
/**
 * Extract the MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE bitfield from a packed word x and return it.
 */
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE(x) (((x) & XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_MASK) >> XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_SHIFT)
/**
 * Pack the value (v) of the MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_SET(x, v) (((x) & ~XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_MASK) | (((v) << XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_SHIFT) & XS1_MIPI_SHIM_CFG0_PIXEL_DEMUX_MODE_MASK))
///@}
/**
 * \name MIPI_SHIM_DEMUX_STUFF
 * \anchor MIPI_SHIM_DEMUX_STUFF
 * Set to 1 to add an extra data byte after every RGB565 or
 *       RGB888 pixel. This will align pixels to a 32-bit word.
 */
///@{
#define XS1_MIPI_SHIM_DEMUX_STUFF_SHIFT 0x16
#define XS1_MIPI_SHIM_DEMUX_STUFF_SIZE 0x1
#define XS1_MIPI_SHIM_DEMUX_STUFF_MASK (((1 << XS1_MIPI_SHIM_DEMUX_STUFF_SIZE) - 1) << XS1_MIPI_SHIM_DEMUX_STUFF_SHIFT)
/**
 * Extract the MIPI_SHIM_DEMUX_STUFF bitfield from a packed word x and return it.
 */
#define XS1_MIPI_SHIM_DEMUX_STUFF(x) (((x) & XS1_MIPI_SHIM_DEMUX_STUFF_MASK) >> XS1_MIPI_SHIM_DEMUX_STUFF_SHIFT)
/**
 * Pack the value (v) of the MIPI_SHIM_DEMUX_STUFF bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_SHIM_DEMUX_STUFF_SET(x, v) (((x) & ~XS1_MIPI_SHIM_DEMUX_STUFF_MASK) | (((v) << XS1_MIPI_SHIM_DEMUX_STUFF_SHIFT) & XS1_MIPI_SHIM_DEMUX_STUFF_MASK))
///@}
/**
 * \name MIPI_SHIM_BIAS
 * \anchor MIPI_SHIM_BIAS
 * Set to 1 to offset the output pixels with -0x80 (for
 *       8-bit outputs) or -0x8000 (for 16-bit outputs). This can be used to
 *       make unsigned data signed around zero.
 */
///@{
#define XS1_MIPI_SHIM_BIAS_SHIFT 0x17
#define XS1_MIPI_SHIM_BIAS_SIZE 0x1
#define XS1_MIPI_SHIM_BIAS_MASK (((1 << XS1_MIPI_SHIM_BIAS_SIZE) - 1) << XS1_MIPI_SHIM_BIAS_SHIFT)
/**
 * Extract the MIPI_SHIM_BIAS bitfield from a packed word x and return it.
 */
#define XS1_MIPI_SHIM_BIAS(x) (((x) & XS1_MIPI_SHIM_BIAS_MASK) >> XS1_MIPI_SHIM_BIAS_SHIFT)
/**
 * Pack the value (v) of the MIPI_SHIM_BIAS bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_SHIM_BIAS_SET(x, v) (((x) & ~XS1_MIPI_SHIM_BIAS_MASK) | (((v) << XS1_MIPI_SHIM_BIAS_SHIFT) & XS1_MIPI_SHIM_BIAS_MASK))
///@}
/**
 * \name MIPI_SHIM_CFG0_SEL_DEBUG_OUT
 * \anchor MIPI_SHIM_CFG0_SEL_DEBUG_OUT
 * MIPI shim config0 sel debug out
 */
///@{
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_SHIFT 0x19
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_SIZE 0x1
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_MASK (((1 << XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_SIZE) - 1) << XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_SHIFT)
/**
 * Extract the MIPI_SHIM_CFG0_SEL_DEBUG_OUT bitfield from a packed word x and return it.
 */
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT(x) (((x) & XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_MASK) >> XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_SHIFT)
/**
 * Pack the value (v) of the MIPI_SHIM_CFG0_SEL_DEBUG_OUT bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_SET(x, v) (((x) & ~XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_MASK) | (((v) << XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_SHIFT) & XS1_MIPI_SHIM_CFG0_SEL_DEBUG_OUT_MASK))
///@}
/**
 * \name MIPI_SHIM_CFG0_SEL_DEBUG
 * \anchor MIPI_SHIM_CFG0_SEL_DEBUG
 * MIPI shim config0 sel debug
 */
///@{
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG_SHIFT 0x1a
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG_SIZE 0x1
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG_MASK (((1 << XS1_MIPI_SHIM_CFG0_SEL_DEBUG_SIZE) - 1) << XS1_MIPI_SHIM_CFG0_SEL_DEBUG_SHIFT)
/**
 * Extract the MIPI_SHIM_CFG0_SEL_DEBUG bitfield from a packed word x and return it.
 */
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG(x) (((x) & XS1_MIPI_SHIM_CFG0_SEL_DEBUG_MASK) >> XS1_MIPI_SHIM_CFG0_SEL_DEBUG_SHIFT)
/**
 * Pack the value (v) of the MIPI_SHIM_CFG0_SEL_DEBUG bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_SHIM_CFG0_SEL_DEBUG_SET(x, v) (((x) & ~XS1_MIPI_SHIM_CFG0_SEL_DEBUG_MASK) | (((v) << XS1_MIPI_SHIM_CFG0_SEL_DEBUG_SHIFT) & XS1_MIPI_SHIM_CFG0_SEL_DEBUG_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG0_HW_RSTN
 * \anchor MIPI_DPHY_CFG0_HW_RSTN
 * Reset, set to 1 to take the MIPI PHY out of reset
 */
///@{
#define XS1_MIPI_DPHY_CFG0_HW_RSTN_SHIFT 0x0
#define XS1_MIPI_DPHY_CFG0_HW_RSTN_SIZE 0x1
#define XS1_MIPI_DPHY_CFG0_HW_RSTN_MASK (((1 << XS1_MIPI_DPHY_CFG0_HW_RSTN_SIZE) - 1) << XS1_MIPI_DPHY_CFG0_HW_RSTN_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG0_HW_RSTN bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG0_HW_RSTN(x) (((x) & XS1_MIPI_DPHY_CFG0_HW_RSTN_MASK) >> XS1_MIPI_DPHY_CFG0_HW_RSTN_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG0_HW_RSTN bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG0_HW_RSTN_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG0_HW_RSTN_MASK) | (((v) << XS1_MIPI_DPHY_CFG0_HW_RSTN_SHIFT) & XS1_MIPI_DPHY_CFG0_HW_RSTN_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON
 * \anchor MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON
 * Set to 1
 */
///@{
#define XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_SHIFT 0x1
#define XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_SIZE 0x1
#define XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_MASK (((1 << XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_SIZE) - 1) << XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON(x) (((x) & XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_MASK) >> XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_MASK) | (((v) << XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_SHIFT) & XS1_MIPI_DPHY_CFG0_RSTB09_ALWAYS_ON_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG1_MP_TEST_EN
 * \anchor MIPI_DPHY_CFG1_MP_TEST_EN
 * MIPI dphy config1 mp test mode enable
 */
///@{
#define XS1_MIPI_DPHY_CFG1_MP_TEST_EN_SHIFT 0x0
#define XS1_MIPI_DPHY_CFG1_MP_TEST_EN_SIZE 0x1
#define XS1_MIPI_DPHY_CFG1_MP_TEST_EN_MASK (((1 << XS1_MIPI_DPHY_CFG1_MP_TEST_EN_SIZE) - 1) << XS1_MIPI_DPHY_CFG1_MP_TEST_EN_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG1_MP_TEST_EN bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG1_MP_TEST_EN(x) (((x) & XS1_MIPI_DPHY_CFG1_MP_TEST_EN_MASK) >> XS1_MIPI_DPHY_CFG1_MP_TEST_EN_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG1_MP_TEST_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG1_MP_TEST_EN_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG1_MP_TEST_EN_MASK) | (((v) << XS1_MIPI_DPHY_CFG1_MP_TEST_EN_SHIFT) & XS1_MIPI_DPHY_CFG1_MP_TEST_EN_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG1_MP_TEST_MODE_SEL
 * \anchor MIPI_DPHY_CFG1_MP_TEST_MODE_SEL
 * MIPI dphy config1 mp test mode select
 */
///@{
#define XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_SHIFT 0x1
#define XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_SIZE 0x5
#define XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_MASK (((1 << XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_SIZE) - 1) << XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG1_MP_TEST_MODE_SEL bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL(x) (((x) & XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_MASK) >> XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG1_MP_TEST_MODE_SEL bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_MASK) | (((v) << XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_SHIFT) & XS1_MIPI_DPHY_CFG1_MP_TEST_MODE_SEL_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN
 * \anchor MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN
 * MIPI dphy config1 cdphy r100 control 0 2d1c efuse enable
 */
///@{
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_SHIFT 0x6
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_SIZE 0x1
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_MASK (((1 << XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_SIZE) - 1) << XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN(x) (((x) & XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_MASK) >> XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_MASK) | (((v) << XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_SHIFT) & XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_EN_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN
 * \anchor MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN
 * MIPI dphy config1 cdphy r100 control 0 2d1c efuse in
 */
///@{
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_SHIFT 0x7
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_SIZE 0x6
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_MASK (((1 << XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_SIZE) - 1) << XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN(x) (((x) & XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_MASK) >> XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_MASK) | (((v) << XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_SHIFT) & XS1_MIPI_DPHY_CFG1_DA_CDPHY_R100_CTRL0_2D1C_EFUSE_IN_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG2_PLL_CLK_SEL
 * \anchor MIPI_DPHY_CFG2_PLL_CLK_SEL
 * MIPI dphy config2 pll clock select
 */
///@{
#define XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_SHIFT 0x0
#define XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_SIZE 0xa
#define XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_MASK (((1 << XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_SIZE) - 1) << XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG2_PLL_CLK_SEL bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL(x) (((x) & XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_MASK) >> XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG2_PLL_CLK_SEL bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_MASK) | (((v) << XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_SHIFT) & XS1_MIPI_DPHY_CFG2_PLL_CLK_SEL_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG3_LANE_SWAP_CLK
 * \anchor MIPI_DPHY_CFG3_LANE_SWAP_CLK
 * The DP/DN pair over which to input the clock
 */
///@{
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_SHIFT 0x0
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_SIZE 0x3
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_MASK (((1 << XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_SIZE) - 1) << XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG3_LANE_SWAP_CLK bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK(x) (((x) & XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_MASK) >> XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG3_LANE_SWAP_CLK bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_MASK) | (((v) << XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_SHIFT) & XS1_MIPI_DPHY_CFG3_LANE_SWAP_CLK_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG3_LANE_SWAP_LAN0
 * \anchor MIPI_DPHY_CFG3_LANE_SWAP_LAN0
 * The DP/DN pair over which to input lane 0
 */
///@{
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_SHIFT 0x3
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_SIZE 0x3
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_MASK (((1 << XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_SIZE) - 1) << XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG3_LANE_SWAP_LAN0 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0(x) (((x) & XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_MASK) >> XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG3_LANE_SWAP_LAN0 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_MASK) | (((v) << XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_SHIFT) & XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN0_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG3_LANE_SWAP_LAN1
 * \anchor MIPI_DPHY_CFG3_LANE_SWAP_LAN1
 * The DP/DN pair over which to input lane 1 (if two lanes
 *       are needed)
 */
///@{
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_SHIFT 0x6
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_SIZE 0x3
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_MASK (((1 << XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_SIZE) - 1) << XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG3_LANE_SWAP_LAN1 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1(x) (((x) & XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_MASK) >> XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG3_LANE_SWAP_LAN1 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_MASK) | (((v) << XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_SHIFT) & XS1_MIPI_DPHY_CFG3_LANE_SWAP_LAN1_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG3_DPDN_SWAP_CLK
 * \anchor MIPI_DPHY_CFG3_DPDN_SWAP_CLK
 * Set to 1 to swap the DN/DP pair on the clock lane
 */
///@{
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_SHIFT 0x9
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_SIZE 0x1
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_MASK (((1 << XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_SIZE) - 1) << XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG3_DPDN_SWAP_CLK bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK(x) (((x) & XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_MASK) >> XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG3_DPDN_SWAP_CLK bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_MASK) | (((v) << XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_SHIFT) & XS1_MIPI_DPHY_CFG3_DPDN_SWAP_CLK_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG3_DPDN_SWAP_LAN0
 * \anchor MIPI_DPHY_CFG3_DPDN_SWAP_LAN0
 * Set to 1 to swap the DN/DP pair on the lane 0
 */
///@{
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_SHIFT 0xa
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_SIZE 0x1
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_MASK (((1 << XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_SIZE) - 1) << XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG3_DPDN_SWAP_LAN0 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0(x) (((x) & XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_MASK) >> XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG3_DPDN_SWAP_LAN0 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_MASK) | (((v) << XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_SHIFT) & XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN0_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG3_DPDN_SWAP_LAN1
 * \anchor MIPI_DPHY_CFG3_DPDN_SWAP_LAN1
 * Set to 1 to swap the DN/DP pair on the lane 1
 */
///@{
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_SHIFT 0xb
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_SIZE 0x1
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_MASK (((1 << XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_SIZE) - 1) << XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG3_DPDN_SWAP_LAN1 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1(x) (((x) & XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_MASK) >> XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG3_DPDN_SWAP_LAN1 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_MASK) | (((v) << XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_SHIFT) & XS1_MIPI_DPHY_CFG3_DPDN_SWAP_LAN1_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG3_ENABLE_CLK
 * \anchor MIPI_DPHY_CFG3_ENABLE_CLK
 * Set to 0 to disable the clock lane receiver
 */
///@{
#define XS1_MIPI_DPHY_CFG3_ENABLE_CLK_SHIFT 0xc
#define XS1_MIPI_DPHY_CFG3_ENABLE_CLK_SIZE 0x1
#define XS1_MIPI_DPHY_CFG3_ENABLE_CLK_MASK (((1 << XS1_MIPI_DPHY_CFG3_ENABLE_CLK_SIZE) - 1) << XS1_MIPI_DPHY_CFG3_ENABLE_CLK_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG3_ENABLE_CLK bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG3_ENABLE_CLK(x) (((x) & XS1_MIPI_DPHY_CFG3_ENABLE_CLK_MASK) >> XS1_MIPI_DPHY_CFG3_ENABLE_CLK_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG3_ENABLE_CLK bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG3_ENABLE_CLK_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG3_ENABLE_CLK_MASK) | (((v) << XS1_MIPI_DPHY_CFG3_ENABLE_CLK_SHIFT) & XS1_MIPI_DPHY_CFG3_ENABLE_CLK_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG3_ENABLE_LAN0
 * \anchor MIPI_DPHY_CFG3_ENABLE_LAN0
 * Set to 0 to disable lane 0 receiver
 */
///@{
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_SHIFT 0xd
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_SIZE 0x1
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_MASK (((1 << XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_SIZE) - 1) << XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG3_ENABLE_LAN0 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN0(x) (((x) & XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_MASK) >> XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG3_ENABLE_LAN0 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_MASK) | (((v) << XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_SHIFT) & XS1_MIPI_DPHY_CFG3_ENABLE_LAN0_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG3_ENABLE_LAN1
 * \anchor MIPI_DPHY_CFG3_ENABLE_LAN1
 * Set to 0 to disable lane 1 receiver
 */
///@{
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_SHIFT 0xe
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_SIZE 0x1
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_MASK (((1 << XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_SIZE) - 1) << XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG3_ENABLE_LAN1 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN1(x) (((x) & XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_MASK) >> XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG3_ENABLE_LAN1 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_MASK) | (((v) << XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_SHIFT) & XS1_MIPI_DPHY_CFG3_ENABLE_LAN1_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK
 * \anchor MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK
 * MIPI dphy Tclk-settle for clock
 */
///@{
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_SHIFT 0x0
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_SIZE 0x8
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_MASK (((1 << XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_SIZE) - 1) << XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK(x) (((x) & XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_MASK) >> XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_MASK) | (((v) << XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_SHIFT) & XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_CLK_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0
 * \anchor MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0
 * MIPI dphy Tclk-settle in lane 0
 */
///@{
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_SHIFT 0x8
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_SIZE 0x8
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_MASK (((1 << XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_SIZE) - 1) << XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0(x) (((x) & XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_MASK) >> XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_MASK) | (((v) << XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_SHIFT) & XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN0_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1
 * \anchor MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1
 * MIPI dphy Tclk-settle in lane 1
 */
///@{
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_SHIFT 0x10
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_SIZE 0x8
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_MASK (((1 << XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_SIZE) - 1) << XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1 bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1(x) (((x) & XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_MASK) >> XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1 bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_MASK) | (((v) << XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_SHIFT) & XS1_MIPI_DPHY_CFG4_PRECOUNTER_IN_LAN1_MASK))
///@}
/**
 * \name MIPI_DPHY_CFG5_DEBUG_MODE_SEL
 * \anchor MIPI_DPHY_CFG5_DEBUG_MODE_SEL
 * MIPI dphy debug mode select
 */
///@{
#define XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_SHIFT 0x0
#define XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_SIZE 0x7
#define XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_MASK (((1 << XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_SIZE) - 1) << XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_SHIFT)
/**
 * Extract the MIPI_DPHY_CFG5_DEBUG_MODE_SEL bitfield from a packed word x and return it.
 */
#define XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL(x) (((x) & XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_MASK) >> XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_SHIFT)
/**
 * Pack the value (v) of the MIPI_DPHY_CFG5_DEBUG_MODE_SEL bitfield into a packed word x and return the packed field.
 */
#define XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_SET(x, v) (((x) & ~XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_MASK) | (((v) << XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_SHIFT) & XS1_MIPI_DPHY_CFG5_DEBUG_MODE_SEL_MASK))
///@}
/**
 * \name LPDDR_IID_ENABLE
 * \anchor LPDDR_IID_ENABLE
 * Two 8-bit masks, one bit per thread. Top eight bits enable
 *       instructions to be routed through a specified queue, bottom eight
 *       bits enable data to be routed through a specified queue.
 */
///@{
#define XS1_LPDDR_IID_ENABLE_SHIFT 0x0
#define XS1_LPDDR_IID_ENABLE_SIZE 0x10
#define XS1_LPDDR_IID_ENABLE_MASK (((1 << XS1_LPDDR_IID_ENABLE_SIZE) - 1) << XS1_LPDDR_IID_ENABLE_SHIFT)
/**
 * Extract the LPDDR_IID_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_IID_ENABLE(x) (((x) & XS1_LPDDR_IID_ENABLE_MASK) >> XS1_LPDDR_IID_ENABLE_SHIFT)
/**
 * Pack the value (v) of the LPDDR_IID_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_IID_ENABLE_SET(x, v) (((x) & ~XS1_LPDDR_IID_ENABLE_MASK) | (((v) << XS1_LPDDR_IID_ENABLE_SHIFT) & XS1_LPDDR_IID_ENABLE_MASK))
///@}
/**
 * \name LPDDR_IID_0_7
 * \anchor LPDDR_IID_0_7
 * Four bits per thread. Top bit sets the queue type that
 *       this thread should be using (0: RO, 1: RW), further three bits the
 *       number of the queue. Valid values for the further three bits are 000
 *       for RO queues, and 000/001 for a RW queue.
 */
///@{
#define XS1_LPDDR_IID_0_7_SHIFT 0x0
#define XS1_LPDDR_IID_0_7_SIZE 0x20
#define XS1_LPDDR_IID_0_7_MASK (((1 << XS1_LPDDR_IID_0_7_SIZE) - 1) << XS1_LPDDR_IID_0_7_SHIFT)
/**
 * Extract the LPDDR_IID_0_7 bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_IID_0_7(x) (((x) & XS1_LPDDR_IID_0_7_MASK) >> XS1_LPDDR_IID_0_7_SHIFT)
/**
 * Pack the value (v) of the LPDDR_IID_0_7 bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_IID_0_7_SET(x, v) (((x) & ~XS1_LPDDR_IID_0_7_MASK) | (((v) << XS1_LPDDR_IID_0_7_SHIFT) & XS1_LPDDR_IID_0_7_MASK))
///@}
/**
 * \name LPDDR_IID_8_15
 * \anchor LPDDR_IID_8_15
 * Four bits per thread. Top bit sets the queue type that
 *       this thread should be using (0: RO, 1: RW), further three bits the
 *       number of the queue. Valid values for the further three bits are 000
 *       for RO queues, and 000/001 for a RW queue.
 */
///@{
#define XS1_LPDDR_IID_8_15_SHIFT 0x0
#define XS1_LPDDR_IID_8_15_SIZE 0x20
#define XS1_LPDDR_IID_8_15_MASK (((1 << XS1_LPDDR_IID_8_15_SIZE) - 1) << XS1_LPDDR_IID_8_15_SHIFT)
/**
 * Extract the LPDDR_IID_8_15 bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_IID_8_15(x) (((x) & XS1_LPDDR_IID_8_15_MASK) >> XS1_LPDDR_IID_8_15_SHIFT)
/**
 * Pack the value (v) of the LPDDR_IID_8_15 bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_IID_8_15_SET(x, v) (((x) & ~XS1_LPDDR_IID_8_15_MASK) | (((v) << XS1_LPDDR_IID_8_15_SHIFT) & XS1_LPDDR_IID_8_15_MASK))
///@}
/**
 * \name LPDDR_QUEUE_CONT
 * \anchor LPDDR_QUEUE_CONT
 * Slow sys clock. Set this bit if the tile clock is less
 *       than the LPDDR clock.
 */
///@{
#define XS1_LPDDR_QUEUE_CONT_SHIFT 0x0
#define XS1_LPDDR_QUEUE_CONT_SIZE 0x1
#define XS1_LPDDR_QUEUE_CONT_MASK (((1 << XS1_LPDDR_QUEUE_CONT_SIZE) - 1) << XS1_LPDDR_QUEUE_CONT_SHIFT)
/**
 * Extract the LPDDR_QUEUE_CONT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_QUEUE_CONT(x) (((x) & XS1_LPDDR_QUEUE_CONT_MASK) >> XS1_LPDDR_QUEUE_CONT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_QUEUE_CONT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_QUEUE_CONT_SET(x, v) (((x) & ~XS1_LPDDR_QUEUE_CONT_MASK) | (((v) << XS1_LPDDR_QUEUE_CONT_SHIFT) & XS1_LPDDR_QUEUE_CONT_MASK))
///@}
/**
 * \name LPDDR_RO_PRI
 * \anchor LPDDR_RO_PRI
 * Priority for RO queue. Zero is lowest priority.
 */
///@{
#define XS1_LPDDR_RO_PRI_SHIFT 0x0
#define XS1_LPDDR_RO_PRI_SIZE 0x3
#define XS1_LPDDR_RO_PRI_MASK (((1 << XS1_LPDDR_RO_PRI_SIZE) - 1) << XS1_LPDDR_RO_PRI_SHIFT)
/**
 * Extract the LPDDR_RO_PRI bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_RO_PRI(x) (((x) & XS1_LPDDR_RO_PRI_MASK) >> XS1_LPDDR_RO_PRI_SHIFT)
/**
 * Pack the value (v) of the LPDDR_RO_PRI bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_RO_PRI_SET(x, v) (((x) & ~XS1_LPDDR_RO_PRI_MASK) | (((v) << XS1_LPDDR_RO_PRI_SHIFT) & XS1_LPDDR_RO_PRI_MASK))
///@}
/**
 * \name LPDDR_RW0_PRI
 * \anchor LPDDR_RW0_PRI
 * Priority for RW queue 0. Zero is lowest priority.
 */
///@{
#define XS1_LPDDR_RW0_PRI_SHIFT 0x0
#define XS1_LPDDR_RW0_PRI_SIZE 0x3
#define XS1_LPDDR_RW0_PRI_MASK (((1 << XS1_LPDDR_RW0_PRI_SIZE) - 1) << XS1_LPDDR_RW0_PRI_SHIFT)
/**
 * Extract the LPDDR_RW0_PRI bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_RW0_PRI(x) (((x) & XS1_LPDDR_RW0_PRI_MASK) >> XS1_LPDDR_RW0_PRI_SHIFT)
/**
 * Pack the value (v) of the LPDDR_RW0_PRI bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_RW0_PRI_SET(x, v) (((x) & ~XS1_LPDDR_RW0_PRI_MASK) | (((v) << XS1_LPDDR_RW0_PRI_SHIFT) & XS1_LPDDR_RW0_PRI_MASK))
///@}
/**
 * \name LPDDR_RW1_PRI
 * \anchor LPDDR_RW1_PRI
 * Priority for RW queue 1. Zero is lowest priority.
 */
///@{
#define XS1_LPDDR_RW1_PRI_SHIFT 0x3
#define XS1_LPDDR_RW1_PRI_SIZE 0x3
#define XS1_LPDDR_RW1_PRI_MASK (((1 << XS1_LPDDR_RW1_PRI_SIZE) - 1) << XS1_LPDDR_RW1_PRI_SHIFT)
/**
 * Extract the LPDDR_RW1_PRI bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_RW1_PRI(x) (((x) & XS1_LPDDR_RW1_PRI_MASK) >> XS1_LPDDR_RW1_PRI_SHIFT)
/**
 * Pack the value (v) of the LPDDR_RW1_PRI bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_RW1_PRI_SET(x, v) (((x) & ~XS1_LPDDR_RW1_PRI_MASK) | (((v) << XS1_LPDDR_RW1_PRI_SHIFT) & XS1_LPDDR_RW1_PRI_MASK))
///@}
/**
 * \name LPDDR_TOUT
 * \anchor LPDDR_TOUT
 * Maximum number of transactions until a queue is served.
 *                    Set to 0 to disable a timeout
 */
///@{
#define XS1_LPDDR_TOUT_SHIFT 0x0
#define XS1_LPDDR_TOUT_SIZE 0x4
#define XS1_LPDDR_TOUT_MASK (((1 << XS1_LPDDR_TOUT_SIZE) - 1) << XS1_LPDDR_TOUT_SHIFT)
/**
 * Extract the LPDDR_TOUT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_TOUT(x) (((x) & XS1_LPDDR_TOUT_MASK) >> XS1_LPDDR_TOUT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_TOUT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_TOUT_SET(x, v) (((x) & ~XS1_LPDDR_TOUT_MASK) | (((v) << XS1_LPDDR_TOUT_SHIFT) & XS1_LPDDR_TOUT_MASK))
///@}
/**
 * \name LPDDR_MTG_CMD
 * \anchor LPDDR_MTG_CMD
 * MTG Commands status for CSR Read
 */
///@{
#define XS1_LPDDR_MTG_CMD_SHIFT 0x0
#define XS1_LPDDR_MTG_CMD_SIZE 0x6
#define XS1_LPDDR_MTG_CMD_MASK (((1 << XS1_LPDDR_MTG_CMD_SIZE) - 1) << XS1_LPDDR_MTG_CMD_SHIFT)
/**
 * Extract the LPDDR_MTG_CMD bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_MTG_CMD(x) (((x) & XS1_LPDDR_MTG_CMD_MASK) >> XS1_LPDDR_MTG_CMD_SHIFT)
/**
 * Pack the value (v) of the LPDDR_MTG_CMD bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_MTG_CMD_SET(x, v) (((x) & ~XS1_LPDDR_MTG_CMD_MASK) | (((v) << XS1_LPDDR_MTG_CMD_SHIFT) & XS1_LPDDR_MTG_CMD_MASK))
///@}
/**
 * \name LPDDR_DLL_CONTROL
 * \anchor LPDDR_DLL_CONTROL
 * DLL Control
 */
///@{
#define XS1_LPDDR_DLL_CONTROL_SHIFT 0x0
#define XS1_LPDDR_DLL_CONTROL_SIZE 0x16
#define XS1_LPDDR_DLL_CONTROL_MASK (((1 << XS1_LPDDR_DLL_CONTROL_SIZE) - 1) << XS1_LPDDR_DLL_CONTROL_SHIFT)
/**
 * Extract the LPDDR_DLL_CONTROL bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_DLL_CONTROL(x) (((x) & XS1_LPDDR_DLL_CONTROL_MASK) >> XS1_LPDDR_DLL_CONTROL_SHIFT)
/**
 * Pack the value (v) of the LPDDR_DLL_CONTROL bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_DLL_CONTROL_SET(x, v) (((x) & ~XS1_LPDDR_DLL_CONTROL_MASK) | (((v) << XS1_LPDDR_DLL_CONTROL_SHIFT) & XS1_LPDDR_DLL_CONTROL_MASK))
///@}
/**
 * \name LPDDR_DLL_MEASUREMENT_STATUS
 * \anchor LPDDR_DLL_MEASUREMENT_STATUS
 * Measurement status of the DLL
 */
///@{
#define XS1_LPDDR_DLL_MEASUREMENT_STATUS_SHIFT 0x0
#define XS1_LPDDR_DLL_MEASUREMENT_STATUS_SIZE 0x1c
#define XS1_LPDDR_DLL_MEASUREMENT_STATUS_MASK (((1 << XS1_LPDDR_DLL_MEASUREMENT_STATUS_SIZE) - 1) << XS1_LPDDR_DLL_MEASUREMENT_STATUS_SHIFT)
/**
 * Extract the LPDDR_DLL_MEASUREMENT_STATUS bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_DLL_MEASUREMENT_STATUS(x) (((x) & XS1_LPDDR_DLL_MEASUREMENT_STATUS_MASK) >> XS1_LPDDR_DLL_MEASUREMENT_STATUS_SHIFT)
/**
 * Pack the value (v) of the LPDDR_DLL_MEASUREMENT_STATUS bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_DLL_MEASUREMENT_STATUS_SET(x, v) (((x) & ~XS1_LPDDR_DLL_MEASUREMENT_STATUS_MASK) | (((v) << XS1_LPDDR_DLL_MEASUREMENT_STATUS_SHIFT) & XS1_LPDDR_DLL_MEASUREMENT_STATUS_MASK))
///@}
/**
 * \name LPDDR_DLL_MANUAL_CONTROL
 * \anchor LPDDR_DLL_MANUAL_CONTROL
 * DLL Manual Control
 */
///@{
#define XS1_LPDDR_DLL_MANUAL_CONTROL_SHIFT 0x0
#define XS1_LPDDR_DLL_MANUAL_CONTROL_SIZE 0x20
#define XS1_LPDDR_DLL_MANUAL_CONTROL_MASK (((1 << XS1_LPDDR_DLL_MANUAL_CONTROL_SIZE) - 1) << XS1_LPDDR_DLL_MANUAL_CONTROL_SHIFT)
/**
 * Extract the LPDDR_DLL_MANUAL_CONTROL bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_DLL_MANUAL_CONTROL(x) (((x) & XS1_LPDDR_DLL_MANUAL_CONTROL_MASK) >> XS1_LPDDR_DLL_MANUAL_CONTROL_SHIFT)
/**
 * Pack the value (v) of the LPDDR_DLL_MANUAL_CONTROL bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_DLL_MANUAL_CONTROL_SET(x, v) (((x) & ~XS1_LPDDR_DLL_MANUAL_CONTROL_MASK) | (((v) << XS1_LPDDR_DLL_MANUAL_CONTROL_SHIFT) & XS1_LPDDR_DLL_MANUAL_CONTROL_MASK))
///@}
/**
 * \name LPDDR_DLL_PHY_CALIBRATION_DATA
 * \anchor LPDDR_DLL_PHY_CALIBRATION_DATA
 * DLL Calibration Data
 */
///@{
#define XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_SHIFT 0x0
#define XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_SIZE 0x18
#define XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_MASK (((1 << XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_SIZE) - 1) << XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_SHIFT)
/**
 * Extract the LPDDR_DLL_PHY_CALIBRATION_DATA bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_DLL_PHY_CALIBRATION_DATA(x) (((x) & XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_MASK) >> XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_SHIFT)
/**
 * Pack the value (v) of the LPDDR_DLL_PHY_CALIBRATION_DATA bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_SET(x, v) (((x) & ~XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_MASK) | (((v) << XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_SHIFT) & XS1_LPDDR_DLL_PHY_CALIBRATION_DATA_MASK))
///@}
/**
 * \name LPDDR_PHY_CONTROL
 * \anchor LPDDR_PHY_CONTROL
 * PHY Control
 */
///@{
#define XS1_LPDDR_PHY_CONTROL_SHIFT 0x0
#define XS1_LPDDR_PHY_CONTROL_SIZE 0xe
#define XS1_LPDDR_PHY_CONTROL_MASK (((1 << XS1_LPDDR_PHY_CONTROL_SIZE) - 1) << XS1_LPDDR_PHY_CONTROL_SHIFT)
/**
 * Extract the LPDDR_PHY_CONTROL bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PHY_CONTROL(x) (((x) & XS1_LPDDR_PHY_CONTROL_MASK) >> XS1_LPDDR_PHY_CONTROL_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PHY_CONTROL bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PHY_CONTROL_SET(x, v) (((x) & ~XS1_LPDDR_PHY_CONTROL_MASK) | (((v) << XS1_LPDDR_PHY_CONTROL_SHIFT) & XS1_LPDDR_PHY_CONTROL_MASK))
///@}
/**
 * \name LPDDR_LMR_OPCODE
 * \anchor LPDDR_LMR_OPCODE
 * LMR opcode
 */
///@{
#define XS1_LPDDR_LMR_OPCODE_SHIFT 0x0
#define XS1_LPDDR_LMR_OPCODE_SIZE 0xe
#define XS1_LPDDR_LMR_OPCODE_MASK (((1 << XS1_LPDDR_LMR_OPCODE_SIZE) - 1) << XS1_LPDDR_LMR_OPCODE_SHIFT)
/**
 * Extract the LPDDR_LMR_OPCODE bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_LMR_OPCODE(x) (((x) & XS1_LPDDR_LMR_OPCODE_MASK) >> XS1_LPDDR_LMR_OPCODE_SHIFT)
/**
 * Pack the value (v) of the LPDDR_LMR_OPCODE bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_LMR_OPCODE_SET(x, v) (((x) & ~XS1_LPDDR_LMR_OPCODE_MASK) | (((v) << XS1_LPDDR_LMR_OPCODE_SHIFT) & XS1_LPDDR_LMR_OPCODE_MASK))
///@}
/**
 * \name LPDDR_EMR_OPCODE
 * \anchor LPDDR_EMR_OPCODE
 * EMR opcode
 */
///@{
#define XS1_LPDDR_EMR_OPCODE_SHIFT 0x0
#define XS1_LPDDR_EMR_OPCODE_SIZE 0xe
#define XS1_LPDDR_EMR_OPCODE_MASK (((1 << XS1_LPDDR_EMR_OPCODE_SIZE) - 1) << XS1_LPDDR_EMR_OPCODE_SHIFT)
/**
 * Extract the LPDDR_EMR_OPCODE bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_EMR_OPCODE(x) (((x) & XS1_LPDDR_EMR_OPCODE_MASK) >> XS1_LPDDR_EMR_OPCODE_SHIFT)
/**
 * Pack the value (v) of the LPDDR_EMR_OPCODE bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_EMR_OPCODE_SET(x, v) (((x) & ~XS1_LPDDR_EMR_OPCODE_MASK) | (((v) << XS1_LPDDR_EMR_OPCODE_SHIFT) & XS1_LPDDR_EMR_OPCODE_MASK))
///@}
/**
 * \name LPDDR_PE_TREFI_CNT
 * \anchor LPDDR_PE_TREFI_CNT
 * LPDDR tREFI clock count
 */
///@{
#define XS1_LPDDR_PE_TREFI_CNT_SHIFT 0x0
#define XS1_LPDDR_PE_TREFI_CNT_SIZE 0xb
#define XS1_LPDDR_PE_TREFI_CNT_MASK (((1 << XS1_LPDDR_PE_TREFI_CNT_SIZE) - 1) << XS1_LPDDR_PE_TREFI_CNT_SHIFT)
/**
 * Extract the LPDDR_PE_TREFI_CNT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_TREFI_CNT(x) (((x) & XS1_LPDDR_PE_TREFI_CNT_MASK) >> XS1_LPDDR_PE_TREFI_CNT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_TREFI_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_TREFI_CNT_SET(x, v) (((x) & ~XS1_LPDDR_PE_TREFI_CNT_MASK) | (((v) << XS1_LPDDR_PE_TREFI_CNT_SHIFT) & XS1_LPDDR_PE_TREFI_CNT_MASK))
///@}
/**
 * \name LPDDR_PE_TRAS_CNT
 * \anchor LPDDR_PE_TRAS_CNT
 * LPDDR tRAS clock count
 */
///@{
#define XS1_LPDDR_PE_TRAS_CNT_SHIFT 0xb
#define XS1_LPDDR_PE_TRAS_CNT_SIZE 0x4
#define XS1_LPDDR_PE_TRAS_CNT_MASK (((1 << XS1_LPDDR_PE_TRAS_CNT_SIZE) - 1) << XS1_LPDDR_PE_TRAS_CNT_SHIFT)
/**
 * Extract the LPDDR_PE_TRAS_CNT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_TRAS_CNT(x) (((x) & XS1_LPDDR_PE_TRAS_CNT_MASK) >> XS1_LPDDR_PE_TRAS_CNT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_TRAS_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_TRAS_CNT_SET(x, v) (((x) & ~XS1_LPDDR_PE_TRAS_CNT_MASK) | (((v) << XS1_LPDDR_PE_TRAS_CNT_SHIFT) & XS1_LPDDR_PE_TRAS_CNT_MASK))
///@}
/**
 * \name LPDDR_PE_TXSR_CNT
 * \anchor LPDDR_PE_TXSR_CNT
 * LPDDR tXSR clock count
 */
///@{
#define XS1_LPDDR_PE_TXSR_CNT_SHIFT 0xf
#define XS1_LPDDR_PE_TXSR_CNT_SIZE 0x6
#define XS1_LPDDR_PE_TXSR_CNT_MASK (((1 << XS1_LPDDR_PE_TXSR_CNT_SIZE) - 1) << XS1_LPDDR_PE_TXSR_CNT_SHIFT)
/**
 * Extract the LPDDR_PE_TXSR_CNT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_TXSR_CNT(x) (((x) & XS1_LPDDR_PE_TXSR_CNT_MASK) >> XS1_LPDDR_PE_TXSR_CNT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_TXSR_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_TXSR_CNT_SET(x, v) (((x) & ~XS1_LPDDR_PE_TXSR_CNT_MASK) | (((v) << XS1_LPDDR_PE_TXSR_CNT_SHIFT) & XS1_LPDDR_PE_TXSR_CNT_MASK))
///@}
/**
 * \name LPDDR_PE_TWR_CNT
 * \anchor LPDDR_PE_TWR_CNT
 * LPDDR tWR clock count
 */
///@{
#define XS1_LPDDR_PE_TWR_CNT_SHIFT 0x15
#define XS1_LPDDR_PE_TWR_CNT_SIZE 0x3
#define XS1_LPDDR_PE_TWR_CNT_MASK (((1 << XS1_LPDDR_PE_TWR_CNT_SIZE) - 1) << XS1_LPDDR_PE_TWR_CNT_SHIFT)
/**
 * Extract the LPDDR_PE_TWR_CNT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_TWR_CNT(x) (((x) & XS1_LPDDR_PE_TWR_CNT_MASK) >> XS1_LPDDR_PE_TWR_CNT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_TWR_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_TWR_CNT_SET(x, v) (((x) & ~XS1_LPDDR_PE_TWR_CNT_MASK) | (((v) << XS1_LPDDR_PE_TWR_CNT_SHIFT) & XS1_LPDDR_PE_TWR_CNT_MASK))
///@}
/**
 * \name LPDDR_PE_TRC_CNT
 * \anchor LPDDR_PE_TRC_CNT
 * LPDDR tRC clock count
 */
///@{
#define XS1_LPDDR_PE_TRC_CNT_SHIFT 0x0
#define XS1_LPDDR_PE_TRC_CNT_SIZE 0x4
#define XS1_LPDDR_PE_TRC_CNT_MASK (((1 << XS1_LPDDR_PE_TRC_CNT_SIZE) - 1) << XS1_LPDDR_PE_TRC_CNT_SHIFT)
/**
 * Extract the LPDDR_PE_TRC_CNT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_TRC_CNT(x) (((x) & XS1_LPDDR_PE_TRC_CNT_MASK) >> XS1_LPDDR_PE_TRC_CNT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_TRC_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_TRC_CNT_SET(x, v) (((x) & ~XS1_LPDDR_PE_TRC_CNT_MASK) | (((v) << XS1_LPDDR_PE_TRC_CNT_SHIFT) & XS1_LPDDR_PE_TRC_CNT_MASK))
///@}
/**
 * \name LPDDR_PE_TRCD_CNT
 * \anchor LPDDR_PE_TRCD_CNT
 * LPDDR tRCD clock count
 */
///@{
#define XS1_LPDDR_PE_TRCD_CNT_SHIFT 0x4
#define XS1_LPDDR_PE_TRCD_CNT_SIZE 0x3
#define XS1_LPDDR_PE_TRCD_CNT_MASK (((1 << XS1_LPDDR_PE_TRCD_CNT_SIZE) - 1) << XS1_LPDDR_PE_TRCD_CNT_SHIFT)
/**
 * Extract the LPDDR_PE_TRCD_CNT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_TRCD_CNT(x) (((x) & XS1_LPDDR_PE_TRCD_CNT_MASK) >> XS1_LPDDR_PE_TRCD_CNT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_TRCD_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_TRCD_CNT_SET(x, v) (((x) & ~XS1_LPDDR_PE_TRCD_CNT_MASK) | (((v) << XS1_LPDDR_PE_TRCD_CNT_SHIFT) & XS1_LPDDR_PE_TRCD_CNT_MASK))
///@}
/**
 * \name LPDDR_PE_TRP_CNT
 * \anchor LPDDR_PE_TRP_CNT
 * LPDDR tRP clock count
 */
///@{
#define XS1_LPDDR_PE_TRP_CNT_SHIFT 0x7
#define XS1_LPDDR_PE_TRP_CNT_SIZE 0x3
#define XS1_LPDDR_PE_TRP_CNT_MASK (((1 << XS1_LPDDR_PE_TRP_CNT_SIZE) - 1) << XS1_LPDDR_PE_TRP_CNT_SHIFT)
/**
 * Extract the LPDDR_PE_TRP_CNT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_TRP_CNT(x) (((x) & XS1_LPDDR_PE_TRP_CNT_MASK) >> XS1_LPDDR_PE_TRP_CNT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_TRP_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_TRP_CNT_SET(x, v) (((x) & ~XS1_LPDDR_PE_TRP_CNT_MASK) | (((v) << XS1_LPDDR_PE_TRP_CNT_SHIFT) & XS1_LPDDR_PE_TRP_CNT_MASK))
///@}
/**
 * \name LPDDR_PE_TRFC_CNT
 * \anchor LPDDR_PE_TRFC_CNT
 * LPDDR tRFC clock count
 */
///@{
#define XS1_LPDDR_PE_TRFC_CNT_SHIFT 0xa
#define XS1_LPDDR_PE_TRFC_CNT_SIZE 0x5
#define XS1_LPDDR_PE_TRFC_CNT_MASK (((1 << XS1_LPDDR_PE_TRFC_CNT_SIZE) - 1) << XS1_LPDDR_PE_TRFC_CNT_SHIFT)
/**
 * Extract the LPDDR_PE_TRFC_CNT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_TRFC_CNT(x) (((x) & XS1_LPDDR_PE_TRFC_CNT_MASK) >> XS1_LPDDR_PE_TRFC_CNT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_TRFC_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_TRFC_CNT_SET(x, v) (((x) & ~XS1_LPDDR_PE_TRFC_CNT_MASK) | (((v) << XS1_LPDDR_PE_TRFC_CNT_SHIFT) & XS1_LPDDR_PE_TRFC_CNT_MASK))
///@}
/**
 * \name LPDDR_PE_TRRD_CNT
 * \anchor LPDDR_PE_TRRD_CNT
 * LPDDR tRRD clock count
 */
///@{
#define XS1_LPDDR_PE_TRRD_CNT_SHIFT 0xf
#define XS1_LPDDR_PE_TRRD_CNT_SIZE 0x2
#define XS1_LPDDR_PE_TRRD_CNT_MASK (((1 << XS1_LPDDR_PE_TRRD_CNT_SIZE) - 1) << XS1_LPDDR_PE_TRRD_CNT_SHIFT)
/**
 * Extract the LPDDR_PE_TRRD_CNT bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_TRRD_CNT(x) (((x) & XS1_LPDDR_PE_TRRD_CNT_MASK) >> XS1_LPDDR_PE_TRRD_CNT_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_TRRD_CNT bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_TRRD_CNT_SET(x, v) (((x) & ~XS1_LPDDR_PE_TRRD_CNT_MASK) | (((v) << XS1_LPDDR_PE_TRRD_CNT_SHIFT) & XS1_LPDDR_PE_TRRD_CNT_MASK))
///@}
/**
 * \name LPDDR_PE_EN_256M_DEV_SIZE
 * \anchor LPDDR_PE_EN_256M_DEV_SIZE
 * Enable 256 Mbit device
 */
///@{
#define XS1_LPDDR_PE_EN_256M_DEV_SIZE_SHIFT 0x11
#define XS1_LPDDR_PE_EN_256M_DEV_SIZE_SIZE 0x1
#define XS1_LPDDR_PE_EN_256M_DEV_SIZE_MASK (((1 << XS1_LPDDR_PE_EN_256M_DEV_SIZE_SIZE) - 1) << XS1_LPDDR_PE_EN_256M_DEV_SIZE_SHIFT)
/**
 * Extract the LPDDR_PE_EN_256M_DEV_SIZE bitfield from a packed word x and return it.
 */
#define XS1_LPDDR_PE_EN_256M_DEV_SIZE(x) (((x) & XS1_LPDDR_PE_EN_256M_DEV_SIZE_MASK) >> XS1_LPDDR_PE_EN_256M_DEV_SIZE_SHIFT)
/**
 * Pack the value (v) of the LPDDR_PE_EN_256M_DEV_SIZE bitfield into a packed word x and return the packed field.
 */
#define XS1_LPDDR_PE_EN_256M_DEV_SIZE_SET(x, v) (((x) & ~XS1_LPDDR_PE_EN_256M_DEV_SIZE_MASK) | (((v) << XS1_LPDDR_PE_EN_256M_DEV_SIZE_SHIFT) & XS1_LPDDR_PE_EN_256M_DEV_SIZE_MASK))
///@}
/**
 * \name PADCTRL_RECEIVER_ENABLE
 * \anchor PADCTRL_RECEIVER_ENABLE
 * Set to 1 to enable the input receiver
 */
///@{
#define XS1_PADCTRL_RECEIVER_ENABLE_SHIFT 0x0
#define XS1_PADCTRL_RECEIVER_ENABLE_SIZE 0x1
#define XS1_PADCTRL_RECEIVER_ENABLE_MASK (((1 << XS1_PADCTRL_RECEIVER_ENABLE_SIZE) - 1) << XS1_PADCTRL_RECEIVER_ENABLE_SHIFT)
/**
 * Extract the PADCTRL_RECEIVER_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_PADCTRL_RECEIVER_ENABLE(x) (((x) & XS1_PADCTRL_RECEIVER_ENABLE_MASK) >> XS1_PADCTRL_RECEIVER_ENABLE_SHIFT)
/**
 * Pack the value (v) of the PADCTRL_RECEIVER_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_PADCTRL_RECEIVER_ENABLE_SET(x, v) (((x) & ~XS1_PADCTRL_RECEIVER_ENABLE_MASK) | (((v) << XS1_PADCTRL_RECEIVER_ENABLE_SHIFT) & XS1_PADCTRL_RECEIVER_ENABLE_MASK))
///@}
/**
 * \name PADCTRL_PULL
 * \anchor PADCTRL_PULL
 * Pull resistor:
 *        00 for none;
 *        01 for weak pull-up;
 *        10 for weak pull-down; or
 *        11 for weak bus-keep.
 *       
 */
///@{
#define XS1_PADCTRL_PULL_SHIFT 0x1
#define XS1_PADCTRL_PULL_SIZE 0x2
#define XS1_PADCTRL_PULL_MASK (((1 << XS1_PADCTRL_PULL_SIZE) - 1) << XS1_PADCTRL_PULL_SHIFT)
/**
 * Extract the PADCTRL_PULL bitfield from a packed word x and return it.
 */
#define XS1_PADCTRL_PULL(x) (((x) & XS1_PADCTRL_PULL_MASK) >> XS1_PADCTRL_PULL_SHIFT)
/**
 * Pack the value (v) of the PADCTRL_PULL bitfield into a packed word x and return the packed field.
 */
#define XS1_PADCTRL_PULL_SET(x, v) (((x) & ~XS1_PADCTRL_PULL_MASK) | (((v) << XS1_PADCTRL_PULL_SHIFT) & XS1_PADCTRL_PULL_MASK))
///@}
/**
 * \name PADCTRL_DRIVE_STRENGTH
 * \anchor PADCTRL_DRIVE_STRENGTH
 * Pad drive strength:
 *        00 for 2 mA;
 *        01 for 4 mA;
 *        10 for 8 mA; or
 *        11 for 12 mA.
 *       
 */
///@{
#define XS1_PADCTRL_DRIVE_STRENGTH_SHIFT 0x3
#define XS1_PADCTRL_DRIVE_STRENGTH_SIZE 0x2
#define XS1_PADCTRL_DRIVE_STRENGTH_MASK (((1 << XS1_PADCTRL_DRIVE_STRENGTH_SIZE) - 1) << XS1_PADCTRL_DRIVE_STRENGTH_SHIFT)
/**
 * Extract the PADCTRL_DRIVE_STRENGTH bitfield from a packed word x and return it.
 */
#define XS1_PADCTRL_DRIVE_STRENGTH(x) (((x) & XS1_PADCTRL_DRIVE_STRENGTH_MASK) >> XS1_PADCTRL_DRIVE_STRENGTH_SHIFT)
/**
 * Pack the value (v) of the PADCTRL_DRIVE_STRENGTH bitfield into a packed word x and return the packed field.
 */
#define XS1_PADCTRL_DRIVE_STRENGTH_SET(x, v) (((x) & ~XS1_PADCTRL_DRIVE_STRENGTH_MASK) | (((v) << XS1_PADCTRL_DRIVE_STRENGTH_SHIFT) & XS1_PADCTRL_DRIVE_STRENGTH_MASK))
///@}
/**
 * \name PADCTRL_SLEW_RATE_CONTROL
 * \anchor PADCTRL_SLEW_RATE_CONTROL
 * Set to 1 to enable slew-rate control
 */
///@{
#define XS1_PADCTRL_SLEW_RATE_CONTROL_SHIFT 0x5
#define XS1_PADCTRL_SLEW_RATE_CONTROL_SIZE 0x1
#define XS1_PADCTRL_SLEW_RATE_CONTROL_MASK (((1 << XS1_PADCTRL_SLEW_RATE_CONTROL_SIZE) - 1) << XS1_PADCTRL_SLEW_RATE_CONTROL_SHIFT)
/**
 * Extract the PADCTRL_SLEW_RATE_CONTROL bitfield from a packed word x and return it.
 */
#define XS1_PADCTRL_SLEW_RATE_CONTROL(x) (((x) & XS1_PADCTRL_SLEW_RATE_CONTROL_MASK) >> XS1_PADCTRL_SLEW_RATE_CONTROL_SHIFT)
/**
 * Pack the value (v) of the PADCTRL_SLEW_RATE_CONTROL bitfield into a packed word x and return the packed field.
 */
#define XS1_PADCTRL_SLEW_RATE_CONTROL_SET(x, v) (((x) & ~XS1_PADCTRL_SLEW_RATE_CONTROL_MASK) | (((v) << XS1_PADCTRL_SLEW_RATE_CONTROL_SHIFT) & XS1_PADCTRL_SLEW_RATE_CONTROL_MASK))
///@}
/**
 * \name PADCTRL_SCHMITT_TRIGGER_ENABLE
 * \anchor PADCTRL_SCHMITT_TRIGGER_ENABLE
 * Set to 1 to enable the schmitt trigger
 */
///@{
#define XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_SHIFT 0x6
#define XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_SIZE 0x1
#define XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_MASK (((1 << XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_SIZE) - 1) << XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_SHIFT)
/**
 * Extract the PADCTRL_SCHMITT_TRIGGER_ENABLE bitfield from a packed word x and return it.
 */
#define XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE(x) (((x) & XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_MASK) >> XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_SHIFT)
/**
 * Pack the value (v) of the PADCTRL_SCHMITT_TRIGGER_ENABLE bitfield into a packed word x and return the packed field.
 */
#define XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_SET(x, v) (((x) & ~XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_MASK) | (((v) << XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_SHIFT) & XS1_PADCTRL_SCHMITT_TRIGGER_ENABLE_MASK))
///@}
/// @}
/**
 * \defgroup xs3aMiscellaneousDefinitions xs3a Miscellaneous Definitions
 * @{
 */
#define XS1_DEVICE_ID0_VERSION_VALUE 0x0
#define XS1_DEVICE_ID0_REVISION_VALUE 0x4
#define XS1_NUM_NETWORKS 0x4
/**
 * \name RESOURCE_TYPES_DEFS
 * \anchor RESOURCE_TYPES_DEFS
 * Resource types
 */
///@{
/**
 * Ports
 */
#define XS1_RES_TYPE_PORT 0x0
/**
 * Timers
 */
#define XS1_RES_TYPE_TIMER 0x1
/**
 * Channel ends
 */
#define XS1_RES_TYPE_CHANEND 0x2
/**
 * Synchronisers
 */
#define XS1_RES_TYPE_SYNC 0x3
/**
 * Threads
 */
#define XS1_RES_TYPE_THREAD 0x4
/**
 * Lock
 */
#define XS1_RES_TYPE_LOCK 0x5
/**
 * Clock source
 */
#define XS1_RES_TYPE_CLKBLK 0x6
/**
 * Co-processor interface/multicycle unit
 */
#define XS1_RES_TYPE_COPROC 0x7
/**
 * SWMEM management resource
 */
#define XS1_RES_TYPE_SWMEM 0x8
/**
 * Processor state
 */
#define XS1_RES_TYPE_PS 0xb
/**
 * Configuration messages
 */
#define XS1_RES_TYPE_CONFIG 0xc
/**
 * Instruction type
 */
#define XS1_RES_TYPE_INSTRUCTION 0xd
///@}
#define XS1_NUM_RES_TYPES 0x9
#define XS1_CLK_REF 0x1
#define XS1_CLK_XCORE 0x101
#define XS1_SWMEM_FILL 0x8
#define XS1_SWMEM_EVICT 0x108
/**
 * \name ClockBlocks_DEFS
 * \anchor ClockBlocks_DEFS
 */
///@{
#define XS1_CLKBLK_REF 0x6
#define XS1_CLKBLK_1 0x106
#define XS1_CLKBLK_2 0x206
#define XS1_CLKBLK_3 0x306
#define XS1_CLKBLK_4 0x406
#define XS1_CLKBLK_5 0x506
#define XS1_CLKBLK_6 0x606
#define XS1_CLKBLK_7 0x706
///@}
/**
 * \name EXCEPTION_TYPES_DEFS
 * \anchor EXCEPTION_TYPES_DEFS
 * Exceptions change
 *         the normal flow of control; they may be caused by
 *         interrupts, errors arising during instruction execution and by
 *         system calls. On
 *         an exception, the processor will save the ``pc`` and ``sr`` in ``spc`` and ``ssr``,
 *         disable events and interrupts, and start executing
 *         an exception handler. The program counter that is saved normally points to the instruction that raised the exception. Two registers are also set. The
 *         exception-data (``ed``) and
 *         exception-type (``et``) will be set to reflect the cause of the
 *         exception. The exception handler can choose how to deal with the
 *         exception.
 * 
 *         In this chapter the different types of exception are listed,
 *         together with their representation, their meaning, and the
 *         instructions that may cause them.
 *       
 */
///@{
/**
 * Link errors
 */
#define XS1_ET_LINK_ERROR 0x1
/**
 * see [[XcoreArchTraps#Illegal_PC][Illegal PC]]
 */
#define XS1_ET_ILLEGAL_PC 0x2
/**
 * see [[XcoreArchTraps#Illegal_instructionsPC][Illegal instructions]]
 */
#define XS1_ET_ILLEGAL_INSTRUCTION 0x3
/**
 * thread / synchroniser / channel end / port / lock
 */
#define XS1_ET_ILLEGAL_RESOURCE 0x4
/**
 * see [[XcoreArchTraps#Illegal_load_store][Illegal load/store]]
 */
#define XS1_ET_LOAD_STORE 0x5
/**
 * see [[XcoreArchMachineState#Traps][Traps]]
 */
#define XS1_ET_ILLEGAL_PS 0x6
/**
 * see [[XcoreArchTraps#Arithmetic_exceptions][Arithmetic exceptions]]
 */
#define XS1_ET_ARITHMETIC 0x7
/**
 * see [[XcoreArchTraps#Exception_calls][Exception calls]]
 */
#define XS1_ET_ECALL 0x8
/**
 * see [[XcoreArchResources#Back_to_Back_Access][Resource dependencies]]
 */
#define XS1_ET_RESOURCE_DEP 0x9
/**
 * see [[XcoreArchTraps#Kernel_calls][Kernel calls]]
 */
#define XS1_ET_KCALL 0xf
/**
 * Indicates exception took place in the resource lane
 */
#define XS1_ET_IOLANE 0x10
///@}
#define XS1_ET_NONE 0x0
#define XS1_RES_ID_INVALID 0x0
#define XS1_KEP_ALIGNMENT 0x80
#define XS1_KCALL_ALIGNMENT 0x40
#define XS1_TRAP_KCALL_OFFSET 0x40
#define XS1_ARG0_REG r0
#define XS1_ARG1_REG r1
#define XS1_ARG2_REG r2
#define XS1_ARG3_REG r3
#define XS1_RET0_REG r0
#define XS1_RET1_REG r1
#define XS1_RET2_REG r2
#define XS1_RET3_REG r3
/**
 * \name T_REG_VALUES_DEFS
 * \anchor T_REG_VALUES_DEFS
 * Thread state register numbers for debug.
 */
///@{
#define XS1_DBG_T_REG_CP_NUM 0xc
#define XS1_DBG_T_REG_DP_NUM 0xd
#define XS1_DBG_T_REG_SP_NUM 0xe
#define XS1_DBG_T_REG_LR_NUM 0xf
#define XS1_DBG_T_REG_PC_NUM 0x10
#define XS1_DBG_T_REG_SR_NUM 0x11
#define XS1_DBG_T_REG_SPC_NUM 0x12
#define XS1_DBG_T_REG_SSR_NUM 0x13
#define XS1_DBG_T_REG_ET_NUM 0x14
#define XS1_DBG_T_REG_ED_NUM 0x15
#define XS1_DBG_T_REG_SED_NUM 0x16
#define XS1_DBG_T_REG_KEP_NUM 0x17
#define XS1_DBG_T_REG_KSP_NUM 0x18
#define XS1_DBG_T_REG_ID_NUM 0x19
#define XS1_DBG_T_REG_VEC_NUM 0x1a
///@}
/**
 * \name STACK_OFFSET_DEFS
 * \anchor STACK_OFFSET_DEFS
 * Stack offsets for ld,st instructions.
 */
///@{
#define XS1_STACK_OFFSET_SPC 0x1
#define XS1_STACK_OFFSET_SSR 0x2
#define XS1_STACK_OFFSET_SED 0x3
#define XS1_STACK_OFFSET_ET 0x4
///@}
#define XS1_NUM_LOCKS 0x4
#define XS1_NUM_SYNCS 0x7
#define XS1_NUM_TIMERS 0xa
#define XS1_NUM_SWMEMS 0x2
#define XS1_NUM_THREADS 0x8
#define XS1_NUM_CHANENDS 0x20
#define XS1_NUM_CLKBLKS 0x6
#define XS1_NUM_MMAPS 0x10
#define XS1_NUM_WORDS_PER_VECTOR 0x8
#define XS1_DBG_BUFFER_WORDS 0x20
/**
 * \name DBG_CAUSE_DEFS
 * \anchor DBG_CAUSE_DEFS
 * Types of debug causes, with their value
 */
///@{
#define XS1_DBG_CAUSE_NONE 0x0
#define XS1_DBG_CAUSE_HOST 0x1
#define XS1_DBG_CAUSE_DCALL 0x2
#define XS1_DBG_CAUSE_IBREAK 0x3
#define XS1_DBG_CAUSE_DWATCH 0x4
#define XS1_DBG_CAUSE_RWATCH 0x5
///@}
/**
 * \name DEBUG_COMMANDS_DEFS
 * \anchor DEBUG_COMMANDS_DEFS
 * Debug commands.
 */
///@{
#define XS1_DBG_CMD_ACK 0x0
#define XS1_DBG_CMD_NACK 0x1
#define XS1_DBG_CMD_READ 0x2
#define XS1_DBG_CMD_WRITE 0x3
#define XS1_DBG_CMD_GETPS 0x4
#define XS1_DBG_CMD_SETPS 0x5
#define XS1_DBG_CMD_GETSTATE 0x6
#define XS1_DBG_CMD_SETSTATE 0x7
#define XS1_DBG_CMD_CALL 0x8
#define XS1_DBG_CMD_RFDBG 0x9
#define XS1_DBG_CMD_READ4PI 0xa
#define XS1_DBG_CMD_WRITE4PI 0xb
#define XS1_DBG_CMD_READVEC 0xc
#define XS1_DBG_CMD_WRITEVEC 0xd
#define XS1_DBG_CMD_READSSWITCH 0xe
#define XS1_DBG_CMD_WRITESSWITCH 0xf
///@}
/**
 * \name DB_SCRATCH_USAGE_DEFS
 * \anchor DB_SCRATCH_USAGE_DEFS
 * Debug scratch register usage.
 */
///@{
#define XS1_PS_DBG_HANDLER XS1_PS_DBG_SCRATCH_0
#define XS1_PS_DBG_COMMAND XS1_PS_DBG_SCRATCH_1
#define XS1_PS_DBG_ARG0_REG XS1_PS_DBG_SCRATCH_2
#define XS1_PS_DBG_ARG1_REG XS1_PS_DBG_SCRATCH_3
#define XS1_PS_DBG_ARG2_REG XS1_PS_DBG_SCRATCH_4
#define XS1_PS_DBG_ARG3_REG XS1_PS_DBG_SCRATCH_5
#define XS1_PS_DBG_ARG4_REG XS1_PS_DBG_SCRATCH_6
#define XS1_PS_DBG_ARG5_REG XS1_PS_DBG_SCRATCH_7
#define XS1_NUM_DBG_SCRATCH_REGS 0x8
#define XS1_LOG2_NUM_DBG_SCRATCH_REGS 0x3
#define XS1_PSWITCH_DBG_HANDLER_NUM XS1_PSWITCH_DBG_SCRATCH_0_NUM
#define XS1_PSWITCH_DBG_COMMAND_NUM XS1_PSWITCH_DBG_SCRATCH_1_NUM
#define XS1_PSWITCH_DBG_ARG0_NUM XS1_PSWITCH_DBG_SCRATCH_2_NUM
#define XS1_PSWITCH_DBG_ARG1_NUM XS1_PSWITCH_DBG_SCRATCH_3_NUM
#define XS1_PSWITCH_DBG_ARG2_NUM XS1_PSWITCH_DBG_SCRATCH_4_NUM
#define XS1_PSWITCH_DBG_ARG3_NUM XS1_PSWITCH_DBG_SCRATCH_5_NUM
#define XS1_PSWITCH_DBG_ARG4_NUM XS1_PSWITCH_DBG_SCRATCH_6_NUM
#define XS1_PSWITCH_DBG_ARG5_NUM XS1_PSWITCH_DBG_SCRATCH_7_NUM
///@}
/**
 * \name DBG_BREAKPOINTS_DEFS
 * \anchor DBG_BREAKPOINTS_DEFS
 * Debug breakpoints and watchpoints
 */
///@{
#define XS1_NUM_DBG_IBREAK 0x4
#define XS1_NUM_DBG_RWATCH 0x4
#define XS1_NUM_DBG_DWATCH 0x4
///@}
/**
 * \name EXTMEM_DEFS
 * \anchor EXTMEM_DEFS
 * External memory definitions.
 */
///@{
#define XS1_EXTMEM_BASE 0x10000000
#define XS1_EXTMEM_SIZE 0x10000000
#define XS1_EXTMEM_ADDR_WIDTH 0x1a
///@}
/**
 * \name SWMEM_DEFS
 * \anchor SWMEM_DEFS
 * Software defined memory definitions.
 */
///@{
#define XS1_SWMEM_BASE 0x40000000
#define XS1_SWMEM_SIZE 0x40000000
#define XS1_SWMEM_ADDR_WIDTH 0x1c
///@}
#define XS1_RAM_BASE 0x80000
#define XS1_RAM_SIZE 0x80000
#define XS1_RAM_ADDR_WIDTH 0x11
/**
 * \name ROM_DEFS
 * \anchor ROM_DEFS
 * ROM definitions.
 */
///@{
#define XS1_ROM_BASE 0xfff00000
#define XS1_ROM_SIZE 0x4000
#define XS1_ROM_ADDR_WIDTH 0xc
#define XS1_ROM_BASE_WIDTH 0x10
#define XS1_DEBUG_VECTOR 0xfff00004
///@}
/**
 * \name OTP_DEFS
 * \anchor OTP_DEFS
 * OTP reserved location definitinos.
 */
///@{
#define XS1_OTP_SECURITY_CONFIG_TILE_0_0 0x0
#define XS1_OTP_SECURITY_CONFIG_TILE_0_1 0x20
#define XS1_OTP_SECURITY_CONFIG_TILE_1_0 0x1
#define XS1_OTP_SECURITY_CONFIG_TILE_1_1 0x21
#define XS1_OTP_DAP_RFMR_0 0x2
#define XS1_OTP_DAP_RFMR_1 0x22
#define XS1_OTP_HOBBLING_CONFIG_0 0x3
#define XS1_OTP_HOBBLING_CONFIG_1 0x23
#define XS1_OTP_JTAG_USER_CONFIG_0 0x4
#define XS1_OTP_JTAG_USER_CONFIG_1 0x24
#define XS1_OTP_SBPI_PMC_ADDRESS 0x3a
#define XS1_OTP_SBPI_DAP_ADDRESS 0x2
#define XS1_OTP_PMC_START_INSTRUCTION 0x1
#define XS1_OTP_PMC_STOP_INSTRUCTION 0x2
#define XS1_OTP_PMC_NOP_INSTRUCTION 0x0
#define XS1_OTP_PMC_DAP_RDF 0x80
#define XS1_OTP_PMC_DAP_WDF 0xc0
#define XS1_OTP_PMC_BOOT_TIMING_CTRL_0_ADDR 0x38
#define XS1_OTP_DAP_RFMR_ADDR 0x30
///@}
/**
 * \name OTPA_DEFS
 * \anchor OTPA_DEFS
 * OTPA (arbiter) definitions.
 */
///@{
#define XS1_OTPA_SEL_SBPI 0x0
#define XS1_OTPA_SEL_Q 0x1
#define XS1_OTPA_SEL_Q_MIXED 0x2
#define XS1_OTPA_SEL_QSR_LOWER 0x3
#define XS1_OTPA_SEL_QRR_LOWER 0x4
///@}
/**
 * \name USER_CONTROL_TOKENS_DEFS
 * \anchor USER_CONTROL_TOKENS_DEFS
 * User control tokens.
 */
///@{
/**
 * Start transaction.
 */
#define XS1_CT_START_TRANSACTION 0x0
/**
 * End - free up interconnect and tell target.
 */
#define XS1_CT_END 0x1
/**
 * End with control token bit set - free up interconnect and tell target.
 */
#define XS1_EOM_TOKEN 0x101
/**
 * Pause - free up interconnect but don't tell target.
 */
#define XS1_CT_PAUSE 0x2
/**
 * Pause with control token bit set - free up interconnect but don't tell target.
 */
#define XS1_PAUSE_TOKEN 0x102
/**
 * Acknowledge operation completed successfully.
 */
#define XS1_CT_ACK 0x3
/**
 * Acknowledge with control token bit set - operation completed successfully.
 */
#define XS1_ACK_TOKEN 0x103
/**
 * Acknowledge that there was an error.
 */
#define XS1_CT_NACK 0x4
/**
 * Acknowledge that there was an error with control token bit set.
 */
#define XS1_NACK_TOKEN 0x104
/**
 * Read data.
 */
#define XS1_CT_READN 0x10
/**
 * Read one byte.
 */
#define XS1_CT_READ1 0x11
/**
 * Read two bytes.
 */
#define XS1_CT_READ2 0x12
/**
 * Read four bytes.
 */
#define XS1_CT_READ4 0x13
/**
 * Read eight bytes.
 */
#define XS1_CT_READ8 0x14
/**
 * Write data.
 */
#define XS1_CT_WRITEN 0x15
/**
 * Write one byte.
 */
#define XS1_CT_WRITE1 0x16
/**
 * Write two bytes.
 */
#define XS1_CT_WRITE2 0x17
/**
 * Write four bytes.
 */
#define XS1_CT_WRITE4 0x18
/**
 * Write eight bytes.
 */
#define XS1_CT_WRITE8 0x19
/**
 * Call code at the specified address.
 */
#define XS1_CT_CALL 0x1a
///@}
/**
 * Write control register.
 */
#define XS1_CT_WRITEC 0xc0
/**
 * Read control register.
 */
#define XS1_CT_READC 0xc1
/**
 * PSwitch configuration message data value.
 */
#define XS1_CT_PSCTRL 0xc2
/**
 * SSwitch configuration message data value.
 */
#define XS1_CT_SSCTRL 0xc3
/**
 * \name RESOURCE_CREGS_DEFS
 * \anchor RESOURCE_CREGS_DEFS
 * Resource control registers.
 */
///@{
#define XS1_RES_PS_CTRL0 0x0
#define XS1_RES_PS_CTRL1 0x1
#define XS1_RES_PS_CTRL2 0x2
#define XS1_RES_PS_VECTOR 0x3
#define XS1_RES_PS_EV 0x4
#define XS1_RES_PS_DATA 0x5
#define XS1_RES_PS_CLKSRC 0x6
#define XS1_RES_PS_RDYSRC 0x7
#define XS1_RES_PS_TBV0 0x8
///@}
/**
 * \name VSETCTRL_SHIFT_DEFS
 * \anchor VSETCTRL_SHIFT_DEFS
 */
///@{
#define XS1_VSETC_SHIFT_NOSHIFT 0x0
#define XS1_VSETC_SHIFT_SHIFTLEFT 0x1
#define XS1_VSETC_SHIFT_SHIFTRIGHT 0x2
///@}
/**
 * \name VSETCTRL_TYPE_DEFS
 * \anchor VSETCTRL_TYPE_DEFS
 */
///@{
#define XS1_VSETC_TYPE_INT32 0x0
#define XS1_VSETC_TYPE_INT16 0x1
#define XS1_VSETC_TYPE_INT8 0x2
///@}
/**
 * \name SETCTRL_MODES_DEFS
 * \anchor SETCTRL_MODES_DEFS
 */
///@{
#define XS1_SETC_MODE_INUSE 0x0
#define XS1_SETC_MODE_COND 0x1
#define XS1_SETC_MODE_IE_MODE 0x2
#define XS1_SETC_MODE_DRIVE 0x3
#define XS1_SETC_MODE_SETPADCTRL 0x6
#define XS1_SETC_MODE_LONG 0x7
///@}
/**
 * \name SETCTRL_LMODE_DEFS
 * \anchor SETCTRL_LMODE_DEFS
 */
///@{
#define XS1_SETC_LMODE_RUN 0x0
#define XS1_SETC_LMODE_MS 0x1
#define XS1_SETC_LMODE_BUF 0x2
#define XS1_SETC_LMODE_RDY 0x3
#define XS1_SETC_LMODE_SDELAY 0x4
#define XS1_SETC_LMODE_PORT 0x5
#define XS1_SETC_LMODE_INV 0x6
#define XS1_SETC_LMODE_PIN_DELAY 0x7
#define XS1_SETC_LMODE_FALL_DELAY 0x8
#define XS1_SETC_LMODE_RISE_DELAY 0x9
///@}
/**
 * \name CTRL_MODE_DEFS
 * \anchor CTRL_MODE_DEFS
 */
///@{
#define XS1_SETC_INUSE_OFF 0x0
#define XS1_SETC_INUSE_ON 0x8
#define XS1_SETC_COND_NONE 0x1
#define XS1_SETC_COND_FULL 0x1
#define XS1_SETC_COND_AFTER 0x9
#define XS1_SETC_COND_EQ 0x11
#define XS1_SETC_COND_NEQ 0x19
#define XS1_SETC_COND_GREATER 0x21
#define XS1_SETC_COND_LESS 0x29
#define XS1_SETC_IE_MODE_EVENT 0x2
#define XS1_SETC_IE_MODE_INTERRUPT 0xa
#define XS1_SETC_DRIVE_DRIVE 0x3
#define XS1_SETC_DRIVE_PULL_DOWN 0xb
#define XS1_SETC_DRIVE_PULL_UP 0x13
#define XS1_SETC_RUN_STOPR 0x7
#define XS1_SETC_RUN_STARTR 0xf
#define XS1_SETC_RUN_CLRBUF 0x17
#define XS1_SETC_MS_MASTER 0x1007
#define XS1_SETC_MS_SLAVE 0x100f
#define XS1_SETC_BUF_NOBUFFERS 0x2007
#define XS1_SETC_BUF_BUFFERS 0x200f
#define XS1_SETC_RDY_NOREADY 0x3007
#define XS1_SETC_RDY_STROBED 0x300f
#define XS1_SETC_RDY_HANDSHAKE 0x3017
#define XS1_SETC_SDELAY_NOSDELAY 0x4007
#define XS1_SETC_SDELAY_SDELAY 0x400f
#define XS1_SETC_PORT_DATAPORT 0x5007
#define XS1_SETC_PORT_CLOCKPORT 0x500f
#define XS1_SETC_PORT_READYPORT 0x5017
#define XS1_SETC_INV_NOINVERT 0x6007
#define XS1_SETC_INV_INVERT 0x600f
///@}
#define XS1_XMOS_PHY_CONF_WIDTH 0x3
#define XS1_USB_PHY_VCONTROL_SETUP_LENGTH 0x6
#define XS1_USB_PHY_ENTER_BIST_LENGTH 0x40
#define XS1_USB_PHY_CLKCNT_WIDTH 0x4
#define XS1_USB_BISTGO_CTR_WIDTH 0x4
#define XS1_USB_TESTGO_CTR_WIDTH 0x4
#define XS1_USB_TESTGO_PULSE_LENGTH 0x8
#define XS1_USB_BISTGO_PULSE_LENGTH 0x8
#define XS1_CRC5_RESULT_WIDTH 0x5
#define XS1_MS_NIBBLE "7:4"
#define XS1_LS_NIBBLE "3:0"
/// @}
/**
 * \defgroup xs3aPortDefinitions xs3a Port Definitions
 * @{
 */
/* gpio ports*/
#define XS1_NUM_1BIT_GPIO_PORTS 0x10
#define XS1_NUM_4BIT_GPIO_PORTS 0x6
#define XS1_NUM_8BIT_GPIO_PORTS 0x4
#define XS1_NUM_16BIT_GPIO_PORTS 0x2
#define XS1_NUM_32BIT_GPIO_PORTS 0x1
/* periph ports*/
#define XS1_NUM_16BIT_PERIPH_PORTS 0x2
#define XS1_NUM_32BIT_PERIPH_PORTS 0x1
/* Totals*/
#define XS1_NUM_1BIT_PORTS 0x10
#define XS1_NUM_4BIT_PORTS 0x6
#define XS1_NUM_8BIT_PORTS 0x4
#define XS1_NUM_16BIT_PORTS 0x4
#define XS1_NUM_32BIT_PORTS 0x2
/// @}
#endif /* _xs3a_defines_H_ */
